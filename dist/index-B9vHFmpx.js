var G0 = Object.defineProperty;
var H0 = (i, t, e) => t in i ? G0(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;
var mt = (i, t, e) => H0(i, typeof t != "symbol" ? t + "" : t, e);
var W0 = Object.defineProperty, q0 = (i, t, e) => t in i ? W0(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, Ae = (i, t, e) => q0(i, typeof t != "symbol" ? t + "" : t, e);
const W = {
  gameName: "",
  gameContainer: document.body,
  maxFPS: 60,
  debug: !1,
  assets: {
    basePath: "/assets",
    manifest: {},
    extra: []
  },
  colors: {
    backgroundColor: "#000000"
  },
  screen: {
    width: 1280,
    aspectRatio: 1.7777777777777777
  },
  tickIntervalMillis: 16,
  loadingScene: {
    fontFamily: "Arial, sans-serif",
    fontSize: 28,
    textColor: 16777215,
    keepAliveTimeMS: 2e3,
    text: "Loading..."
  },
  pauseScene: {
    overlayColor: 0,
    overlayAlpha: 0.8,
    fontFamily: "Arial, sans-serif",
    titleFontSize: 48,
    subTitleFontSize: 28,
    textColor: 16777215,
    title: "Paused",
    subTitle: "Click/tap to continue"
  },
  signals: {
    onResize: "onResize",
    onOrientationChange: "onOrientationChange",
    onTick: "onTick",
    destroyLoadingScene: "destroyLoadingScene"
  },
  sounds: {
    click: "click"
  }
}, tt = {
  screen: {
    orientation: "landscape",
    width: 0,
    height: 0
  },
  scene: null,
  muted: localStorage.getItem("muted") === "true"
};
var X = /* @__PURE__ */ ((i) => (i.Application = "application", i.WebGLPipes = "webgl-pipes", i.WebGLPipesAdaptor = "webgl-pipes-adaptor", i.WebGLSystem = "webgl-system", i.WebGPUPipes = "webgpu-pipes", i.WebGPUPipesAdaptor = "webgpu-pipes-adaptor", i.WebGPUSystem = "webgpu-system", i.CanvasSystem = "canvas-system", i.CanvasPipesAdaptor = "canvas-pipes-adaptor", i.CanvasPipes = "canvas-pipes", i.Asset = "asset", i.LoadParser = "load-parser", i.ResolveParser = "resolve-parser", i.CacheParser = "cache-parser", i.DetectionParser = "detection-parser", i.MaskEffect = "mask-effect", i.BlendMode = "blend-mode", i.TextureSource = "texture-source", i.Environment = "environment", i.ShapeBuilder = "shape-builder", i.Batcher = "batcher", i))(X || {});
const sh = (i) => {
  if (typeof i == "function" || typeof i == "object" && i.extension) {
    if (!i.extension)
      throw new Error("Extension class must have an extension object");
    i = { ...typeof i.extension != "object" ? { type: i.extension } : i.extension, ref: i };
  }
  if (typeof i == "object")
    i = { ...i };
  else
    throw new Error("Invalid extension type");
  return typeof i.type == "string" && (i.type = [i.type]), i;
}, _o = (i, t) => sh(i).priority ?? t, ge = {
  /** @ignore */
  _addHandlers: {},
  /** @ignore */
  _removeHandlers: {},
  /** @ignore */
  _queue: {},
  /**
   * Remove extensions from PixiJS.
   * @param extensions - Extensions to be removed.
   * @returns {extensions} For chaining.
   */
  remove(...i) {
    return i.map(sh).forEach((t) => {
      t.type.forEach((e) => {
        var n, r;
        return (r = (n = this._removeHandlers)[e]) == null ? void 0 : r.call(n, t);
      });
    }), this;
  },
  /**
   * Register new extensions with PixiJS.
   * @param extensions - The spread of extensions to add to PixiJS.
   * @returns {extensions} For chaining.
   */
  add(...i) {
    return i.map(sh).forEach((t) => {
      t.type.forEach((e) => {
        var n, r;
        const s = this._addHandlers, o = this._queue;
        s[e] ? (r = s[e]) == null || r.call(s, t) : (o[e] = o[e] || [], (n = o[e]) == null || n.push(t));
      });
    }), this;
  },
  /**
   * Internal method to handle extensions by name.
   * @param type - The extension type.
   * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.
   * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.
   * @returns {extensions} For chaining.
   */
  handle(i, t, e) {
    var n;
    const r = this._addHandlers, s = this._removeHandlers;
    if (r[i] || s[i])
      throw new Error(`Extension type ${i} already has a handler`);
    r[i] = t, s[i] = e;
    const o = this._queue;
    return o[i] && ((n = o[i]) == null || n.forEach((a) => t(a)), delete o[i]), this;
  },
  /**
   * Handle a type, but using a map by `name` property.
   * @param type - Type of extension to handle.
   * @param map - The object map of named extensions.
   * @returns {extensions} For chaining.
   */
  handleByMap(i, t) {
    return this.handle(
      i,
      (e) => {
        e.name && (t[e.name] = e.ref);
      },
      (e) => {
        e.name && delete t[e.name];
      }
    );
  },
  /**
   * Handle a type, but using a list of extensions with a `name` property.
   * @param type - Type of extension to handle.
   * @param map - The array of named extensions.
   * @param defaultPriority - Fallback priority if none is defined.
   * @returns {extensions} For chaining.
   */
  handleByNamedList(i, t, e = -1) {
    return this.handle(
      i,
      (n) => {
        t.findIndex((r) => r.name === n.name) >= 0 || (t.push({ name: n.name, value: n.ref }), t.sort((r, s) => _o(s.value, e) - _o(r.value, e)));
      },
      (n) => {
        const r = t.findIndex((s) => s.name === n.name);
        r !== -1 && t.splice(r, 1);
      }
    );
  },
  /**
   * Handle a type, but using a list of extensions.
   * @param type - Type of extension to handle.
   * @param list - The list of extensions.
   * @param defaultPriority - The default priority to use if none is specified.
   * @returns {extensions} For chaining.
   */
  handleByList(i, t, e = -1) {
    return this.handle(
      i,
      (n) => {
        t.includes(n.ref) || (t.push(n.ref), t.sort((r, s) => _o(s, e) - _o(r, e)));
      },
      (n) => {
        const r = t.indexOf(n.ref);
        r !== -1 && t.splice(r, 1);
      }
    );
  }
}, Y0 = {
  extension: {
    type: X.Environment,
    name: "browser",
    priority: -1
  },
  test: () => !0,
  load: async () => {
    await import("./browserAll-BpoGT0PN-CMDsOsig.js");
  }
}, X0 = {
  extension: {
    type: X.Environment,
    name: "webworker",
    priority: 0
  },
  test: () => typeof self < "u" && self.WorkerGlobalScope !== void 0,
  load: async () => {
    await import("./webworkerAll-DQbc7pxG-WTZIbVh7.js");
  }
};
class Wt {
  /**
   * Creates a new `ObservablePoint`
   * @param observer - Observer to pass to listen for change events.
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(t, e, n) {
    this._x = e || 0, this._y = n || 0, this._observer = t;
  }
  /**
   * Creates a clone of this point.
   * @param observer - Optional observer to pass to the new observable point.
   * @returns a copy of this observable point
   */
  clone(t) {
    return new Wt(t ?? this._observer, this._x, this._y);
  }
  /**
   * Sets the point to a new `x` and `y` position.
   * If `y` is omitted, both `x` and `y` will be set to `x`.
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=x] - position of the point on the y axis
   * @returns The observable point instance itself
   */
  set(t = 0, e = t) {
    return (this._x !== t || this._y !== e) && (this._x = t, this._y = e, this._observer._onUpdate(this)), this;
  }
  /**
   * Copies x and y from the given point (`p`)
   * @param p - The point to copy from. Can be any of type that is or extends `PointData`
   * @returns The observable point instance itself
   */
  copyFrom(t) {
    return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this._observer._onUpdate(this)), this;
  }
  /**
   * Copies this point's x and y into that of the given point (`p`)
   * @param p - The point to copy to. Can be any of type that is or extends `PointData`
   * @returns The point (`p`) with values updated
   */
  copyTo(t) {
    return t.set(this._x, this._y), t;
  }
  /**
   * Accepts another point (`p`) and returns `true` if the given point is equal to this point
   * @param p - The point to check
   * @returns Returns `true` if both `x` and `y` are equal
   */
  equals(t) {
    return t.x === this._x && t.y === this._y;
  }
  toString() {
    return `[pixi.js/math:ObservablePoint x=0 y=0 scope=${this._observer}]`;
  }
  /** Position of the observable point on the x axis. */
  get x() {
    return this._x;
  }
  set x(t) {
    this._x !== t && (this._x = t, this._observer._onUpdate(this));
  }
  /** Position of the observable point on the y axis. */
  get y() {
    return this._y;
  }
  set y(t) {
    this._y !== t && (this._y = t, this._observer._onUpdate(this));
  }
}
var xn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function cc(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var vf = { exports: {} };
(function(i) {
  var t = Object.prototype.hasOwnProperty, e = "~";
  function n() {
  }
  Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (e = !1));
  function r(l, h, c) {
    this.fn = l, this.context = h, this.once = c || !1;
  }
  function s(l, h, c, p, f) {
    if (typeof c != "function")
      throw new TypeError("The listener must be a function");
    var d = new r(c, p || l, f), m = e ? e + h : h;
    return l._events[m] ? l._events[m].fn ? l._events[m] = [l._events[m], d] : l._events[m].push(d) : (l._events[m] = d, l._eventsCount++), l;
  }
  function o(l, h) {
    --l._eventsCount === 0 ? l._events = new n() : delete l._events[h];
  }
  function a() {
    this._events = new n(), this._eventsCount = 0;
  }
  a.prototype.eventNames = function() {
    var l = [], h, c;
    if (this._eventsCount === 0) return l;
    for (c in h = this._events)
      t.call(h, c) && l.push(e ? c.slice(1) : c);
    return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(h)) : l;
  }, a.prototype.listeners = function(l) {
    var h = e ? e + l : l, c = this._events[h];
    if (!c) return [];
    if (c.fn) return [c.fn];
    for (var p = 0, f = c.length, d = new Array(f); p < f; p++)
      d[p] = c[p].fn;
    return d;
  }, a.prototype.listenerCount = function(l) {
    var h = e ? e + l : l, c = this._events[h];
    return c ? c.fn ? 1 : c.length : 0;
  }, a.prototype.emit = function(l, h, c, p, f, d) {
    var m = e ? e + l : l;
    if (!this._events[m]) return !1;
    var g = this._events[m], y = arguments.length, b, S;
    if (g.fn) {
      switch (g.once && this.removeListener(l, g.fn, void 0, !0), y) {
        case 1:
          return g.fn.call(g.context), !0;
        case 2:
          return g.fn.call(g.context, h), !0;
        case 3:
          return g.fn.call(g.context, h, c), !0;
        case 4:
          return g.fn.call(g.context, h, c, p), !0;
        case 5:
          return g.fn.call(g.context, h, c, p, f), !0;
        case 6:
          return g.fn.call(g.context, h, c, p, f, d), !0;
      }
      for (S = 1, b = new Array(y - 1); S < y; S++)
        b[S - 1] = arguments[S];
      g.fn.apply(g.context, b);
    } else {
      var C = g.length, I;
      for (S = 0; S < C; S++)
        switch (g[S].once && this.removeListener(l, g[S].fn, void 0, !0), y) {
          case 1:
            g[S].fn.call(g[S].context);
            break;
          case 2:
            g[S].fn.call(g[S].context, h);
            break;
          case 3:
            g[S].fn.call(g[S].context, h, c);
            break;
          case 4:
            g[S].fn.call(g[S].context, h, c, p);
            break;
          default:
            if (!b) for (I = 1, b = new Array(y - 1); I < y; I++)
              b[I - 1] = arguments[I];
            g[S].fn.apply(g[S].context, b);
        }
    }
    return !0;
  }, a.prototype.on = function(l, h, c) {
    return s(this, l, h, c, !1);
  }, a.prototype.once = function(l, h, c) {
    return s(this, l, h, c, !0);
  }, a.prototype.removeListener = function(l, h, c, p) {
    var f = e ? e + l : l;
    if (!this._events[f]) return this;
    if (!h)
      return o(this, f), this;
    var d = this._events[f];
    if (d.fn)
      d.fn === h && (!p || d.once) && (!c || d.context === c) && o(this, f);
    else {
      for (var m = 0, g = [], y = d.length; m < y; m++)
        (d[m].fn !== h || p && !d[m].once || c && d[m].context !== c) && g.push(d[m]);
      g.length ? this._events[f] = g.length === 1 ? g[0] : g : o(this, f);
    }
    return this;
  }, a.prototype.removeAllListeners = function(l) {
    var h;
    return l ? (h = e ? e + l : l, this._events[h] && o(this, h)) : (this._events = new n(), this._eventsCount = 0), this;
  }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = e, a.EventEmitter = a, i.exports = a;
})(vf);
var K0 = vf.exports;
const xe = /* @__PURE__ */ cc(K0), Q0 = Math.PI * 2, J0 = 180 / Math.PI, Z0 = Math.PI / 180;
class me {
  /**
   * Creates a new `Point`
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(t = 0, e = 0) {
    this.x = 0, this.y = 0, this.x = t, this.y = e;
  }
  /**
   * Creates a clone of this point
   * @returns A clone of this point
   */
  clone() {
    return new me(this.x, this.y);
  }
  /**
   * Copies `x` and `y` from the given point into this point
   * @param p - The point to copy from
   * @returns The point instance itself
   */
  copyFrom(t) {
    return this.set(t.x, t.y), this;
  }
  /**
   * Copies this point's x and y into the given point (`p`).
   * @param p - The point to copy to. Can be any of type that is or extends `PointData`
   * @returns The point (`p`) with values updated
   */
  copyTo(t) {
    return t.set(this.x, this.y), t;
  }
  /**
   * Accepts another point (`p`) and returns `true` if the given point is equal to this point
   * @param p - The point to check
   * @returns Returns `true` if both `x` and `y` are equal
   */
  equals(t) {
    return t.x === this.x && t.y === this.y;
  }
  /**
   * Sets the point to a new `x` and `y` position.
   * If `y` is omitted, both `x` and `y` will be set to `x`.
   * @param {number} [x=0] - position of the point on the `x` axis
   * @param {number} [y=x] - position of the point on the `y` axis
   * @returns The point instance itself
   */
  set(t = 0, e = t) {
    return this.x = t, this.y = e, this;
  }
  toString() {
    return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
  }
  /**
   * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.
   * @readonly
   */
  static get shared() {
    return pl.x = 0, pl.y = 0, pl;
  }
}
const pl = new me();
class ct {
  /**
   * @param a - x scale
   * @param b - y skew
   * @param c - x skew
   * @param d - y scale
   * @param tx - x translation
   * @param ty - y translation
   */
  constructor(t = 1, e = 0, n = 0, r = 1, s = 0, o = 0) {
    this.array = null, this.a = t, this.b = e, this.c = n, this.d = r, this.tx = s, this.ty = o;
  }
  /**
   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
   *
   * a = array[0]
   * b = array[1]
   * c = array[3]
   * d = array[4]
   * tx = array[2]
   * ty = array[5]
   * @param array - The array that the matrix will be populated from.
   */
  fromArray(t) {
    this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5];
  }
  /**
   * Sets the matrix properties.
   * @param a - Matrix component
   * @param b - Matrix component
   * @param c - Matrix component
   * @param d - Matrix component
   * @param tx - Matrix component
   * @param ty - Matrix component
   * @returns This matrix. Good for chaining method calls.
   */
  set(t, e, n, r, s, o) {
    return this.a = t, this.b = e, this.c = n, this.d = r, this.tx = s, this.ty = o, this;
  }
  /**
   * Creates an array from the current Matrix object.
   * @param transpose - Whether we need to transpose the matrix or not
   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out
   * @returns The newly created array which contains the matrix
   */
  toArray(t, e) {
    this.array || (this.array = new Float32Array(9));
    const n = e || this.array;
    return t ? (n[0] = this.a, n[1] = this.b, n[2] = 0, n[3] = this.c, n[4] = this.d, n[5] = 0, n[6] = this.tx, n[7] = this.ty, n[8] = 1) : (n[0] = this.a, n[1] = this.c, n[2] = this.tx, n[3] = this.b, n[4] = this.d, n[5] = this.ty, n[6] = 0, n[7] = 0, n[8] = 1), n;
  }
  /**
   * Get a new position with the current transformation applied.
   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
   * @param pos - The origin
   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
   * @returns {Point} The new point, transformed through this matrix
   */
  apply(t, e) {
    e = e || new me();
    const n = t.x, r = t.y;
    return e.x = this.a * n + this.c * r + this.tx, e.y = this.b * n + this.d * r + this.ty, e;
  }
  /**
   * Get a new position with the inverse of the current transformation applied.
   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
   * @param pos - The origin
   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
   * @returns {Point} The new point, inverse-transformed through this matrix
   */
  applyInverse(t, e) {
    e = e || new me();
    const n = this.a, r = this.b, s = this.c, o = this.d, a = this.tx, l = this.ty, h = 1 / (n * o + s * -r), c = t.x, p = t.y;
    return e.x = o * h * c + -s * h * p + (l * s - a * o) * h, e.y = n * h * p + -r * h * c + (-l * n + a * r) * h, e;
  }
  /**
   * Translates the matrix on the x and y.
   * @param x - How much to translate x by
   * @param y - How much to translate y by
   * @returns This matrix. Good for chaining method calls.
   */
  translate(t, e) {
    return this.tx += t, this.ty += e, this;
  }
  /**
   * Applies a scale transformation to the matrix.
   * @param x - The amount to scale horizontally
   * @param y - The amount to scale vertically
   * @returns This matrix. Good for chaining method calls.
   */
  scale(t, e) {
    return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this;
  }
  /**
   * Applies a rotation transformation to the matrix.
   * @param angle - The angle in radians.
   * @returns This matrix. Good for chaining method calls.
   */
  rotate(t) {
    const e = Math.cos(t), n = Math.sin(t), r = this.a, s = this.c, o = this.tx;
    return this.a = r * e - this.b * n, this.b = r * n + this.b * e, this.c = s * e - this.d * n, this.d = s * n + this.d * e, this.tx = o * e - this.ty * n, this.ty = o * n + this.ty * e, this;
  }
  /**
   * Appends the given Matrix to this Matrix.
   * @param matrix - The matrix to append.
   * @returns This matrix. Good for chaining method calls.
   */
  append(t) {
    const e = this.a, n = this.b, r = this.c, s = this.d;
    return this.a = t.a * e + t.b * r, this.b = t.a * n + t.b * s, this.c = t.c * e + t.d * r, this.d = t.c * n + t.d * s, this.tx = t.tx * e + t.ty * r + this.tx, this.ty = t.tx * n + t.ty * s + this.ty, this;
  }
  /**
   * Appends two matrix's and sets the result to this matrix. AB = A * B
   * @param a - The matrix to append.
   * @param b - The matrix to append.
   * @returns This matrix. Good for chaining method calls.
   */
  appendFrom(t, e) {
    const n = t.a, r = t.b, s = t.c, o = t.d, a = t.tx, l = t.ty, h = e.a, c = e.b, p = e.c, f = e.d;
    return this.a = n * h + r * p, this.b = n * c + r * f, this.c = s * h + o * p, this.d = s * c + o * f, this.tx = a * h + l * p + e.tx, this.ty = a * c + l * f + e.ty, this;
  }
  /**
   * Sets the matrix based on all the available properties
   * @param x - Position on the x axis
   * @param y - Position on the y axis
   * @param pivotX - Pivot on the x axis
   * @param pivotY - Pivot on the y axis
   * @param scaleX - Scale on the x axis
   * @param scaleY - Scale on the y axis
   * @param rotation - Rotation in radians
   * @param skewX - Skew on the x axis
   * @param skewY - Skew on the y axis
   * @returns This matrix. Good for chaining method calls.
   */
  setTransform(t, e, n, r, s, o, a, l, h) {
    return this.a = Math.cos(a + h) * s, this.b = Math.sin(a + h) * s, this.c = -Math.sin(a - l) * o, this.d = Math.cos(a - l) * o, this.tx = t - (n * this.a + r * this.c), this.ty = e - (n * this.b + r * this.d), this;
  }
  /**
   * Prepends the given Matrix to this Matrix.
   * @param matrix - The matrix to prepend
   * @returns This matrix. Good for chaining method calls.
   */
  prepend(t) {
    const e = this.tx;
    if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
      const n = this.a, r = this.c;
      this.a = n * t.a + this.b * t.c, this.b = n * t.b + this.b * t.d, this.c = r * t.a + this.d * t.c, this.d = r * t.b + this.d * t.d;
    }
    return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this;
  }
  /**
   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
   * @param transform - The transform to apply the properties to.
   * @returns The transform with the newly applied properties
   */
  decompose(t) {
    const e = this.a, n = this.b, r = this.c, s = this.d, o = t.pivot, a = -Math.atan2(-r, s), l = Math.atan2(n, e), h = Math.abs(a + l);
    return h < 1e-5 || Math.abs(Q0 - h) < 1e-5 ? (t.rotation = l, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = a, t.skew.y = l), t.scale.x = Math.sqrt(e * e + n * n), t.scale.y = Math.sqrt(r * r + s * s), t.position.x = this.tx + (o.x * e + o.y * r), t.position.y = this.ty + (o.x * n + o.y * s), t;
  }
  /**
   * Inverts this matrix
   * @returns This matrix. Good for chaining method calls.
   */
  invert() {
    const t = this.a, e = this.b, n = this.c, r = this.d, s = this.tx, o = t * r - e * n;
    return this.a = r / o, this.b = -e / o, this.c = -n / o, this.d = t / o, this.tx = (n * this.ty - r * s) / o, this.ty = -(t * this.ty - e * s) / o, this;
  }
  /** Checks if this matrix is an identity matrix */
  isIdentity() {
    return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
  }
  /**
   * Resets this Matrix to an identity (default) matrix.
   * @returns This matrix. Good for chaining method calls.
   */
  identity() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
  }
  /**
   * Creates a new Matrix object with the same values as this one.
   * @returns A copy of this matrix. Good for chaining method calls.
   */
  clone() {
    const t = new ct();
    return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
  }
  /**
   * Changes the values of the given matrix to be the same as the ones in this matrix
   * @param matrix - The matrix to copy to.
   * @returns The matrix given in parameter with its values updated.
   */
  copyTo(t) {
    return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
  }
  /**
   * Changes the values of the matrix to be the same as the ones in given matrix
   * @param matrix - The matrix to copy from.
   * @returns this
   */
  copyFrom(t) {
    return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this;
  }
  /**
   * check to see if two matrices are the same
   * @param matrix - The matrix to compare to.
   */
  equals(t) {
    return t.a === this.a && t.b === this.b && t.c === this.c && t.d === this.d && t.tx === this.tx && t.ty === this.ty;
  }
  toString() {
    return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
  }
  /**
   * A default (identity) matrix.
   *
   * This is a shared object, if you want to modify it consider creating a new `Matrix`
   * @readonly
   */
  static get IDENTITY() {
    return tv.identity();
  }
  /**
   * A static Matrix that can be used to avoid creating new objects.
   * Will always ensure the matrix is reset to identity when requested.
   * Use this object for fast but temporary calculations, as it may be mutated later on.
   * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.
   * @readonly
   */
  static get shared() {
    return $0.identity();
  }
}
const $0 = new ct(), tv = new ct(), fn = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], mn = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], gn = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], yn = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], oh = [], _f = [], xo = Math.sign;
function ev() {
  for (let i = 0; i < 16; i++) {
    const t = [];
    oh.push(t);
    for (let e = 0; e < 16; e++) {
      const n = xo(fn[i] * fn[e] + gn[i] * mn[e]), r = xo(mn[i] * fn[e] + yn[i] * mn[e]), s = xo(fn[i] * gn[e] + gn[i] * yn[e]), o = xo(mn[i] * gn[e] + yn[i] * yn[e]);
      for (let a = 0; a < 16; a++)
        if (fn[a] === n && mn[a] === r && gn[a] === s && yn[a] === o) {
          t.push(a);
          break;
        }
    }
  }
  for (let i = 0; i < 16; i++) {
    const t = new ct();
    t.set(fn[i], mn[i], gn[i], yn[i], 0, 0), _f.push(t);
  }
}
ev();
const Ct = {
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0°       | East      |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  E: 0,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45°↻     | Southeast |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  SE: 1,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90°↻     | South     |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  S: 2,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135°↻    | Southwest |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  SW: 3,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180°     | West      |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  W: 4,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135°/225°↻ | Northwest    |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  NW: 5,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90°/270°↻  | North        |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  N: 6,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45°/315°↻  | Northeast    |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  NE: 7,
  /**
   * Reflection about Y-axis.
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  MIRROR_VERTICAL: 8,
  /**
   * Reflection about the main diagonal.
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  MAIN_DIAGONAL: 10,
  /**
   * Reflection about X-axis.
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  MIRROR_HORIZONTAL: 12,
  /**
   * Reflection about reverse diagonal.
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  REVERSE_DIAGONAL: 14,
  /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */
  uX: (i) => fn[i],
  /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */
  uY: (i) => mn[i],
  /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */
  vX: (i) => gn[i],
  /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */
  vY: (i) => yn[i],
  /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @returns {GD8Symmetry} The opposite symmetry of `rotation`
   */
  inv: (i) => i & 8 ? i & 15 : -i & 7,
  /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @memberof maths.groupD8
   * @param {GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @returns {GD8Symmetry} Composed operation
   */
  add: (i, t) => oh[i][t],
  /**
   * Reverse of `add`.
   * @memberof maths.groupD8
   * @param {GD8Symmetry} rotationSecond - Second operation
   * @param {GD8Symmetry} rotationFirst - First operation
   * @returns {GD8Symmetry} Result
   */
  sub: (i, t) => oh[i][Ct.inv(t)],
  /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   * @memberof maths.groupD8
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */
  rotate180: (i) => i ^ 4,
  /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   * @memberof maths.groupD8
   * @param {GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */
  isVertical: (i) => (i & 3) === 2,
  // rotation % 4 === 2
  /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   * @memberof maths.groupD8
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @returns {GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */
  byDirection: (i, t) => Math.abs(i) * 2 <= Math.abs(t) ? t >= 0 ? Ct.S : Ct.N : Math.abs(t) * 2 <= Math.abs(i) ? i > 0 ? Ct.E : Ct.W : t > 0 ? i > 0 ? Ct.SE : Ct.SW : i > 0 ? Ct.NE : Ct.NW,
  /**
   * Helps sprite to compensate texture packer rotation.
   * @memberof maths.groupD8
   * @param {Matrix} matrix - sprite world matrix
   * @param {GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   */
  matrixAppendRotationInv: (i, t, e = 0, n = 0) => {
    const r = _f[Ct.inv(t)];
    r.tx = e, r.ty = n, i.append(r);
  }
}, bo = [new me(), new me(), new me(), new me()];
class jt {
  /**
   * @param x - The X coordinate of the upper-left corner of the rectangle
   * @param y - The Y coordinate of the upper-left corner of the rectangle
   * @param width - The overall width of the rectangle
   * @param height - The overall height of the rectangle
   */
  constructor(t = 0, e = 0, n = 0, r = 0) {
    this.type = "rectangle", this.x = Number(t), this.y = Number(e), this.width = Number(n), this.height = Number(r);
  }
  /** Returns the left edge of the rectangle. */
  get left() {
    return this.x;
  }
  /** Returns the right edge of the rectangle. */
  get right() {
    return this.x + this.width;
  }
  /** Returns the top edge of the rectangle. */
  get top() {
    return this.y;
  }
  /** Returns the bottom edge of the rectangle. */
  get bottom() {
    return this.y + this.height;
  }
  /** Determines whether the Rectangle is empty. */
  isEmpty() {
    return this.left === this.right || this.top === this.bottom;
  }
  /** A constant empty rectangle. This is a new object every time the property is accessed */
  static get EMPTY() {
    return new jt(0, 0, 0, 0);
  }
  /**
   * Creates a clone of this Rectangle
   * @returns a copy of the rectangle
   */
  clone() {
    return new jt(this.x, this.y, this.width, this.height);
  }
  /**
   * Converts a Bounds object to a Rectangle object.
   * @param bounds - The bounds to copy and convert to a rectangle.
   * @returns Returns itself.
   */
  copyFromBounds(t) {
    return this.x = t.minX, this.y = t.minY, this.width = t.maxX - t.minX, this.height = t.maxY - t.minY, this;
  }
  /**
   * Copies another rectangle to this one.
   * @param rectangle - The rectangle to copy from.
   * @returns Returns itself.
   */
  copyFrom(t) {
    return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
  }
  /**
   * Copies this rectangle to another one.
   * @param rectangle - The rectangle to copy to.
   * @returns Returns given parameter.
   */
  copyTo(t) {
    return t.copyFrom(this), t;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rectangle
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Rectangle
   */
  contains(t, e) {
    return this.width <= 0 || this.height <= 0 ? !1 : t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @returns Whether the x/y coordinates are within this rectangle
   */
  strokeContains(t, e, n) {
    const { width: r, height: s } = this;
    if (r <= 0 || s <= 0)
      return !1;
    const o = this.x, a = this.y, l = o - n / 2, h = o + r + n / 2, c = a - n / 2, p = a + s + n / 2, f = o + n / 2, d = o + r - n / 2, m = a + n / 2, g = a + s - n / 2;
    return t >= l && t <= h && e >= c && e <= p && !(t > f && t < d && e > m && e < g);
  }
  /**
   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
   * Returns true only if the area of the intersection is >0, this means that Rectangles
   * sharing a side are not overlapping. Another side effect is that an arealess rectangle
   * (width or height equal to zero) can't intersect any other rectangle.
   * @param {Rectangle} other - The Rectangle to intersect with `this`.
   * @param {Matrix} transform - The transformation matrix of `other`.
   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
   */
  intersects(t, e) {
    if (!e) {
      const v = this.x < t.x ? t.x : this.x;
      if ((this.right > t.right ? t.right : this.right) <= v)
        return !1;
      const x = this.y < t.y ? t.y : this.y;
      return (this.bottom > t.bottom ? t.bottom : this.bottom) > x;
    }
    const n = this.left, r = this.right, s = this.top, o = this.bottom;
    if (r <= n || o <= s)
      return !1;
    const a = bo[0].set(t.left, t.top), l = bo[1].set(t.left, t.bottom), h = bo[2].set(t.right, t.top), c = bo[3].set(t.right, t.bottom);
    if (h.x <= a.x || l.y <= a.y)
      return !1;
    const p = Math.sign(e.a * e.d - e.b * e.c);
    if (p === 0 || (e.apply(a, a), e.apply(l, l), e.apply(h, h), e.apply(c, c), Math.max(a.x, l.x, h.x, c.x) <= n || Math.min(a.x, l.x, h.x, c.x) >= r || Math.max(a.y, l.y, h.y, c.y) <= s || Math.min(a.y, l.y, h.y, c.y) >= o))
      return !1;
    const f = p * (l.y - a.y), d = p * (a.x - l.x), m = f * n + d * s, g = f * r + d * s, y = f * n + d * o, b = f * r + d * o;
    if (Math.max(m, g, y, b) <= f * a.x + d * a.y || Math.min(m, g, y, b) >= f * c.x + d * c.y)
      return !1;
    const S = p * (a.y - h.y), C = p * (h.x - a.x), I = S * n + C * s, T = S * r + C * s, R = S * n + C * o, w = S * r + C * o;
    return !(Math.max(I, T, R, w) <= S * a.x + C * a.y || Math.min(I, T, R, w) >= S * c.x + C * c.y);
  }
  /**
   * Pads the rectangle making it grow in all directions.
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @param paddingX - The horizontal padding amount.
   * @param paddingY - The vertical padding amount.
   * @returns Returns itself.
   */
  pad(t = 0, e = t) {
    return this.x -= t, this.y -= e, this.width += t * 2, this.height += e * 2, this;
  }
  /**
   * Fits this rectangle around the passed one.
   * @param rectangle - The rectangle to fit.
   * @returns Returns itself.
   */
  fit(t) {
    const e = Math.max(this.x, t.x), n = Math.min(this.x + this.width, t.x + t.width), r = Math.max(this.y, t.y), s = Math.min(this.y + this.height, t.y + t.height);
    return this.x = e, this.width = Math.max(n - e, 0), this.y = r, this.height = Math.max(s - r, 0), this;
  }
  /**
   * Enlarges rectangle that way its corners lie on grid
   * @param resolution - resolution
   * @param eps - precision
   * @returns Returns itself.
   */
  ceil(t = 1, e = 1e-3) {
    const n = Math.ceil((this.x + this.width - e) * t) / t, r = Math.ceil((this.y + this.height - e) * t) / t;
    return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = n - this.x, this.height = r - this.y, this;
  }
  /**
   * Enlarges this rectangle to include the passed rectangle.
   * @param rectangle - The rectangle to include.
   * @returns Returns itself.
   */
  enlarge(t) {
    const e = Math.min(this.x, t.x), n = Math.max(this.x + this.width, t.x + t.width), r = Math.min(this.y, t.y), s = Math.max(this.y + this.height, t.y + t.height);
    return this.x = e, this.width = n - e, this.y = r, this.height = s - r, this;
  }
  /**
   * Returns the framing rectangle of the rectangle as a Rectangle object
   * @param out - optional rectangle to store the result
   * @returns The framing rectangle
   */
  getBounds(t) {
    return t = t || new jt(), t.copyFrom(this), t;
  }
  toString() {
    return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
}
const fl = {
  default: -1
};
function qt(i = "default") {
  return fl[i] === void 0 && (fl[i] = -1), ++fl[i];
}
const ad = {}, dt = "8.0.0", iv = "8.3.4";
function ut(i, t, e = 3) {
  if (ad[t])
    return;
  let n = new Error().stack;
  typeof n > "u" ? console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${i}`) : (n = n.split(`
`).splice(e).join(`
`), console.groupCollapsed ? (console.groupCollapsed(
    "%cPixiJS Deprecation Warning: %c%s",
    "color:#614108;background:#fffbe6",
    "font-weight:normal;color:#614108;background:#fffbe6",
    `${t}
Deprecated since v${i}`
  ), console.warn(n), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${i}`), console.warn(n))), ad[t] = !0;
}
const xf = () => {
};
function ld(i) {
  return i += i === 0 ? 1 : 0, --i, i |= i >>> 1, i |= i >>> 2, i |= i >>> 4, i |= i >>> 8, i |= i >>> 16, i + 1;
}
function hd(i) {
  return !(i & i - 1) && !!i;
}
function nv(i) {
  const t = {};
  for (const e in i)
    i[e] !== void 0 && (t[e] = i[e]);
  return t;
}
const cd = /* @__PURE__ */ Object.create(null);
function rv(i) {
  const t = cd[i];
  return t === void 0 && (cd[i] = qt("resource")), t;
}
const bf = class wf extends xe {
  /**
   * @param options - options for the style
   */
  constructor(t = {}) {
    super(), this._resourceType = "textureSampler", this._touched = 0, this._maxAnisotropy = 1, this.destroyed = !1, t = { ...wf.defaultOptions, ...t }, this.addressMode = t.addressMode, this.addressModeU = t.addressModeU ?? this.addressModeU, this.addressModeV = t.addressModeV ?? this.addressModeV, this.addressModeW = t.addressModeW ?? this.addressModeW, this.scaleMode = t.scaleMode, this.magFilter = t.magFilter ?? this.magFilter, this.minFilter = t.minFilter ?? this.minFilter, this.mipmapFilter = t.mipmapFilter ?? this.mipmapFilter, this.lodMinClamp = t.lodMinClamp, this.lodMaxClamp = t.lodMaxClamp, this.compare = t.compare, this.maxAnisotropy = t.maxAnisotropy ?? 1;
  }
  set addressMode(t) {
    this.addressModeU = t, this.addressModeV = t, this.addressModeW = t;
  }
  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
  get addressMode() {
    return this.addressModeU;
  }
  set wrapMode(t) {
    ut(dt, "TextureStyle.wrapMode is now TextureStyle.addressMode"), this.addressMode = t;
  }
  get wrapMode() {
    return this.addressMode;
  }
  set scaleMode(t) {
    this.magFilter = t, this.minFilter = t, this.mipmapFilter = t;
  }
  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
  get scaleMode() {
    return this.magFilter;
  }
  /** Specifies the maximum anisotropy value clamp used by the sampler. */
  set maxAnisotropy(t) {
    this._maxAnisotropy = Math.min(t, 16), this._maxAnisotropy > 1 && (this.scaleMode = "linear");
  }
  get maxAnisotropy() {
    return this._maxAnisotropy;
  }
  // TODO - move this to WebGL?
  get _resourceId() {
    return this._sharedResourceId || this._generateResourceId();
  }
  update() {
    this.emit("change", this), this._sharedResourceId = null;
  }
  _generateResourceId() {
    const t = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
    return this._sharedResourceId = rv(t), this._resourceId;
  }
  /** Destroys the style */
  destroy() {
    this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this.removeAllListeners();
  }
};
bf.defaultOptions = {
  addressMode: "clamp-to-edge",
  scaleMode: "linear"
};
let sv = bf;
const Af = class Sf extends xe {
  /**
   * @param options - options for creating a new TextureSource
   */
  constructor(t = {}) {
    super(), this.options = t, this.uid = qt("textureSource"), this._resourceType = "textureSource", this._resourceId = qt("resource"), this.uploadMethodId = "unknown", this._resolution = 1, this.pixelWidth = 1, this.pixelHeight = 1, this.width = 1, this.height = 1, this.sampleCount = 1, this.mipLevelCount = 1, this.autoGenerateMipmaps = !1, this.format = "rgba8unorm", this.dimension = "2d", this.antialias = !1, this._touched = 0, this._batchTick = -1, this._textureBindLocation = -1, t = { ...Sf.defaultOptions, ...t }, this.label = t.label ?? "", this.resource = t.resource, this.autoGarbageCollect = t.autoGarbageCollect, this._resolution = t.resolution, t.width ? this.pixelWidth = t.width * this._resolution : this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1, t.height ? this.pixelHeight = t.height * this._resolution : this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1, this.width = this.pixelWidth / this._resolution, this.height = this.pixelHeight / this._resolution, this.format = t.format, this.dimension = t.dimensions, this.mipLevelCount = t.mipLevelCount, this.autoGenerateMipmaps = t.autoGenerateMipmaps, this.sampleCount = t.sampleCount, this.antialias = t.antialias, this.alphaMode = t.alphaMode, this.style = new sv(nv(t)), this.destroyed = !1, this._refreshPOT();
  }
  /** returns itself */
  get source() {
    return this;
  }
  /** the style of the texture */
  get style() {
    return this._style;
  }
  set style(t) {
    var e, n;
    this.style !== t && ((e = this._style) == null || e.off("change", this._onStyleChange, this), this._style = t, (n = this._style) == null || n.on("change", this._onStyleChange, this), this._onStyleChange());
  }
  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
  get addressMode() {
    return this._style.addressMode;
  }
  set addressMode(t) {
    this._style.addressMode = t;
  }
  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
  get repeatMode() {
    return this._style.addressMode;
  }
  set repeatMode(t) {
    this._style.addressMode = t;
  }
  /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */
  get magFilter() {
    return this._style.magFilter;
  }
  set magFilter(t) {
    this._style.magFilter = t;
  }
  /** Specifies the sampling behavior when the sample footprint is larger than one texel. */
  get minFilter() {
    return this._style.minFilter;
  }
  set minFilter(t) {
    this._style.minFilter = t;
  }
  /** Specifies behavior for sampling between mipmap levels. */
  get mipmapFilter() {
    return this._style.mipmapFilter;
  }
  set mipmapFilter(t) {
    this._style.mipmapFilter = t;
  }
  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
  get lodMinClamp() {
    return this._style.lodMinClamp;
  }
  set lodMinClamp(t) {
    this._style.lodMinClamp = t;
  }
  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
  get lodMaxClamp() {
    return this._style.lodMaxClamp;
  }
  set lodMaxClamp(t) {
    this._style.lodMaxClamp = t;
  }
  _onStyleChange() {
    this.emit("styleChange", this);
  }
  /** call this if you have modified the texture outside of the constructor */
  update() {
    if (this.resource) {
      const t = this._resolution;
      if (this.resize(this.resourceWidth / t, this.resourceHeight / t))
        return;
    }
    this.emit("update", this);
  }
  /** Destroys this texture source */
  destroy() {
    this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this._style && (this._style.destroy(), this._style = null), this.uploadMethodId = null, this.resource = null, this.removeAllListeners();
  }
  /**
   * This will unload the Texture source from the GPU. This will free up the GPU memory
   * As soon as it is required fore rendering, it will be re-uploaded.
   */
  unload() {
    this._resourceId = qt("resource"), this.emit("change", this), this.emit("unload", this);
  }
  /** the width of the resource. This is the REAL pure number, not accounting resolution   */
  get resourceWidth() {
    const { resource: t } = this;
    return t.naturalWidth || t.videoWidth || t.displayWidth || t.width;
  }
  /** the height of the resource. This is the REAL pure number, not accounting resolution */
  get resourceHeight() {
    const { resource: t } = this;
    return t.naturalHeight || t.videoHeight || t.displayHeight || t.height;
  }
  /**
   * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture
   * but will the size of the texture when rendered.
   *
   * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel
   * density will have increased)
   */
  get resolution() {
    return this._resolution;
  }
  set resolution(t) {
    this._resolution !== t && (this._resolution = t, this.width = this.pixelWidth / t, this.height = this.pixelHeight / t);
  }
  /**
   * Resize the texture, this is handy if you want to use the texture as a render texture
   * @param width - the new width of the texture
   * @param height - the new height of the texture
   * @param resolution - the new resolution of the texture
   * @returns - if the texture was resized
   */
  resize(t, e, n) {
    n = n || this._resolution, t = t || this.width, e = e || this.height;
    const r = Math.round(t * n), s = Math.round(e * n);
    return this.width = r / n, this.height = s / n, this._resolution = n, this.pixelWidth === r && this.pixelHeight === s ? !1 : (this._refreshPOT(), this.pixelWidth = r, this.pixelHeight = s, this.emit("resize", this), this._resourceId = qt("resource"), this.emit("change", this), !0);
  }
  /**
   * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.
   * This is only important for RenderTexture instances, as standard Texture instances will have their
   * mipmaps generated on upload. You should call this method after you make any change to the texture
   *
   * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,
   * We want you, the developer to specify when this action should happen.
   *
   * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,
   */
  updateMipmaps() {
    this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this);
  }
  set wrapMode(t) {
    this._style.wrapMode = t;
  }
  get wrapMode() {
    return this._style.wrapMode;
  }
  set scaleMode(t) {
    this._style.scaleMode = t;
  }
  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
  get scaleMode() {
    return this._style.scaleMode;
  }
  /**
   * Refresh check for isPowerOfTwo texture based on size
   * @private
   */
  _refreshPOT() {
    this.isPowerOfTwo = hd(this.pixelWidth) && hd(this.pixelHeight);
  }
  static test(t) {
    throw new Error("Unimplemented");
  }
};
Af.defaultOptions = {
  resolution: 1,
  format: "bgra8unorm",
  alphaMode: "premultiply-alpha-on-upload",
  dimensions: "2d",
  mipLevelCount: 1,
  autoGenerateMipmaps: !1,
  sampleCount: 1,
  antialias: !1,
  autoGarbageCollect: !1
};
let bi = Af;
class uc extends bi {
  constructor(t) {
    const e = t.resource || new Float32Array(t.width * t.height * 4);
    let n = t.format;
    n || (e instanceof Float32Array ? n = "rgba32float" : e instanceof Int32Array || e instanceof Uint32Array ? n = "rgba32uint" : e instanceof Int16Array || e instanceof Uint16Array ? n = "rgba16uint" : n = "bgra8unorm"), super({
      ...t,
      resource: e,
      format: n
    }), this.uploadMethodId = "buffer";
  }
  static test(t) {
    return t instanceof Int8Array || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array;
  }
}
uc.extension = X.TextureSource;
const ud = new ct();
class ov {
  /**
   * @param texture - observed texture
   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
   */
  constructor(t, e) {
    this.mapCoord = new ct(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, typeof e > "u" ? this.clampMargin = t.width < 10 ? 0 : 0.5 : this.clampMargin = e, this.isSimple = !1, this.texture = t;
  }
  /** Texture property. */
  get texture() {
    return this._texture;
  }
  set texture(t) {
    var e;
    this.texture !== t && ((e = this._texture) == null || e.removeListener("update", this.update, this), this._texture = t, this._texture.addListener("update", this.update, this), this.update());
  }
  /**
   * Multiplies uvs array to transform
   * @param uvs - mesh uvs
   * @param [out=uvs] - output
   * @returns - output
   */
  multiplyUvs(t, e) {
    e === void 0 && (e = t);
    const n = this.mapCoord;
    for (let r = 0; r < t.length; r += 2) {
      const s = t[r], o = t[r + 1];
      e[r] = s * n.a + o * n.c + n.tx, e[r + 1] = s * n.b + o * n.d + n.ty;
    }
    return e;
  }
  /**
   * Updates matrices if texture was changed
   * @returns - whether or not it was updated
   */
  update() {
    const t = this._texture;
    this._updateID++;
    const e = t.uvs;
    this.mapCoord.set(e.x1 - e.x0, e.y1 - e.y0, e.x3 - e.x0, e.y3 - e.y0, e.x0, e.y0);
    const n = t.orig, r = t.trim;
    r && (ud.set(
      n.width / r.width,
      0,
      0,
      n.height / r.height,
      -r.x / r.width,
      -r.y / r.height
    ), this.mapCoord.append(ud));
    const s = t.source, o = this.uClampFrame, a = this.clampMargin / s._resolution, l = this.clampOffset / s._resolution;
    return o[0] = (t.frame.x + a + l) / s.width, o[1] = (t.frame.y + a + l) / s.height, o[2] = (t.frame.x + t.frame.width - a + l) / s.width, o[3] = (t.frame.y + t.frame.height - a + l) / s.height, this.uClampOffset[0] = this.clampOffset / s.pixelWidth, this.uClampOffset[1] = this.clampOffset / s.pixelHeight, this.isSimple = t.frame.width === s.width && t.frame.height === s.height && t.rotate === 0, !0;
  }
}
class nt extends xe {
  /**
   * @param {rendering.TextureOptions} options - Options for the texture
   */
  constructor({
    source: t,
    label: e,
    frame: n,
    orig: r,
    trim: s,
    defaultAnchor: o,
    defaultBorders: a,
    rotate: l,
    dynamic: h
  } = {}) {
    if (super(), this.uid = qt("texture"), this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }, this.frame = new jt(), this.noFrame = !1, this.dynamic = !1, this.isTexture = !0, this.label = e, this.source = (t == null ? void 0 : t.source) ?? new bi(), this.noFrame = !n, n)
      this.frame.copyFrom(n);
    else {
      const { width: c, height: p } = this._source;
      this.frame.width = c, this.frame.height = p;
    }
    this.orig = r || this.frame, this.trim = s, this.rotate = l ?? 0, this.defaultAnchor = o, this.defaultBorders = a, this.destroyed = !1, this.dynamic = h || !1, this.updateUvs();
  }
  set source(t) {
    this._source && this._source.off("resize", this.update, this), this._source = t, t.on("resize", this.update, this), this.emit("update", this);
  }
  /** the underlying source of the texture (equivalent of baseTexture in v7) */
  get source() {
    return this._source;
  }
  /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */
  get textureMatrix() {
    return this._textureMatrix || (this._textureMatrix = new ov(this)), this._textureMatrix;
  }
  /** The width of the Texture in pixels. */
  get width() {
    return this.orig.width;
  }
  /** The height of the Texture in pixels. */
  get height() {
    return this.orig.height;
  }
  /** Call this function when you have modified the frame of this texture. */
  updateUvs() {
    const { uvs: t, frame: e } = this, { width: n, height: r } = this._source, s = e.x / n, o = e.y / r, a = e.width / n, l = e.height / r;
    let h = this.rotate;
    if (h) {
      const c = a / 2, p = l / 2, f = s + c, d = o + p;
      h = Ct.add(h, Ct.NW), t.x0 = f + c * Ct.uX(h), t.y0 = d + p * Ct.uY(h), h = Ct.add(h, 2), t.x1 = f + c * Ct.uX(h), t.y1 = d + p * Ct.uY(h), h = Ct.add(h, 2), t.x2 = f + c * Ct.uX(h), t.y2 = d + p * Ct.uY(h), h = Ct.add(h, 2), t.x3 = f + c * Ct.uX(h), t.y3 = d + p * Ct.uY(h);
    } else
      t.x0 = s, t.y0 = o, t.x1 = s + a, t.y1 = o, t.x2 = s + a, t.y2 = o + l, t.x3 = s, t.y3 = o + l;
  }
  /**
   * Destroys this texture
   * @param destroySource - Destroy the source when the texture is destroyed.
   */
  destroy(t = !1) {
    this._source && t && (this._source.destroy(), this._source = null), this._textureMatrix = null, this.destroyed = !0, this.emit("destroy", this), this.removeAllListeners();
  }
  /**
   * Call this if you have modified the `texture outside` of the constructor.
   *
   * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.
   */
  update() {
    this.noFrame && (this.frame.width = this._source.width, this.frame.height = this._source.height), this.updateUvs(), this.emit("update", this);
  }
  /** @deprecated since 8.0.0 */
  get baseTexture() {
    return ut(dt, "Texture.baseTexture is now Texture.source"), this._source;
  }
}
nt.EMPTY = new nt({
  label: "EMPTY",
  source: new bi({
    label: "EMPTY"
  })
});
nt.EMPTY.destroy = xf;
nt.WHITE = new nt({
  source: new uc({
    resource: new Uint8Array([255, 255, 255, 255]),
    width: 1,
    height: 1,
    alphaMode: "premultiply-alpha-on-upload",
    label: "WHITE"
  }),
  label: "WHITE"
});
nt.WHITE.destroy = xf;
function av(i, t, e, n) {
  const { width: r, height: s } = e.orig, o = e.trim;
  if (o) {
    const a = o.width, l = o.height;
    i.minX = o.x - t._x * r - n, i.maxX = i.minX + a, i.minY = o.y - t._y * s - n, i.maxY = i.minY + l;
  } else
    i.minX = -t._x * r - n, i.maxX = i.minX + r, i.minY = -t._y * s - n, i.maxY = i.minY + s;
}
const dd = new ct();
let Ji = class Tf {
  constructor(t = 1 / 0, e = 1 / 0, n = -1 / 0, r = -1 / 0) {
    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = dd, this.minX = t, this.minY = e, this.maxX = n, this.maxY = r;
  }
  /**
   * Checks if bounds are empty.
   * @returns - True if empty.
   */
  isEmpty() {
    return this.minX > this.maxX || this.minY > this.maxY;
  }
  /** The bounding rectangle of the bounds. */
  get rectangle() {
    this._rectangle || (this._rectangle = new jt());
    const t = this._rectangle;
    return this.minX > this.maxX || this.minY > this.maxY ? (t.x = 0, t.y = 0, t.width = 0, t.height = 0) : t.copyFromBounds(this), t;
  }
  /** Clears the bounds and resets. */
  clear() {
    return this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = dd, this;
  }
  /**
   * Sets the bounds.
   * @param x0 - left X of frame
   * @param y0 - top Y of frame
   * @param x1 - right X of frame
   * @param y1 - bottom Y of frame
   */
  set(t, e, n, r) {
    this.minX = t, this.minY = e, this.maxX = n, this.maxY = r;
  }
  /**
   * Adds sprite frame
   * @param x0 - left X of frame
   * @param y0 - top Y of frame
   * @param x1 - right X of frame
   * @param y1 - bottom Y of frame
   * @param matrix
   */
  addFrame(t, e, n, r, s) {
    s || (s = this.matrix);
    const o = s.a, a = s.b, l = s.c, h = s.d, c = s.tx, p = s.ty;
    let f = this.minX, d = this.minY, m = this.maxX, g = this.maxY, y = o * t + l * e + c, b = a * t + h * e + p;
    y < f && (f = y), b < d && (d = b), y > m && (m = y), b > g && (g = b), y = o * n + l * e + c, b = a * n + h * e + p, y < f && (f = y), b < d && (d = b), y > m && (m = y), b > g && (g = b), y = o * t + l * r + c, b = a * t + h * r + p, y < f && (f = y), b < d && (d = b), y > m && (m = y), b > g && (g = b), y = o * n + l * r + c, b = a * n + h * r + p, y < f && (f = y), b < d && (d = b), y > m && (m = y), b > g && (g = b), this.minX = f, this.minY = d, this.maxX = m, this.maxY = g;
  }
  /**
   * Adds a rectangle to the bounds.
   * @param rect - The rectangle to be added.
   * @param matrix - The matrix to apply to the bounds.
   */
  addRect(t, e) {
    this.addFrame(t.x, t.y, t.x + t.width, t.y + t.height, e);
  }
  /**
   * Adds other {@link Bounds}.
   * @param bounds - The Bounds to be added
   * @param matrix
   */
  addBounds(t, e) {
    this.addFrame(t.minX, t.minY, t.maxX, t.maxY, e);
  }
  /**
   * Adds other Bounds, masked with Bounds.
   * @param mask - The Bounds to be added.
   */
  addBoundsMask(t) {
    this.minX = this.minX > t.minX ? this.minX : t.minX, this.minY = this.minY > t.minY ? this.minY : t.minY, this.maxX = this.maxX < t.maxX ? this.maxX : t.maxX, this.maxY = this.maxY < t.maxY ? this.maxY : t.maxY;
  }
  /**
   * Adds other Bounds, multiplied with matrix.
   * @param matrix - The matrix to apply to the bounds.
   */
  applyMatrix(t) {
    const e = this.minX, n = this.minY, r = this.maxX, s = this.maxY, { a: o, b: a, c: l, d: h, tx: c, ty: p } = t;
    let f = o * e + l * n + c, d = a * e + h * n + p;
    this.minX = f, this.minY = d, this.maxX = f, this.maxY = d, f = o * r + l * n + c, d = a * r + h * n + p, this.minX = f < this.minX ? f : this.minX, this.minY = d < this.minY ? d : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = d > this.maxY ? d : this.maxY, f = o * e + l * s + c, d = a * e + h * s + p, this.minX = f < this.minX ? f : this.minX, this.minY = d < this.minY ? d : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = d > this.maxY ? d : this.maxY, f = o * r + l * s + c, d = a * r + h * s + p, this.minX = f < this.minX ? f : this.minX, this.minY = d < this.minY ? d : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = d > this.maxY ? d : this.maxY;
  }
  /**
   * Resizes the bounds object to include the given rectangle.
   * @param rect - The rectangle to be included.
   */
  fit(t) {
    return this.minX < t.left && (this.minX = t.left), this.maxX > t.right && (this.maxX = t.right), this.minY < t.top && (this.minY = t.top), this.maxY > t.bottom && (this.maxY = t.bottom), this;
  }
  /**
   * Resizes the bounds object to include the given bounds.
   * @param left - The left value of the bounds.
   * @param right - The right value of the bounds.
   * @param top - The top value of the bounds.
   * @param bottom - The bottom value of the bounds.
   */
  fitBounds(t, e, n, r) {
    return this.minX < t && (this.minX = t), this.maxX > e && (this.maxX = e), this.minY < n && (this.minY = n), this.maxY > r && (this.maxY = r), this;
  }
  /**
   * Pads bounds object, making it grow in all directions.
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @param paddingX - The horizontal padding amount.
   * @param paddingY - The vertical padding amount.
   */
  pad(t, e = t) {
    return this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e, this;
  }
  /** Ceils the bounds. */
  ceil() {
    return this.minX = Math.floor(this.minX), this.minY = Math.floor(this.minY), this.maxX = Math.ceil(this.maxX), this.maxY = Math.ceil(this.maxY), this;
  }
  /** Clones the bounds. */
  clone() {
    return new Tf(this.minX, this.minY, this.maxX, this.maxY);
  }
  /**
   * Scales the bounds by the given values
   * @param x - The X value to scale by.
   * @param y - The Y value to scale by.
   */
  scale(t, e = t) {
    return this.minX *= t, this.minY *= e, this.maxX *= t, this.maxY *= e, this;
  }
  /** the x value of the bounds. */
  get x() {
    return this.minX;
  }
  set x(t) {
    const e = this.maxX - this.minX;
    this.minX = t, this.maxX = t + e;
  }
  /** the y value of the bounds. */
  get y() {
    return this.minY;
  }
  set y(t) {
    const e = this.maxY - this.minY;
    this.minY = t, this.maxY = t + e;
  }
  /** the width value of the bounds. */
  get width() {
    return this.maxX - this.minX;
  }
  set width(t) {
    this.maxX = this.minX + t;
  }
  /** the height value of the bounds. */
  get height() {
    return this.maxY - this.minY;
  }
  set height(t) {
    this.maxY = this.minY + t;
  }
  /** the left value of the bounds. */
  get left() {
    return this.minX;
  }
  /** the right value of the bounds. */
  get right() {
    return this.maxX;
  }
  /** the top value of the bounds. */
  get top() {
    return this.minY;
  }
  /** the bottom value of the bounds. */
  get bottom() {
    return this.maxY;
  }
  /** Is the bounds positive. */
  get isPositive() {
    return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
  }
  get isValid() {
    return this.minX + this.minY !== 1 / 0;
  }
  /**
   * Adds screen vertices from array
   * @param vertexData - calculated vertices
   * @param beginOffset - begin offset
   * @param endOffset - end offset, excluded
   * @param matrix
   */
  addVertexData(t, e, n, r) {
    let s = this.minX, o = this.minY, a = this.maxX, l = this.maxY;
    r || (r = this.matrix);
    const h = r.a, c = r.b, p = r.c, f = r.d, d = r.tx, m = r.ty;
    for (let g = e; g < n; g += 2) {
      const y = t[g], b = t[g + 1], S = h * y + p * b + d, C = c * y + f * b + m;
      s = S < s ? S : s, o = C < o ? C : o, a = S > a ? S : a, l = C > l ? C : l;
    }
    this.minX = s, this.minY = o, this.maxX = a, this.maxY = l;
  }
  /**
   * Checks if the point is contained within the bounds.
   * @param x - x coordinate
   * @param y - y coordinate
   */
  containsPoint(t, e) {
    return this.minX <= t && this.minY <= e && this.maxX >= t && this.maxY >= e;
  }
  toString() {
    return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
  }
};
var lv = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }, Ei = function(i) {
  return typeof i == "string" ? i.length > 0 : typeof i == "number";
}, Jt = function(i, t, e) {
  return t === void 0 && (t = 0), e === void 0 && (e = Math.pow(10, t)), Math.round(e * i) / e + 0;
}, Je = function(i, t, e) {
  return t === void 0 && (t = 0), e === void 0 && (e = 1), i > e ? e : i > t ? i : t;
}, Ef = function(i) {
  return (i = isFinite(i) ? i % 360 : 0) > 0 ? i : i + 360;
}, pd = function(i) {
  return { r: Je(i.r, 0, 255), g: Je(i.g, 0, 255), b: Je(i.b, 0, 255), a: Je(i.a) };
}, ml = function(i) {
  return { r: Jt(i.r), g: Jt(i.g), b: Jt(i.b), a: Jt(i.a, 3) };
}, hv = /^#([0-9a-f]{3,8})$/i, wo = function(i) {
  var t = i.toString(16);
  return t.length < 2 ? "0" + t : t;
}, Cf = function(i) {
  var t = i.r, e = i.g, n = i.b, r = i.a, s = Math.max(t, e, n), o = s - Math.min(t, e, n), a = o ? s === t ? (e - n) / o : s === e ? 2 + (n - t) / o : 4 + (t - e) / o : 0;
  return { h: 60 * (a < 0 ? a + 6 : a), s: s ? o / s * 100 : 0, v: s / 255 * 100, a: r };
}, Pf = function(i) {
  var t = i.h, e = i.s, n = i.v, r = i.a;
  t = t / 360 * 6, e /= 100, n /= 100;
  var s = Math.floor(t), o = n * (1 - e), a = n * (1 - (t - s) * e), l = n * (1 - (1 - t + s) * e), h = s % 6;
  return { r: 255 * [n, a, o, o, l, n][h], g: 255 * [l, n, n, a, o, o][h], b: 255 * [o, o, l, n, n, a][h], a: r };
}, fd = function(i) {
  return { h: Ef(i.h), s: Je(i.s, 0, 100), l: Je(i.l, 0, 100), a: Je(i.a) };
}, md = function(i) {
  return { h: Jt(i.h), s: Jt(i.s), l: Jt(i.l), a: Jt(i.a, 3) };
}, gd = function(i) {
  return Pf((e = (t = i).s, { h: t.h, s: (e *= ((n = t.l) < 50 ? n : 100 - n) / 100) > 0 ? 2 * e / (n + e) * 100 : 0, v: n + e, a: t.a }));
  var t, e, n;
}, gs = function(i) {
  return { h: (t = Cf(i)).h, s: (r = (200 - (e = t.s)) * (n = t.v) / 100) > 0 && r < 200 ? e * n / 100 / (r <= 100 ? r : 200 - r) * 100 : 0, l: r / 2, a: t.a };
  var t, e, n, r;
}, cv = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, uv = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, dv = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, pv = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, ah = { string: [[function(i) {
  var t = hv.exec(i);
  return t ? (i = t[1]).length <= 4 ? { r: parseInt(i[0] + i[0], 16), g: parseInt(i[1] + i[1], 16), b: parseInt(i[2] + i[2], 16), a: i.length === 4 ? Jt(parseInt(i[3] + i[3], 16) / 255, 2) : 1 } : i.length === 6 || i.length === 8 ? { r: parseInt(i.substr(0, 2), 16), g: parseInt(i.substr(2, 2), 16), b: parseInt(i.substr(4, 2), 16), a: i.length === 8 ? Jt(parseInt(i.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
}, "hex"], [function(i) {
  var t = dv.exec(i) || pv.exec(i);
  return t ? t[2] !== t[4] || t[4] !== t[6] ? null : pd({ r: Number(t[1]) / (t[2] ? 100 / 255 : 1), g: Number(t[3]) / (t[4] ? 100 / 255 : 1), b: Number(t[5]) / (t[6] ? 100 / 255 : 1), a: t[7] === void 0 ? 1 : Number(t[7]) / (t[8] ? 100 : 1) }) : null;
}, "rgb"], [function(i) {
  var t = cv.exec(i) || uv.exec(i);
  if (!t) return null;
  var e, n, r = fd({ h: (e = t[1], n = t[2], n === void 0 && (n = "deg"), Number(e) * (lv[n] || 1)), s: Number(t[3]), l: Number(t[4]), a: t[5] === void 0 ? 1 : Number(t[5]) / (t[6] ? 100 : 1) });
  return gd(r);
}, "hsl"]], object: [[function(i) {
  var t = i.r, e = i.g, n = i.b, r = i.a, s = r === void 0 ? 1 : r;
  return Ei(t) && Ei(e) && Ei(n) ? pd({ r: Number(t), g: Number(e), b: Number(n), a: Number(s) }) : null;
}, "rgb"], [function(i) {
  var t = i.h, e = i.s, n = i.l, r = i.a, s = r === void 0 ? 1 : r;
  if (!Ei(t) || !Ei(e) || !Ei(n)) return null;
  var o = fd({ h: Number(t), s: Number(e), l: Number(n), a: Number(s) });
  return gd(o);
}, "hsl"], [function(i) {
  var t = i.h, e = i.s, n = i.v, r = i.a, s = r === void 0 ? 1 : r;
  if (!Ei(t) || !Ei(e) || !Ei(n)) return null;
  var o = function(a) {
    return { h: Ef(a.h), s: Je(a.s, 0, 100), v: Je(a.v, 0, 100), a: Je(a.a) };
  }({ h: Number(t), s: Number(e), v: Number(n), a: Number(s) });
  return Pf(o);
}, "hsv"]] }, yd = function(i, t) {
  for (var e = 0; e < t.length; e++) {
    var n = t[e][0](i);
    if (n) return [n, t[e][1]];
  }
  return [null, void 0];
}, fv = function(i) {
  return typeof i == "string" ? yd(i.trim(), ah.string) : typeof i == "object" && i !== null ? yd(i, ah.object) : [null, void 0];
}, gl = function(i, t) {
  var e = gs(i);
  return { h: e.h, s: Je(e.s + 100 * t, 0, 100), l: e.l, a: e.a };
}, yl = function(i) {
  return (299 * i.r + 587 * i.g + 114 * i.b) / 1e3 / 255;
}, vd = function(i, t) {
  var e = gs(i);
  return { h: e.h, s: e.s, l: Je(e.l + 100 * t, 0, 100), a: e.a };
}, lh = function() {
  function i(t) {
    this.parsed = fv(t)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
  }
  return i.prototype.isValid = function() {
    return this.parsed !== null;
  }, i.prototype.brightness = function() {
    return Jt(yl(this.rgba), 2);
  }, i.prototype.isDark = function() {
    return yl(this.rgba) < 0.5;
  }, i.prototype.isLight = function() {
    return yl(this.rgba) >= 0.5;
  }, i.prototype.toHex = function() {
    return t = ml(this.rgba), e = t.r, n = t.g, r = t.b, o = (s = t.a) < 1 ? wo(Jt(255 * s)) : "", "#" + wo(e) + wo(n) + wo(r) + o;
    var t, e, n, r, s, o;
  }, i.prototype.toRgb = function() {
    return ml(this.rgba);
  }, i.prototype.toRgbString = function() {
    return t = ml(this.rgba), e = t.r, n = t.g, r = t.b, (s = t.a) < 1 ? "rgba(" + e + ", " + n + ", " + r + ", " + s + ")" : "rgb(" + e + ", " + n + ", " + r + ")";
    var t, e, n, r, s;
  }, i.prototype.toHsl = function() {
    return md(gs(this.rgba));
  }, i.prototype.toHslString = function() {
    return t = md(gs(this.rgba)), e = t.h, n = t.s, r = t.l, (s = t.a) < 1 ? "hsla(" + e + ", " + n + "%, " + r + "%, " + s + ")" : "hsl(" + e + ", " + n + "%, " + r + "%)";
    var t, e, n, r, s;
  }, i.prototype.toHsv = function() {
    return t = Cf(this.rgba), { h: Jt(t.h), s: Jt(t.s), v: Jt(t.v), a: Jt(t.a, 3) };
    var t;
  }, i.prototype.invert = function() {
    return ui({ r: 255 - (t = this.rgba).r, g: 255 - t.g, b: 255 - t.b, a: t.a });
    var t;
  }, i.prototype.saturate = function(t) {
    return t === void 0 && (t = 0.1), ui(gl(this.rgba, t));
  }, i.prototype.desaturate = function(t) {
    return t === void 0 && (t = 0.1), ui(gl(this.rgba, -t));
  }, i.prototype.grayscale = function() {
    return ui(gl(this.rgba, -1));
  }, i.prototype.lighten = function(t) {
    return t === void 0 && (t = 0.1), ui(vd(this.rgba, t));
  }, i.prototype.darken = function(t) {
    return t === void 0 && (t = 0.1), ui(vd(this.rgba, -t));
  }, i.prototype.rotate = function(t) {
    return t === void 0 && (t = 15), this.hue(this.hue() + t);
  }, i.prototype.alpha = function(t) {
    return typeof t == "number" ? ui({ r: (e = this.rgba).r, g: e.g, b: e.b, a: t }) : Jt(this.rgba.a, 3);
    var e;
  }, i.prototype.hue = function(t) {
    var e = gs(this.rgba);
    return typeof t == "number" ? ui({ h: t, s: e.s, l: e.l, a: e.a }) : Jt(e.h);
  }, i.prototype.isEqual = function(t) {
    return this.toHex() === ui(t).toHex();
  }, i;
}(), ui = function(i) {
  return i instanceof lh ? i : new lh(i);
}, _d = [], mv = function(i) {
  i.forEach(function(t) {
    _d.indexOf(t) < 0 && (t(lh, ah), _d.push(t));
  });
};
function gv(i, t) {
  var e = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, n = {};
  for (var r in e) n[e[r]] = r;
  var s = {};
  i.prototype.toName = function(o) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
    var a, l, h = n[this.toHex()];
    if (h) return h;
    if (o != null && o.closest) {
      var c = this.toRgb(), p = 1 / 0, f = "black";
      if (!s.length) for (var d in e) s[d] = new i(e[d]).toRgb();
      for (var m in e) {
        var g = (a = c, l = s[m], Math.pow(a.r - l.r, 2) + Math.pow(a.g - l.g, 2) + Math.pow(a.b - l.b, 2));
        g < p && (p = g, f = m);
      }
      return f;
    }
  }, t.string.push([function(o) {
    var a = o.toLowerCase(), l = a === "transparent" ? "#0000" : e[a];
    return l ? new i(l).toRgb() : null;
  }, "name"]);
}
mv([gv]);
const gr = class os {
  /**
   * @param {ColorSource} value - Optional value to use, if not provided, white is used.
   */
  constructor(t = 16777215) {
    this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = t;
  }
  /** Get red component (0 - 1) */
  get red() {
    return this._components[0];
  }
  /** Get green component (0 - 1) */
  get green() {
    return this._components[1];
  }
  /** Get blue component (0 - 1) */
  get blue() {
    return this._components[2];
  }
  /** Get alpha component (0 - 1) */
  get alpha() {
    return this._components[3];
  }
  /**
   * Set the value, suitable for chaining
   * @param value
   * @see Color.value
   */
  setValue(t) {
    return this.value = t, this;
  }
  /**
   * The current color source.
   *
   * When setting:
   * - Setting to an instance of `Color` will copy its color source and components.
   * - Otherwise, `Color` will try to normalize the color source and set the components.
   *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.
   *
   * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter
   * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.
   *
   * When getting:
   * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},
   *   {@link Color.premultiply premultiply} or {@link Color.round round}).
   * - Otherwise, the color source used when setting is returned.
   */
  set value(t) {
    if (t instanceof os)
      this._value = this._cloneSource(t._value), this._int = t._int, this._components.set(t._components);
    else {
      if (t === null)
        throw new Error("Cannot set Color#value to null");
      (this._value === null || !this._isSourceEqual(this._value, t)) && (this._value = this._cloneSource(t), this._normalize(this._value));
    }
  }
  get value() {
    return this._value;
  }
  /**
   * Copy a color source internally.
   * @param value - Color source
   */
  _cloneSource(t) {
    return typeof t == "string" || typeof t == "number" || t instanceof Number || t === null ? t : Array.isArray(t) || ArrayBuffer.isView(t) ? t.slice(0) : typeof t == "object" && t !== null ? { ...t } : t;
  }
  /**
   * Equality check for color sources.
   * @param value1 - First color source
   * @param value2 - Second color source
   * @returns `true` if the color sources are equal, `false` otherwise.
   */
  _isSourceEqual(t, e) {
    const n = typeof t;
    if (n !== typeof e)
      return !1;
    if (n === "number" || n === "string" || t instanceof Number)
      return t === e;
    if (Array.isArray(t) && Array.isArray(e) || ArrayBuffer.isView(t) && ArrayBuffer.isView(e))
      return t.length !== e.length ? !1 : t.every((r, s) => r === e[s]);
    if (t !== null && e !== null) {
      const r = Object.keys(t), s = Object.keys(e);
      return r.length !== s.length ? !1 : r.every((o) => t[o] === e[o]);
    }
    return t === e;
  }
  /**
   * Convert to a RGBA color object.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }
   */
  toRgba() {
    const [t, e, n, r] = this._components;
    return { r: t, g: e, b: n, a: r };
  }
  /**
   * Convert to a RGB color object.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }
   */
  toRgb() {
    const [t, e, n] = this._components;
    return { r: t, g: e, b: n };
  }
  /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */
  toRgbaString() {
    const [t, e, n] = this.toUint8RgbArray();
    return `rgba(${t},${e},${n},${this.alpha})`;
  }
  toUint8RgbArray(t) {
    const [e, n, r] = this._components;
    return this._arrayRgb || (this._arrayRgb = []), t = t || this._arrayRgb, t[0] = Math.round(e * 255), t[1] = Math.round(n * 255), t[2] = Math.round(r * 255), t;
  }
  toArray(t) {
    this._arrayRgba || (this._arrayRgba = []), t = t || this._arrayRgba;
    const [e, n, r, s] = this._components;
    return t[0] = e, t[1] = n, t[2] = r, t[3] = s, t;
  }
  toRgbArray(t) {
    this._arrayRgb || (this._arrayRgb = []), t = t || this._arrayRgb;
    const [e, n, r] = this._components;
    return t[0] = e, t[1] = n, t[2] = r, t;
  }
  /**
   * Convert to a hexadecimal number.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toNumber(); // returns 16777215
   */
  toNumber() {
    return this._int;
  }
  /**
   * Convert to a BGR number
   * @example
   * import { Color } from 'pixi.js';
   * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff
   */
  toBgrNumber() {
    const [t, e, n] = this.toUint8RgbArray();
    return (n << 16) + (e << 8) + t;
  }
  /**
   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).
   * @example
   * import { Color } from 'pixi.js';
   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff
   * @returns {number} - The color as a number in little endian format.
   */
  toLittleEndianNumber() {
    const t = this._int;
    return (t >> 16) + (t & 65280) + ((t & 255) << 16);
  }
  /**
   * Multiply with another color. This action is destructive, and will
   * override the previous `value` property to be `null`.
   * @param {ColorSource} value - The color to multiply by.
   */
  multiply(t) {
    const [e, n, r, s] = os._temp.setValue(t)._components;
    return this._components[0] *= e, this._components[1] *= n, this._components[2] *= r, this._components[3] *= s, this._refreshInt(), this._value = null, this;
  }
  /**
   * Converts color to a premultiplied alpha format. This action is destructive, and will
   * override the previous `value` property to be `null`.
   * @param alpha - The alpha to multiply by.
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
   * @returns {Color} - Itself.
   */
  premultiply(t, e = !0) {
    return e && (this._components[0] *= t, this._components[1] *= t, this._components[2] *= t), this._components[3] = t, this._refreshInt(), this._value = null, this;
  }
  /**
   * Premultiplies alpha with current color.
   * @param {number} alpha - The alpha to multiply by.
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
   * @returns {number} tint multiplied by alpha
   */
  toPremultiplied(t, e = !0) {
    if (t === 1)
      return (255 << 24) + this._int;
    if (t === 0)
      return e ? 0 : this._int;
    let n = this._int >> 16 & 255, r = this._int >> 8 & 255, s = this._int & 255;
    return e && (n = n * t + 0.5 | 0, r = r * t + 0.5 | 0, s = s * t + 0.5 | 0), (t * 255 << 24) + (n << 16) + (r << 8) + s;
  }
  /**
   * Convert to a hexadecimal string.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toHex(); // returns "#ffffff"
   */
  toHex() {
    const t = this._int.toString(16);
    return `#${"000000".substring(0, 6 - t.length) + t}`;
  }
  /**
   * Convert to a hexadecimal string with alpha.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toHexa(); // returns "#ffffffff"
   */
  toHexa() {
    const t = Math.round(this._components[3] * 255).toString(16);
    return this.toHex() + "00".substring(0, 2 - t.length) + t;
  }
  /**
   * Set alpha, suitable for chaining.
   * @param alpha
   */
  setAlpha(t) {
    return this._components[3] = this._clamp(t), this;
  }
  /**
   * Normalize the input value into rgba
   * @param value - Input value
   */
  _normalize(t) {
    let e, n, r, s;
    if ((typeof t == "number" || t instanceof Number) && t >= 0 && t <= 16777215) {
      const o = t;
      e = (o >> 16 & 255) / 255, n = (o >> 8 & 255) / 255, r = (o & 255) / 255, s = 1;
    } else if ((Array.isArray(t) || t instanceof Float32Array) && t.length >= 3 && t.length <= 4)
      t = this._clamp(t), [e, n, r, s = 1] = t;
    else if ((t instanceof Uint8Array || t instanceof Uint8ClampedArray) && t.length >= 3 && t.length <= 4)
      t = this._clamp(t, 0, 255), [e, n, r, s = 255] = t, e /= 255, n /= 255, r /= 255, s /= 255;
    else if (typeof t == "string" || typeof t == "object") {
      if (typeof t == "string") {
        const a = os.HEX_PATTERN.exec(t);
        a && (t = `#${a[2]}`);
      }
      const o = ui(t);
      o.isValid() && ({ r: e, g: n, b: r, a: s } = o.rgba, e /= 255, n /= 255, r /= 255);
    }
    if (e !== void 0)
      this._components[0] = e, this._components[1] = n, this._components[2] = r, this._components[3] = s, this._refreshInt();
    else
      throw new Error(`Unable to convert color ${t}`);
  }
  /** Refresh the internal color rgb number */
  _refreshInt() {
    this._clamp(this._components);
    const [t, e, n] = this._components;
    this._int = (t * 255 << 16) + (e * 255 << 8) + (n * 255 | 0);
  }
  /**
   * Clamps values to a range. Will override original values
   * @param value - Value(s) to clamp
   * @param min - Minimum value
   * @param max - Maximum value
   */
  _clamp(t, e = 0, n = 1) {
    return typeof t == "number" ? Math.min(Math.max(t, e), n) : (t.forEach((r, s) => {
      t[s] = Math.min(Math.max(r, e), n);
    }), t);
  }
  /**
   * Check if the value is a color-like object
   * @param value - Value to check
   * @returns True if the value is a color-like object
   * @static
   * @example
   * import { Color } from 'pixi.js';
   * Color.isColorLike('white'); // returns true
   * Color.isColorLike(0xffffff); // returns true
   * Color.isColorLike([1, 1, 1]); // returns true
   */
  static isColorLike(t) {
    return typeof t == "number" || typeof t == "string" || t instanceof Number || t instanceof os || Array.isArray(t) || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Float32Array || t.r !== void 0 && t.g !== void 0 && t.b !== void 0 || t.r !== void 0 && t.g !== void 0 && t.b !== void 0 && t.a !== void 0 || t.h !== void 0 && t.s !== void 0 && t.l !== void 0 || t.h !== void 0 && t.s !== void 0 && t.l !== void 0 && t.a !== void 0 || t.h !== void 0 && t.s !== void 0 && t.v !== void 0 || t.h !== void 0 && t.s !== void 0 && t.v !== void 0 && t.a !== void 0;
  }
};
gr.shared = new gr();
gr._temp = new gr();
gr.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
let Gt = gr;
const yv = {
  cullArea: null,
  cullable: !1,
  cullableChildren: !0
};
class dc {
  /**
   * Constructs a new Pool.
   * @param ClassType - The constructor of the items in the pool.
   * @param {number} [initialSize] - The initial size of the pool.
   */
  constructor(t, e) {
    this._pool = [], this._count = 0, this._index = 0, this._classType = t, e && this.prepopulate(e);
  }
  /**
   * Prepopulates the pool with a given number of items.
   * @param total - The number of items to add to the pool.
   */
  prepopulate(t) {
    for (let e = 0; e < t; e++)
      this._pool[this._index++] = new this._classType();
    this._count += t;
  }
  /**
   * Gets an item from the pool. Calls the item's `init` method if it exists.
   * If there are no items left in the pool, a new one will be created.
   * @param {unknown} [data] - Optional data to pass to the item's constructor.
   * @returns {T} The item from the pool.
   */
  get(t) {
    var e;
    let n;
    return this._index > 0 ? n = this._pool[--this._index] : n = new this._classType(), (e = n.init) == null || e.call(n, t), n;
  }
  /**
   * Returns an item to the pool. Calls the item's `reset` method if it exists.
   * @param {T} item - The item to return to the pool.
   */
  return(t) {
    var e;
    (e = t.reset) == null || e.call(t), this._pool[this._index++] = t;
  }
  /**
   * Gets the number of items in the pool.
   * @readonly
   * @member {number}
   */
  get totalSize() {
    return this._count;
  }
  /**
   * Gets the number of items in the pool that are free to use without needing to create more.
   * @readonly
   * @member {number}
   */
  get totalFree() {
    return this._index;
  }
  /**
   * Gets the number of items in the pool that are currently in use.
   * @readonly
   * @member {number}
   */
  get totalUsed() {
    return this._count - this._index;
  }
  /** clears the pool - mainly used for debugging! */
  clear() {
    this._pool.length = 0, this._index = 0;
  }
}
class vv {
  constructor() {
    this._poolsByClass = /* @__PURE__ */ new Map();
  }
  /**
   * Prepopulates a specific pool with a given number of items.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
   * @param {number} total - The number of items to add to the pool.
   */
  prepopulate(t, e) {
    this.getPool(t).prepopulate(e);
  }
  /**
   * Gets an item from a specific pool.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
   * @param {unknown} [data] - Optional data to pass to the item's constructor.
   * @returns {T} The item from the pool.
   */
  get(t, e) {
    return this.getPool(t).get(e);
  }
  /**
   * Returns an item to its respective pool.
   * @param {PoolItem} item - The item to return to the pool.
   */
  return(t) {
    this.getPool(t.constructor).return(t);
  }
  /**
   * Gets a specific pool based on the class type.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.
   * @returns {Pool<T>} The pool of the given class type.
   */
  getPool(t) {
    return this._poolsByClass.has(t) || this._poolsByClass.set(t, new dc(t)), this._poolsByClass.get(t);
  }
  /** gets the usage stats of each pool in the system */
  stats() {
    const t = {};
    return this._poolsByClass.forEach((e) => {
      const n = t[e._classType.name] ? e._classType.name + e._classType.ID : e._classType.name;
      t[n] = {
        free: e.totalFree,
        used: e.totalUsed,
        size: e.totalSize
      };
    }), t;
  }
}
const Ri = new vv();
function _v(i, t, e) {
  const n = i.length;
  let r;
  if (t >= n || e === 0)
    return;
  e = t + e > n ? n - t : e;
  const s = n - e;
  for (r = t; r < s; ++r)
    i[r] = i[r + e];
  i.length = s;
}
const xv = {
  allowChildren: !0,
  /**
   * Removes all children from this container that are within the begin and end indexes.
   * @param beginIndex - The beginning position.
   * @param endIndex - The ending position. Default value is size of the container.
   * @returns - List of removed children
   * @memberof scene.Container#
   */
  removeChildren(i = 0, t) {
    const e = t ?? this.children.length, n = e - i, r = [];
    if (n > 0 && n <= e) {
      for (let o = e - 1; o >= i; o--) {
        const a = this.children[o];
        a && (r.push(a), a.parent = null);
      }
      _v(this.children, i, e);
      const s = this.renderGroup || this.parentRenderGroup;
      s && s.removeChildren(r);
      for (let o = 0; o < r.length; ++o)
        this.emit("childRemoved", r[o], this, o), r[o].emit("removed", this);
      return r;
    } else if (n === 0 && this.children.length === 0)
      return r;
    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
  },
  /**
   * Removes a child from the specified index position.
   * @param index - The index to get the child from
   * @returns The child that was removed.
   * @memberof scene.Container#
   */
  removeChildAt(i) {
    const t = this.getChildAt(i);
    return this.removeChild(t);
  },
  /**
   * Returns the child at the specified index
   * @param index - The index to get the child at
   * @returns - The child at the given index, if any.
   * @memberof scene.Container#
   */
  getChildAt(i) {
    if (i < 0 || i >= this.children.length)
      throw new Error(`getChildAt: Index (${i}) does not exist.`);
    return this.children[i];
  },
  /**
   * Changes the position of an existing child in the container container
   * @param child - The child Container instance for which you want to change the index number
   * @param index - The resulting index number for the child container
   * @memberof scene.Container#
   */
  setChildIndex(i, t) {
    if (t < 0 || t >= this.children.length)
      throw new Error(`The index ${t} supplied is out of bounds ${this.children.length}`);
    this.getChildIndex(i), this.addChildAt(i, t);
  },
  /**
   * Returns the index position of a child Container instance
   * @param child - The Container instance to identify
   * @returns - The index position of the child container to identify
   * @memberof scene.Container#
   */
  getChildIndex(i) {
    const t = this.children.indexOf(i);
    if (t === -1)
      throw new Error("The supplied Container must be a child of the caller");
    return t;
  },
  /**
   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.
   * If the child is already in this container, it will be moved to the specified index.
   * @param {Container} child - The child to add.
   * @param {number} index - The absolute index where the child will be positioned at the end of the operation.
   * @returns {Container} The child that was added.
   * @memberof scene.Container#
   */
  addChildAt(i, t) {
    this.allowChildren || ut(dt, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
    const { children: e } = this;
    if (t < 0 || t > e.length)
      throw new Error(`${i}addChildAt: The index ${t} supplied is out of bounds ${e.length}`);
    if (i.parent) {
      const r = i.parent.children.indexOf(i);
      if (i.parent === this && r === t)
        return i;
      r !== -1 && i.parent.children.splice(r, 1);
    }
    t === e.length ? e.push(i) : e.splice(t, 0, i), i.parent = this, i.didChange = !0, i._updateFlags = 15;
    const n = this.renderGroup || this.parentRenderGroup;
    return n && n.addChild(i), this.sortableChildren && (this.sortDirty = !0), this.emit("childAdded", i, this, t), i.emit("added", this), i;
  },
  /**
   * Swaps the position of 2 Containers within this container.
   * @param child - First container to swap
   * @param child2 - Second container to swap
   * @memberof scene.Container#
   */
  swapChildren(i, t) {
    if (i === t)
      return;
    const e = this.getChildIndex(i), n = this.getChildIndex(t);
    this.children[e] = t, this.children[n] = i;
    const r = this.renderGroup || this.parentRenderGroup;
    r && (r.structureDidChange = !0), this._didContainerChangeTick++;
  },
  /**
   * Remove the Container from its parent Container. If the Container has no parent, do nothing.
   * @memberof scene.Container#
   */
  removeFromParent() {
    var i;
    (i = this.parent) == null || i.removeChild(this);
  },
  /**
   * Reparent the child to this container, keeping the same worldTransform.
   * @param child - The child to reparent
   * @returns The first child that was reparented.
   * @memberof scene.Container#
   */
  reparentChild(...i) {
    return i.length === 1 ? this.reparentChildAt(i[0], this.children.length) : (i.forEach((t) => this.reparentChildAt(t, this.children.length)), i[0]);
  },
  /**
   * Reparent the child to this container at the specified index, keeping the same worldTransform.
   * @param child - The child to reparent
   * @param index - The index to reparent the child to
   * @memberof scene.Container#
   */
  reparentChildAt(i, t) {
    if (i.parent === this)
      return this.setChildIndex(i, t), i;
    const e = i.worldTransform.clone();
    i.removeFromParent(), this.addChildAt(i, t);
    const n = this.worldTransform.clone();
    return n.invert(), e.prepend(n), i.setFromMatrix(e), i;
  }
};
class xd {
  constructor() {
    this.pipe = "filter", this.priority = 1;
  }
  destroy() {
    for (let t = 0; t < this.filters.length; t++)
      this.filters[t].destroy();
    this.filters = null, this.filterArea = null;
  }
}
class bv {
  constructor() {
    this._effectClasses = [], this._tests = [], this._initialized = !1;
  }
  init() {
    this._initialized || (this._initialized = !0, this._effectClasses.forEach((t) => {
      this.add({
        test: t.test,
        maskClass: t
      });
    }));
  }
  add(t) {
    this._tests.push(t);
  }
  getMaskEffect(t) {
    this._initialized || this.init();
    for (let e = 0; e < this._tests.length; e++) {
      const n = this._tests[e];
      if (n.test(t))
        return Ri.get(n.maskClass, t);
    }
    return t;
  }
  returnMaskEffect(t) {
    Ri.return(t);
  }
}
const hh = new bv();
ge.handleByList(X.MaskEffect, hh._effectClasses);
const wv = {
  _maskEffect: null,
  _maskOptions: {
    inverse: !1
  },
  _filterEffect: null,
  /**
   * @todo Needs docs.
   * @memberof scene.Container#
   * @type {Array<Effect>}
   */
  effects: [],
  /**
   * @todo Needs docs.
   * @param effect - The effect to add.
   * @memberof scene.Container#
   * @ignore
   */
  addEffect(i) {
    if (this.effects.indexOf(i) !== -1)
      return;
    this.effects.push(i), this.effects.sort((e, n) => e.priority - n.priority);
    const t = this.renderGroup || this.parentRenderGroup;
    t && (t.structureDidChange = !0), this._updateIsSimple();
  },
  /**
   * @todo Needs docs.
   * @param effect - The effect to remove.
   * @memberof scene.Container#
   * @ignore
   */
  removeEffect(i) {
    const t = this.effects.indexOf(i);
    t !== -1 && (this.effects.splice(t, 1), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateIsSimple());
  },
  set mask(i) {
    const t = this._maskEffect;
    (t == null ? void 0 : t.mask) !== i && (t && (this.removeEffect(t), hh.returnMaskEffect(t), this._maskEffect = null), i != null && (this._maskEffect = hh.getMaskEffect(i), this.addEffect(this._maskEffect)));
  },
  /**
   * Used to set mask and control mask options.
   * @param options
   * @example
   * import { Graphics, Sprite } from 'pixi.js';
   *
   * const graphics = new Graphics();
   * graphics.beginFill(0xFF3300);
   * graphics.drawRect(50, 250, 100, 100);
   * graphics.endFill();
   *
   * const sprite = new Sprite(texture);
   * sprite.setMask({
   *     mask: graphics,
   *     inverse: true,
   * });
   * @memberof scene.Container#
   */
  setMask(i) {
    this._maskOptions = {
      ...this._maskOptions,
      ...i
    }, i.mask && (this.mask = i.mask);
  },
  /**
   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
   * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
   * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it
   * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.
   * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.
   * To remove a mask, set this property to `null`.
   *
   * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
   * @example
   * import { Graphics, Sprite } from 'pixi.js';
   *
   * const graphics = new Graphics();
   * graphics.beginFill(0xFF3300);
   * graphics.drawRect(50, 250, 100, 100);
   * graphics.endFill();
   *
   * const sprite = new Sprite(texture);
   * sprite.mask = graphics;
   * @memberof scene.Container#
   */
  get mask() {
    var i;
    return (i = this._maskEffect) == null ? void 0 : i.mask;
  },
  set filters(i) {
    var t;
    !Array.isArray(i) && i && (i = [i]);
    const e = this._filterEffect || (this._filterEffect = new xd());
    i = i;
    const n = (i == null ? void 0 : i.length) > 0, r = ((t = e.filters) == null ? void 0 : t.length) > 0, s = n !== r;
    i = Array.isArray(i) ? i.slice(0) : i, e.filters = Object.freeze(i), s && (n ? this.addEffect(e) : (this.removeEffect(e), e.filters = i ?? null));
  },
  /**
   * Sets the filters for the displayObject.
   * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
   * To remove filters simply set this property to `'null'`.
   * @memberof scene.Container#
   */
  get filters() {
    var i;
    return (i = this._filterEffect) == null ? void 0 : i.filters;
  },
  set filterArea(i) {
    this._filterEffect || (this._filterEffect = new xd()), this._filterEffect.filterArea = i;
  },
  /**
   * The area the filter is applied to. This is used as more of an optimization
   * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.
   *
   * Also works as an interaction mask.
   * @memberof scene.Container#
   */
  get filterArea() {
    var i;
    return (i = this._filterEffect) == null ? void 0 : i.filterArea;
  }
}, Av = {
  /**
   * The instance label of the object.
   * @memberof scene.Container#
   * @member {string} label
   */
  label: null,
  /**
   * The instance name of the object.
   * @deprecated since 8.0.0
   * @see scene.Container#label
   * @member {string} name
   * @memberof scene.Container#
   */
  get name() {
    return ut(dt, "Container.name property has been removed, use Container.label instead"), this.label;
  },
  set name(i) {
    ut(dt, "Container.name property has been removed, use Container.label instead"), this.label = i;
  },
  /**
   * @method getChildByName
   * @deprecated since 8.0.0
   * @param {string} name - Instance name.
   * @param {boolean}[deep=false] - Whether to search recursively
   * @returns {Container} The child with the specified name.
   * @see scene.Container#getChildByLabel
   * @memberof scene.Container#
   */
  getChildByName(i, t = !1) {
    return this.getChildByLabel(i, t);
  },
  /**
   * Returns the first child in the container with the specified label.
   *
   * Recursive searches are done in a pre-order traversal.
   * @memberof scene.Container#
   * @param {string|RegExp} label - Instance label.
   * @param {boolean}[deep=false] - Whether to search recursively
   * @returns {Container} The child with the specified label.
   */
  getChildByLabel(i, t = !1) {
    const e = this.children;
    for (let n = 0; n < e.length; n++) {
      const r = e[n];
      if (r.label === i || i instanceof RegExp && i.test(r.label))
        return r;
    }
    if (t)
      for (let n = 0; n < e.length; n++) {
        const r = e[n].getChildByLabel(i, !0);
        if (r)
          return r;
      }
    return null;
  },
  /**
   * Returns all children in the container with the specified label.
   * @memberof scene.Container#
   * @param {string|RegExp} label - Instance label.
   * @param {boolean}[deep=false] - Whether to search recursively
   * @param {Container[]} [out=[]] - The array to store matching children in.
   * @returns {Container[]} An array of children with the specified label.
   */
  getChildrenByLabel(i, t = !1, e = []) {
    const n = this.children;
    for (let r = 0; r < n.length; r++) {
      const s = n[r];
      (s.label === i || i instanceof RegExp && i.test(s.label)) && e.push(s);
    }
    if (t)
      for (let r = 0; r < n.length; r++)
        n[r].getChildrenByLabel(i, !0, e);
    return e;
  }
}, ki = new dc(ct), yr = new dc(Ji);
function If(i, t, e) {
  e.clear();
  let n, r;
  return i.parent ? t ? n = i.parent.worldTransform : (r = ki.get().identity(), n = Xo(i, r)) : n = ct.IDENTITY, Rf(i, e, n, t), r && ki.return(r), e.isValid || e.set(0, 0, 0, 0), e;
}
function Rf(i, t, e, n) {
  var r, s;
  if (!i.visible || !i.measurable)
    return;
  let o;
  n ? o = i.worldTransform : (i.updateLocalTransform(), o = ki.get(), o.appendFrom(i.localTransform, e));
  const a = t, l = !!i.effects.length;
  if (l && (t = yr.get().clear()), i.boundsArea)
    t.addRect(i.boundsArea, o);
  else {
    i.addBounds && (t.matrix = o, i.addBounds(t));
    for (let h = 0; h < i.children.length; h++)
      Rf(i.children[h], t, o, n);
  }
  if (l) {
    for (let h = 0; h < i.effects.length; h++)
      (s = (r = i.effects[h]).addBounds) == null || s.call(r, t);
    a.addBounds(t, ct.IDENTITY), yr.return(t);
  }
  n || ki.return(o);
}
function Xo(i, t) {
  const e = i.parent;
  return e && (Xo(e, t), e.updateLocalTransform(), t.append(e.localTransform)), t;
}
let vl = 0;
const bd = 500;
function Lt(...i) {
  vl !== bd && (vl++, vl === bd ? console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.") : console.warn("PixiJS Warning: ", ...i));
}
function kf(i, t, e) {
  return t.clear(), e || (e = ct.IDENTITY), Mf(i, t, e, i, !0), t.isValid || t.set(0, 0, 0, 0), t;
}
function Mf(i, t, e, n, r) {
  var s, o;
  let a;
  if (r)
    a = ki.get(), a = e.copyTo(a);
  else {
    if (!i.visible || !i.measurable)
      return;
    i.updateLocalTransform();
    const c = i.localTransform;
    a = ki.get(), a.appendFrom(c, e);
  }
  const l = t, h = !!i.effects.length;
  if (h && (t = yr.get().clear()), i.boundsArea)
    t.addRect(i.boundsArea, a);
  else {
    i.renderPipeId && (t.matrix = a, i.addBounds(t));
    const c = i.children;
    for (let p = 0; p < c.length; p++)
      Mf(c[p], t, a, n, !1);
  }
  if (h) {
    for (let c = 0; c < i.effects.length; c++)
      (o = (s = i.effects[c]).addLocalBounds) == null || o.call(s, t, n);
    l.addBounds(t, ct.IDENTITY), yr.return(t);
  }
  ki.return(a);
}
function Of(i, t) {
  const e = i.children;
  for (let n = 0; n < e.length; n++) {
    const r = e[n], s = r.uid, o = (r._didViewChangeTick & 65535) << 16 | r._didContainerChangeTick & 65535, a = t.index;
    (t.data[a] !== s || t.data[a + 1] !== o) && (t.data[t.index] = s, t.data[t.index + 1] = o, t.didChange = !0), t.index = a + 2, r.children.length && Of(r, t);
  }
  return t.didChange;
}
const Sv = new ct(), Tv = {
  _localBoundsCacheId: -1,
  _localBoundsCacheData: null,
  _setWidth(i, t) {
    const e = Math.sign(this.scale.x) || 1;
    t !== 0 ? this.scale.x = i / t * e : this.scale.x = e;
  },
  _setHeight(i, t) {
    const e = Math.sign(this.scale.y) || 1;
    t !== 0 ? this.scale.y = i / t * e : this.scale.y = e;
  },
  /**
   * Retrieves the local bounds of the container as a Bounds object.
   * @returns - The bounding area.
   * @memberof scene.Container#
   */
  getLocalBounds() {
    this._localBoundsCacheData || (this._localBoundsCacheData = {
      data: [],
      index: 1,
      didChange: !1,
      localBounds: new Ji()
    });
    const i = this._localBoundsCacheData;
    return i.index = 1, i.didChange = !1, i.data[0] !== this._didViewChangeTick && (i.didChange = !0, i.data[0] = this._didViewChangeTick), Of(this, i), i.didChange && kf(this, i.localBounds, Sv), i.localBounds;
  },
  /**
   * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.
   * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from
   *  being updated. This means the calculation returned MAY be out of date BUT will give you a
   *  nice performance boost.
   * @param bounds - Optional bounds to store the result of the bounds calculation.
   * @returns - The minimum axis-aligned rectangle in world space that fits around this object.
   * @memberof scene.Container#
   */
  getBounds(i, t) {
    return If(this, i, t || new Ji());
  }
}, Ev = {
  _onRender: null,
  set onRender(i) {
    const t = this.renderGroup || this.parentRenderGroup;
    if (!i) {
      this._onRender && (t == null || t.removeOnRender(this)), this._onRender = null;
      return;
    }
    this._onRender || t == null || t.addOnRender(this), this._onRender = i;
  },
  /**
   * This callback is used when the container is rendered. This is where you should add your custom
   * logic that is needed to be run every frame.
   *
   * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different
   * and "updateTransform" is no longer called every frame
   * @example
   * const container = new Container();
   * container.onRender = () => {
   *    container.rotation += 0.01;
   * };
   * @memberof scene.Container#
   */
  get onRender() {
    return this._onRender;
  }
}, Cv = {
  _zIndex: 0,
  /**
   * Should children be sorted by zIndex at the next render call.
   *
   * Will get automatically set to true if a new child is added, or if a child's zIndex changes.
   * @type {boolean}
   * @memberof scene.Container#
   */
  sortDirty: !1,
  /**
   * If set to true, the container will sort its children by `zIndex` value
   * when the next render is called, or manually if `sortChildren()` is called.
   *
   * This actually changes the order of elements in the array, so should be treated
   * as a basic solution that is not performant compared to other solutions,
   * such as {@link https://github.com/pixijs/layers PixiJS Layers}
   *
   * Also be aware of that this may not work nicely with the `addChildAt()` function,
   * as the `zIndex` sorting may cause the child to automatically sorted to another position.
   * @type {boolean}
   * @memberof scene.Container#
   */
  sortableChildren: !1,
  /**
   * The zIndex of the container.
   *
   * Setting this value, will automatically set the parent to be sortable. Children will be automatically
   * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
   * and thus rendered on top of other display objects within the same container.
   * @see scene.Container#sortableChildren
   * @memberof scene.Container#
   */
  get zIndex() {
    return this._zIndex;
  },
  set zIndex(i) {
    this._zIndex !== i && (this._zIndex = i, this.depthOfChildModified());
  },
  depthOfChildModified() {
    this.parent && (this.parent.sortableChildren = !0, this.parent.sortDirty = !0), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0);
  },
  /**
   * Sorts children by zIndex.
   * @memberof scene.Container#
   */
  sortChildren() {
    this.sortDirty && (this.sortDirty = !1, this.children.sort(Pv));
  }
};
function Pv(i, t) {
  return i._zIndex - t._zIndex;
}
const Iv = {
  /**
   * Returns the global position of the container.
   * @param point - The optional point to write the global value to.
   * @param skipUpdate - Should we skip the update transform.
   * @returns - The updated point.
   * @memberof scene.Container#
   */
  getGlobalPosition(i = new me(), t = !1) {
    return this.parent ? this.parent.toGlobal(this._position, i, t) : (i.x = this._position.x, i.y = this._position.y), i;
  },
  /**
   * Calculates the global position of the container.
   * @param position - The world origin to calculate from.
   * @param point - A Point object in which to store the value, optional
   *  (otherwise will create a new Point).
   * @param skipUpdate - Should we skip the update transform.
   * @returns - A point object representing the position of this object.
   * @memberof scene.Container#
   */
  toGlobal(i, t, e = !1) {
    if (!e) {
      this.updateLocalTransform();
      const n = Xo(this, new ct());
      return n.append(this.localTransform), n.apply(i, t);
    }
    return this.worldTransform.apply(i, t);
  },
  /**
   * Calculates the local position of the container relative to another point.
   * @param position - The world origin to calculate from.
   * @param from - The Container to calculate the global position from.
   * @param point - A Point object in which to store the value, optional
   *  (otherwise will create a new Point).
   * @param skipUpdate - Should we skip the update transform
   * @returns - A point object representing the position of this object
   * @memberof scene.Container#
   */
  toLocal(i, t, e, n) {
    if (t && (i = t.toGlobal(i, e, n)), !n) {
      this.updateLocalTransform();
      const r = Xo(this, new ct());
      return r.append(this.localTransform), r.applyInverse(i, e);
    }
    return this.worldTransform.applyInverse(i, e);
  }
};
let Rv = 0;
class Df {
  constructor() {
    this.uid = qt("instructionSet"), this.instructions = [], this.instructionSize = 0, this.renderables = [], this.tick = 0;
  }
  /** reset the instruction set so it can be reused set size back to 0 */
  reset() {
    this.instructionSize = 0, this.tick = Rv++;
  }
  /**
   * Add an instruction to the set
   * @param instruction - add an instruction to the set
   */
  add(t) {
    this.instructions[this.instructionSize++] = t;
  }
  /**
   * Log the instructions to the console (for debugging)
   * @internal
   * @ignore
   */
  log() {
    this.instructions.length = this.instructionSize, console.table(this.instructions, ["type", "action"]);
  }
}
class kv {
  constructor() {
    this.renderPipeId = "renderGroup", this.root = null, this.canBundle = !1, this.renderGroupParent = null, this.renderGroupChildren = [], this.worldTransform = new ct(), this.worldColorAlpha = 4294967295, this.worldColor = 16777215, this.worldAlpha = 1, this.childrenToUpdate = /* @__PURE__ */ Object.create(null), this.updateTick = 0, this.childrenRenderablesToUpdate = { list: [], index: 0 }, this.structureDidChange = !0, this.instructionSet = new Df(), this._onRenderContainers = [];
  }
  init(t) {
    this.root = t, t._onRender && this.addOnRender(t), t.didChange = !0;
    const e = t.children;
    for (let n = 0; n < e.length; n++)
      this.addChild(e[n]);
  }
  reset() {
    this.renderGroupChildren.length = 0;
    for (const t in this.childrenToUpdate) {
      const e = this.childrenToUpdate[t];
      e.list.fill(null), e.index = 0;
    }
    this.childrenRenderablesToUpdate.index = 0, this.childrenRenderablesToUpdate.list.fill(null), this.root = null, this.updateTick = 0, this.structureDidChange = !0, this._onRenderContainers.length = 0, this.renderGroupParent = null;
  }
  get localTransform() {
    return this.root.localTransform;
  }
  addRenderGroupChild(t) {
    t.renderGroupParent && t.renderGroupParent._removeRenderGroupChild(t), t.renderGroupParent = this, this.renderGroupChildren.push(t);
  }
  _removeRenderGroupChild(t) {
    const e = this.renderGroupChildren.indexOf(t);
    e > -1 && this.renderGroupChildren.splice(e, 1), t.renderGroupParent = null;
  }
  addChild(t) {
    if (this.structureDidChange = !0, t.parentRenderGroup = this, t.updateTick = -1, t.parent === this.root ? t.relativeRenderGroupDepth = 1 : t.relativeRenderGroupDepth = t.parent.relativeRenderGroupDepth + 1, t.didChange = !0, this.onChildUpdate(t), t.renderGroup) {
      this.addRenderGroupChild(t.renderGroup);
      return;
    }
    t._onRender && this.addOnRender(t);
    const e = t.children;
    for (let n = 0; n < e.length; n++)
      this.addChild(e[n]);
  }
  removeChild(t) {
    if (this.structureDidChange = !0, t._onRender && (t.renderGroup || this.removeOnRender(t)), t.parentRenderGroup = null, t.renderGroup) {
      this._removeRenderGroupChild(t.renderGroup);
      return;
    }
    const e = t.children;
    for (let n = 0; n < e.length; n++)
      this.removeChild(e[n]);
  }
  removeChildren(t) {
    for (let e = 0; e < t.length; e++)
      this.removeChild(t[e]);
  }
  onChildUpdate(t) {
    let e = this.childrenToUpdate[t.relativeRenderGroupDepth];
    e || (e = this.childrenToUpdate[t.relativeRenderGroupDepth] = {
      index: 0,
      list: []
    }), e.list[e.index++] = t;
  }
  updateRenderable(t) {
    t.globalDisplayStatus < 7 || (this.instructionSet.renderPipes[t.renderPipeId].updateRenderable(t), t.didViewUpdate = !1);
  }
  onChildViewUpdate(t) {
    this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = t;
  }
  get isRenderable() {
    return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
  }
  /**
   * adding a container to the onRender list will make sure the user function
   * passed in to the user defined 'onRender` callBack
   * @param container - the container to add to the onRender list
   */
  addOnRender(t) {
    this._onRenderContainers.push(t);
  }
  removeOnRender(t) {
    this._onRenderContainers.splice(this._onRenderContainers.indexOf(t), 1);
  }
  runOnRender() {
    for (let t = 0; t < this._onRenderContainers.length; t++)
      this._onRenderContainers[t]._onRender();
  }
  destroy() {
    this.renderGroupParent = null, this.root = null, this.childrenRenderablesToUpdate = null, this.childrenToUpdate = null, this.renderGroupChildren = null, this._onRenderContainers = null, this.instructionSet = null;
  }
  getChildren(t = []) {
    const e = this.root.children;
    for (let n = 0; n < e.length; n++)
      this._getChildren(e[n], t);
    return t;
  }
  _getChildren(t, e = []) {
    if (e.push(t), t.renderGroup)
      return e;
    const n = t.children;
    for (let r = 0; r < n.length; r++)
      this._getChildren(n[r], e);
    return e;
  }
}
function Mv(i, t, e = {}) {
  for (const n in t)
    !e[n] && t[n] !== void 0 && (i[n] = t[n]);
}
const _l = new Wt(null), xl = new Wt(null), bl = new Wt(null, 1, 1), wd = 1, Ov = 2, wl = 4;
class Te extends xe {
  constructor(t = {}) {
    var e, n;
    super(), this.uid = qt("renderable"), this._updateFlags = 15, this.renderGroup = null, this.parentRenderGroup = null, this.parentRenderGroupIndex = 0, this.didChange = !1, this.didViewUpdate = !1, this.relativeRenderGroupDepth = 0, this.children = [], this.parent = null, this.includeInBuild = !0, this.measurable = !0, this.isSimple = !0, this.updateTick = -1, this.localTransform = new ct(), this.relativeGroupTransform = new ct(), this.groupTransform = this.relativeGroupTransform, this.destroyed = !1, this._position = new Wt(this, 0, 0), this._scale = bl, this._pivot = xl, this._skew = _l, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._rotation = 0, this.localColor = 16777215, this.localAlpha = 1, this.groupAlpha = 1, this.groupColor = 16777215, this.groupColorAlpha = 4294967295, this.localBlendMode = "inherit", this.groupBlendMode = "normal", this.localDisplayStatus = 7, this.globalDisplayStatus = 7, this._didContainerChangeTick = 0, this._didViewChangeTick = 0, this._didLocalTransformChangeId = -1, this.effects = [], Mv(this, t, {
      children: !0,
      parent: !0,
      effects: !0
    }), (e = t.children) == null || e.forEach((r) => this.addChild(r)), (n = t.parent) == null || n.addChild(this);
  }
  /**
   * Mixes all enumerable properties and methods from a source object to Container.
   * @param source - The source of properties and methods to mix in.
   */
  static mixin(t) {
    Object.defineProperties(Te.prototype, Object.getOwnPropertyDescriptors(t));
  }
  /**
   * We now use the _didContainerChangeTick and _didViewChangeTick to track changes
   * @deprecated since 8.2.6
   * @ignore
   */
  set _didChangeId(t) {
    this._didViewChangeTick = t >> 12 & 4095, this._didContainerChangeTick = t & 4095;
  }
  get _didChangeId() {
    return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
  }
  /**
   * Adds one or more children to the container.
   *
   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
   * @param {...Container} children - The Container(s) to add to the container
   * @returns {Container} - The first child that was added.
   */
  addChild(...t) {
    if (this.allowChildren || ut(dt, "addChild: Only Containers will be allowed to add children in v8.0.0"), t.length > 1) {
      for (let r = 0; r < t.length; r++)
        this.addChild(t[r]);
      return t[0];
    }
    const e = t[0];
    if (e.parent === this)
      return this.children.splice(this.children.indexOf(e), 1), this.children.push(e), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), e;
    e.parent && e.parent.removeChild(e), this.children.push(e), this.sortableChildren && (this.sortDirty = !0), e.parent = this, e.didChange = !0, e._updateFlags = 15;
    const n = this.renderGroup || this.parentRenderGroup;
    return n && n.addChild(e), this.emit("childAdded", e, this, this.children.length - 1), e.emit("added", this), this._didViewChangeTick++, e._zIndex !== 0 && e.depthOfChildModified(), e;
  }
  /**
   * Removes one or more children from the container.
   * @param {...Container} children - The Container(s) to remove
   * @returns {Container} The first child that was removed.
   */
  removeChild(...t) {
    if (t.length > 1) {
      for (let r = 0; r < t.length; r++)
        this.removeChild(t[r]);
      return t[0];
    }
    const e = t[0], n = this.children.indexOf(e);
    return n > -1 && (this._didViewChangeTick++, this.children.splice(n, 1), this.renderGroup ? this.renderGroup.removeChild(e) : this.parentRenderGroup && this.parentRenderGroup.removeChild(e), e.parent = null, this.emit("childRemoved", e, this, n), e.emit("removed", this)), e;
  }
  /** @ignore */
  _onUpdate(t) {
    t && t === this._skew && this._updateSkew(), this._didContainerChangeTick++, !this.didChange && (this.didChange = !0, this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this));
  }
  set isRenderGroup(t) {
    !!this.renderGroup !== t && (t ? this.enableRenderGroup() : this.disableRenderGroup());
  }
  /**
   * Returns true if this container is a render group.
   * This means that it will be rendered as a separate pass, with its own set of instructions
   */
  get isRenderGroup() {
    return !!this.renderGroup;
  }
  /**
   * Calling this enables a render group for this container.
   * This means it will be rendered as a separate set of instructions.
   * The transform of the container will also be handled on the GPU rather than the CPU.
   */
  enableRenderGroup() {
    if (this.renderGroup)
      return;
    const t = this.parentRenderGroup;
    t == null || t.removeChild(this), this.renderGroup = Ri.get(kv, this), this.groupTransform = ct.IDENTITY, t == null || t.addChild(this), this._updateIsSimple();
  }
  /** This will disable the render group for this container. */
  disableRenderGroup() {
    if (!this.renderGroup)
      return;
    const t = this.parentRenderGroup;
    t == null || t.removeChild(this), Ri.return(this.renderGroup), this.renderGroup = null, this.groupTransform = this.relativeGroupTransform, t == null || t.addChild(this), this._updateIsSimple();
  }
  /** @ignore */
  _updateIsSimple() {
    this.isSimple = !this.renderGroup && this.effects.length === 0;
  }
  /**
   * Current transform of the object based on world (parent) factors.
   * @readonly
   */
  get worldTransform() {
    return this._worldTransform || (this._worldTransform = new ct()), this.renderGroup ? this._worldTransform.copyFrom(this.renderGroup.worldTransform) : this.parentRenderGroup && this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform), this._worldTransform;
  }
  // / ////// transform related stuff
  /**
   * The position of the container on the x axis relative to the local coordinates of the parent.
   * An alias to position.x
   */
  get x() {
    return this._position.x;
  }
  set x(t) {
    this._position.x = t;
  }
  /**
   * The position of the container on the y axis relative to the local coordinates of the parent.
   * An alias to position.y
   */
  get y() {
    return this._position.y;
  }
  set y(t) {
    this._position.y = t;
  }
  /**
   * The coordinate of the object relative to the local coordinates of the parent.
   * @since 4.0.0
   */
  get position() {
    return this._position;
  }
  set position(t) {
    this._position.copyFrom(t);
  }
  /**
   * The rotation of the object in radians.
   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
   */
  get rotation() {
    return this._rotation;
  }
  set rotation(t) {
    this._rotation !== t && (this._rotation = t, this._onUpdate(this._skew));
  }
  /**
   * The angle of the object in degrees.
   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
   */
  get angle() {
    return this.rotation * J0;
  }
  set angle(t) {
    this.rotation = t * Z0;
  }
  /**
   * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
   * is the projection of `pivot` in the parent's local space.
   *
   * By default, the pivot is the origin (0, 0).
   * @since 4.0.0
   */
  get pivot() {
    return this._pivot === xl && (this._pivot = new Wt(this, 0, 0)), this._pivot;
  }
  set pivot(t) {
    this._pivot === xl && (this._pivot = new Wt(this, 0, 0)), typeof t == "number" ? this._pivot.set(t) : this._pivot.copyFrom(t);
  }
  /**
   * The skew factor for the object in radians.
   * @since 4.0.0
   */
  get skew() {
    return this._skew === _l && (this._skew = new Wt(this, 0, 0)), this._skew;
  }
  set skew(t) {
    this._skew === _l && (this._skew = new Wt(this, 0, 0)), this._skew.copyFrom(t);
  }
  /**
   * The scale factors of this object along the local coordinate axes.
   *
   * The default scale is (1, 1).
   * @since 4.0.0
   */
  get scale() {
    return this._scale === bl && (this._scale = new Wt(this, 1, 1)), this._scale;
  }
  set scale(t) {
    this._scale === bl && (this._scale = new Wt(this, 0, 0)), typeof t == "number" ? this._scale.set(t) : this._scale.copyFrom(t);
  }
  /**
   * The width of the Container, setting this will actually modify the scale to achieve the value set.
   * @memberof scene.Container#
   */
  get width() {
    return Math.abs(this.scale.x * this.getLocalBounds().width);
  }
  set width(t) {
    const e = this.getLocalBounds().width;
    this._setWidth(t, e);
  }
  /**
   * The height of the Container, setting this will actually modify the scale to achieve the value set.
   * @memberof scene.Container#
   */
  get height() {
    return Math.abs(this.scale.y * this.getLocalBounds().height);
  }
  set height(t) {
    const e = this.getLocalBounds().height;
    this._setHeight(t, e);
  }
  /**
   * Retrieves the size of the container as a [Size]{@link Size} object.
   * This is faster than get the width and height separately.
   * @param out - Optional object to store the size in.
   * @returns - The size of the container.
   * @memberof scene.Container#
   */
  getSize(t) {
    t || (t = {});
    const e = this.getLocalBounds();
    return t.width = Math.abs(this.scale.x * e.width), t.height = Math.abs(this.scale.y * e.height), t;
  }
  /**
   * Sets the size of the container to the specified width and height.
   * This is faster than setting the width and height separately.
   * @param value - This can be either a number or a [Size]{@link Size} object.
   * @param height - The height to set. Defaults to the value of `width` if not provided.
   * @memberof scene.Container#
   */
  setSize(t, e) {
    const n = this.getLocalBounds();
    typeof t == "object" ? (e = t.height ?? t.width, t = t.width) : e ?? (e = t), t !== void 0 && this._setWidth(t, n.width), e !== void 0 && this._setHeight(e, n.height);
  }
  /** Called when the skew or the rotation changes. */
  _updateSkew() {
    const t = this._rotation, e = this._skew;
    this._cx = Math.cos(t + e._y), this._sx = Math.sin(t + e._y), this._cy = -Math.sin(t - e._x), this._sy = Math.cos(t - e._x);
  }
  /**
   * Updates the transform properties of the container (accepts partial values).
   * @param {object} opts - The options for updating the transform.
   * @param {number} opts.x - The x position of the container.
   * @param {number} opts.y - The y position of the container.
   * @param {number} opts.scaleX - The scale factor on the x-axis.
   * @param {number} opts.scaleY - The scale factor on the y-axis.
   * @param {number} opts.rotation - The rotation of the container, in radians.
   * @param {number} opts.skewX - The skew factor on the x-axis.
   * @param {number} opts.skewY - The skew factor on the y-axis.
   * @param {number} opts.pivotX - The x coordinate of the pivot point.
   * @param {number} opts.pivotY - The y coordinate of the pivot point.
   */
  updateTransform(t) {
    return this.position.set(
      typeof t.x == "number" ? t.x : this.position.x,
      typeof t.y == "number" ? t.y : this.position.y
    ), this.scale.set(
      typeof t.scaleX == "number" ? t.scaleX || 1 : this.scale.x,
      typeof t.scaleY == "number" ? t.scaleY || 1 : this.scale.y
    ), this.rotation = typeof t.rotation == "number" ? t.rotation : this.rotation, this.skew.set(
      typeof t.skewX == "number" ? t.skewX : this.skew.x,
      typeof t.skewY == "number" ? t.skewY : this.skew.y
    ), this.pivot.set(
      typeof t.pivotX == "number" ? t.pivotX : this.pivot.x,
      typeof t.pivotY == "number" ? t.pivotY : this.pivot.y
    ), this;
  }
  /**
   * Updates the local transform using the given matrix.
   * @param matrix - The matrix to use for updating the transform.
   */
  setFromMatrix(t) {
    t.decompose(this);
  }
  /** Updates the local transform. */
  updateLocalTransform() {
    const t = this._didContainerChangeTick;
    if (this._didLocalTransformChangeId === t)
      return;
    this._didLocalTransformChangeId = t;
    const e = this.localTransform, n = this._scale, r = this._pivot, s = this._position, o = n._x, a = n._y, l = r._x, h = r._y;
    e.a = this._cx * o, e.b = this._sx * o, e.c = this._cy * a, e.d = this._sy * a, e.tx = s._x - (l * e.a + h * e.c), e.ty = s._y - (l * e.b + h * e.d);
  }
  // / ///// color related stuff
  set alpha(t) {
    t !== this.localAlpha && (this.localAlpha = t, this._updateFlags |= wd, this._onUpdate());
  }
  /** The opacity of the object. */
  get alpha() {
    return this.localAlpha;
  }
  set tint(t) {
    const e = Gt.shared.setValue(t ?? 16777215).toBgrNumber();
    e !== this.localColor && (this.localColor = e, this._updateFlags |= wd, this._onUpdate());
  }
  /**
   * The tint applied to the sprite. This is a hex value.
   *
   * A value of 0xFFFFFF will remove any tint effect.
   * @default 0xFFFFFF
   */
  get tint() {
    const t = this.localColor;
    return ((t & 255) << 16) + (t & 65280) + (t >> 16 & 255);
  }
  // / //////////////// blend related stuff
  set blendMode(t) {
    this.localBlendMode !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= Ov, this.localBlendMode = t, this._onUpdate());
  }
  /**
   * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.
   * @default 'normal'
   */
  get blendMode() {
    return this.localBlendMode;
  }
  // / ///////// VISIBILITY / RENDERABLE /////////////////
  /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */
  get visible() {
    return !!(this.localDisplayStatus & 2);
  }
  set visible(t) {
    const e = t ? 2 : 0;
    (this.localDisplayStatus & 2) !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= wl, this.localDisplayStatus ^= 2, this._onUpdate());
  }
  /** @ignore */
  get culled() {
    return !(this.localDisplayStatus & 4);
  }
  /** @ignore */
  set culled(t) {
    const e = t ? 0 : 4;
    (this.localDisplayStatus & 4) !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= wl, this.localDisplayStatus ^= 4, this._onUpdate());
  }
  /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */
  get renderable() {
    return !!(this.localDisplayStatus & 1);
  }
  set renderable(t) {
    const e = t ? 1 : 0;
    (this.localDisplayStatus & 1) !== e && (this._updateFlags |= wl, this.localDisplayStatus ^= 1, this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._onUpdate());
  }
  /** Whether or not the object should be rendered. */
  get isRenderable() {
    return this.localDisplayStatus === 7 && this.groupAlpha > 0;
  }
  /**
   * Removes all internal references and listeners as well as removes children from the display list.
   * Do not use a Container after calling `destroy`.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
   *  method called as well. 'options' will be passed on to those calls.
   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children
   * is set to true it should destroy the texture of the child sprite
   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
   * If options.children is set to true it should destroy the texture source of the child sprite
   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
   * If options.children is set to true it should destroy the context of the child graphics
   */
  destroy(t = !1) {
    var e;
    if (this.destroyed)
      return;
    this.destroyed = !0;
    let n;
    if (this.children.length && (n = this.removeChildren(0, this.children.length)), this.removeFromParent(), this.parent = null, this._maskEffect = null, this._filterEffect = null, this.effects = null, this._position = null, this._scale = null, this._pivot = null, this._skew = null, this.emit("destroyed", this), this.removeAllListeners(), (typeof t == "boolean" ? t : t == null ? void 0 : t.children) && n)
      for (let r = 0; r < n.length; ++r)
        n[r].destroy(t);
    (e = this.renderGroup) == null || e.destroy(), this.renderGroup = null;
  }
}
Te.mixin(xv);
Te.mixin(Iv);
Te.mixin(Ev);
Te.mixin(Tv);
Te.mixin(wv);
Te.mixin(Av);
Te.mixin(Cv);
Te.mixin(yv);
class Ea extends Te {
  constructor() {
    super(...arguments), this.canBundle = !0, this.allowChildren = !1, this._roundPixels = 0, this._lastUsed = 0, this._lastInstructionTick = -1, this._bounds = new Ji(0, 1, 0, 0), this._boundsDirty = !0;
  }
  /** @private */
  _updateBounds() {
  }
  /**
   * Whether or not to round the x/y position of the sprite.
   * @type {boolean}
   */
  get roundPixels() {
    return !!this._roundPixels;
  }
  set roundPixels(t) {
    this._roundPixels = t ? 1 : 0;
  }
  /**
   * Checks if the object contains the given point.
   * @param point - The point to check
   */
  containsPoint(t) {
    const e = this.bounds, { x: n, y: r } = t;
    return n >= e.minX && n <= e.maxX && r >= e.minY && r <= e.maxY;
  }
  /** @private */
  onViewUpdate() {
    if (this._didViewChangeTick++, this.didViewUpdate)
      return;
    this.didViewUpdate = !0;
    const t = this.renderGroup || this.parentRenderGroup;
    t && t.onChildViewUpdate(this);
  }
  destroy(t) {
    super.destroy(t), this._bounds = null;
  }
}
class vr extends Ea {
  /**
   * @param options - The options for creating the sprite.
   */
  constructor(t = nt.EMPTY) {
    t instanceof nt && (t = { texture: t });
    const { texture: e = nt.EMPTY, anchor: n, roundPixels: r, width: s, height: o, ...a } = t;
    super({
      label: "Sprite",
      ...a
    }), this.renderPipeId = "sprite", this.batched = !0, this._sourceBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }, this._sourceBoundsDirty = !0, this._anchor = new Wt(
      {
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }
    ), n ? this.anchor = n : e.defaultAnchor && (this.anchor = e.defaultAnchor), this.texture = e, this.allowChildren = !1, this.roundPixels = r ?? !1, s !== void 0 && (this.width = s), o !== void 0 && (this.height = o);
  }
  /**
   * Helper function that creates a new sprite based on the source you provide.
   * The source can be - frame id, image, video, canvas element, video element, texture
   * @param source - Source to create texture from
   * @param [skipCache] - Whether to skip the cache or not
   * @returns The newly created sprite
   */
  static from(t, e = !1) {
    return t instanceof nt ? new vr(t) : new vr(nt.from(t, e));
  }
  set texture(t) {
    t || (t = nt.EMPTY);
    const e = this._texture;
    e !== t && (e && e.dynamic && e.off("update", this.onViewUpdate, this), t.dynamic && t.on("update", this.onViewUpdate, this), this._texture = t, this._width && this._setWidth(this._width, this._texture.orig.width), this._height && this._setHeight(this._height, this._texture.orig.height), this.onViewUpdate());
  }
  /** The texture that the sprite is using. */
  get texture() {
    return this._texture;
  }
  /**
   * The local bounds of the sprite.
   * @type {rendering.Bounds}
   */
  get bounds() {
    return this._boundsDirty && (this._updateBounds(), this._boundsDirty = !1), this._bounds;
  }
  /**
   * The bounds of the sprite, taking the texture's trim into account.
   * @type {rendering.Bounds}
   */
  get sourceBounds() {
    return this._sourceBoundsDirty && (this._updateSourceBounds(), this._sourceBoundsDirty = !1), this._sourceBounds;
  }
  /**
   * Checks if the object contains the given point.
   * @param point - The point to check
   */
  containsPoint(t) {
    const e = this.sourceBounds;
    return t.x >= e.maxX && t.x <= e.minX && t.y >= e.maxY && t.y <= e.minY;
  }
  /**
   * Adds the bounds of this object to the bounds object.
   * @param bounds - The output bounds object.
   */
  addBounds(t) {
    const e = this._texture.trim ? this.sourceBounds : this.bounds;
    t.addFrame(e.minX, e.minY, e.maxX, e.maxY);
  }
  onViewUpdate() {
    this._sourceBoundsDirty = this._boundsDirty = !0, super.onViewUpdate();
  }
  _updateBounds() {
    av(this._bounds, this._anchor, this._texture, 0);
  }
  _updateSourceBounds() {
    const t = this._anchor, e = this._texture, n = this._sourceBounds, { width: r, height: s } = e.orig;
    n.maxX = -t._x * r, n.minX = n.maxX + r, n.maxY = -t._y * s, n.minY = n.maxY + s;
  }
  /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
   */
  destroy(t = !1) {
    if (super.destroy(t), typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
      const e = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
      this._texture.destroy(e);
    }
    this._texture = null, this._bounds = null, this._sourceBounds = null, this._anchor = null;
  }
  /**
   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
   * and passed to the constructor.
   *
   * The default is `(0,0)`, this means the sprite's origin is the top left.
   *
   * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
   *
   * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
   *
   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
   * @example
   * import { Sprite } from 'pixi.js';
   *
   * const sprite = new Sprite({texture: Texture.WHITE});
   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(t) {
    typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t);
  }
  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
  get width() {
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(t) {
    this._setWidth(t, this._texture.orig.width), this._width = t;
  }
  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
  get height() {
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(t) {
    this._setHeight(t, this._texture.orig.height), this._height = t;
  }
  /**
   * Retrieves the size of the Sprite as a [Size]{@link Size} object.
   * This is faster than get the width and height separately.
   * @param out - Optional object to store the size in.
   * @returns - The size of the Sprite.
   */
  getSize(t) {
    return t || (t = {}), t.width = Math.abs(this.scale.x) * this._texture.orig.width, t.height = Math.abs(this.scale.y) * this._texture.orig.height, t;
  }
  /**
   * Sets the size of the Sprite to the specified width and height.
   * This is faster than setting the width and height separately.
   * @param value - This can be either a number or a [Size]{@link Size} object.
   * @param height - The height to set. Defaults to the value of `width` if not provided.
   */
  setSize(t, e) {
    typeof t == "object" ? (e = t.height ?? t.width, t = t.width) : e ?? (e = t), t !== void 0 && this._setWidth(t, this._texture.orig.width), e !== void 0 && this._setHeight(e, this._texture.orig.height);
  }
}
const Dv = new Ji();
function Bf(i, t, e) {
  const n = Dv;
  i.measurable = !0, If(i, e, n), t.addBoundsMask(n), i.measurable = !1;
}
function Vf(i, t, e) {
  const n = yr.get();
  i.measurable = !0;
  const r = ki.get().identity(), s = Ff(i, e, r);
  kf(i, n, s), i.measurable = !1, t.addBoundsMask(n), ki.return(r), yr.return(n);
}
function Ff(i, t, e) {
  return i ? (i !== t && (Ff(i.parent, t, e), i.updateLocalTransform(), e.append(i.localTransform)), e) : (Lt("Mask bounds, renderable is not inside the root container"), e);
}
class Lf {
  constructor(t) {
    this.priority = 0, this.inverse = !1, this.pipe = "alphaMask", t != null && t.mask && this.init(t.mask);
  }
  init(t) {
    this.mask = t, this.renderMaskToTexture = !(t instanceof vr), this.mask.renderable = this.renderMaskToTexture, this.mask.includeInBuild = !this.renderMaskToTexture, this.mask.measurable = !1;
  }
  reset() {
    this.mask.measurable = !0, this.mask = null;
  }
  addBounds(t, e) {
    this.inverse || Bf(this.mask, t, e);
  }
  addLocalBounds(t, e) {
    Vf(this.mask, t, e);
  }
  containsPoint(t, e) {
    const n = this.mask;
    return e(n, t);
  }
  destroy() {
    this.reset();
  }
  static test(t) {
    return t instanceof vr;
  }
}
Lf.extension = X.MaskEffect;
class Nf {
  constructor(t) {
    this.priority = 0, this.pipe = "colorMask", t != null && t.mask && this.init(t.mask);
  }
  init(t) {
    this.mask = t;
  }
  destroy() {
  }
  static test(t) {
    return typeof t == "number";
  }
}
Nf.extension = X.MaskEffect;
class Uf {
  constructor(t) {
    this.priority = 0, this.pipe = "stencilMask", t != null && t.mask && this.init(t.mask);
  }
  init(t) {
    this.mask = t, this.mask.includeInBuild = !1, this.mask.measurable = !1;
  }
  reset() {
    this.mask.measurable = !0, this.mask.includeInBuild = !0, this.mask = null;
  }
  addBounds(t, e) {
    Bf(this.mask, t, e);
  }
  addLocalBounds(t, e) {
    Vf(this.mask, t, e);
  }
  containsPoint(t, e) {
    const n = this.mask;
    return e(n, t);
  }
  destroy() {
    this.reset();
  }
  static test(t) {
    return t instanceof Te;
  }
}
Uf.extension = X.MaskEffect;
const Bv = {
  createCanvas: (i, t) => {
    const e = document.createElement("canvas");
    return e.width = i, e.height = t, e;
  },
  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
  getWebGLRenderingContext: () => WebGLRenderingContext,
  getNavigator: () => navigator,
  getBaseUrl: () => document.baseURI ?? window.location.href,
  getFontFaceSet: () => document.fonts,
  fetch: (i, t) => fetch(i, t),
  parseXML: (i) => new DOMParser().parseFromString(i, "text/xml")
};
let Ad = Bv;
const Mt = {
  /**
   * Returns the current adapter.
   * @returns {environment.Adapter} The current adapter.
   */
  get() {
    return Ad;
  },
  /**
   * Sets the current adapter.
   * @param adapter - The new adapter.
   */
  set(i) {
    Ad = i;
  }
};
class zf extends bi {
  constructor(t) {
    t.resource || (t.resource = Mt.get().createCanvas()), t.width || (t.width = t.resource.width, t.autoDensity || (t.width /= t.resolution)), t.height || (t.height = t.resource.height, t.autoDensity || (t.height /= t.resolution)), super(t), this.uploadMethodId = "image", this.autoDensity = t.autoDensity;
    const e = t.resource;
    (this.pixelWidth !== e.width || this.pixelWidth !== e.height) && this.resizeCanvas(), this.transparent = !!t.transparent;
  }
  resizeCanvas() {
    this.autoDensity && (this.resource.style.width = `${this.width}px`, this.resource.style.height = `${this.height}px`), (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) && (this.resource.width = this.pixelWidth, this.resource.height = this.pixelHeight);
  }
  resize(t = this.width, e = this.height, n = this._resolution) {
    const r = super.resize(t, e, n);
    return r && this.resizeCanvas(), r;
  }
  static test(t) {
    return globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && t instanceof OffscreenCanvas;
  }
  /**
   * Returns the 2D rendering context for the canvas.
   * Caches the context after creating it.
   * @returns The 2D rendering context of the canvas.
   */
  get context2D() {
    return this._context2D || (this._context2D = this.resource.getContext("2d"));
  }
}
zf.extension = X.TextureSource;
class Rr extends bi {
  constructor(t) {
    if (t.resource && globalThis.HTMLImageElement && t.resource instanceof HTMLImageElement) {
      const e = Mt.get().createCanvas(t.resource.width, t.resource.height);
      e.getContext("2d").drawImage(t.resource, 0, 0, t.resource.width, t.resource.height), t.resource = e, Lt("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.");
    }
    super(t), this.uploadMethodId = "image", this.autoGarbageCollect = !0;
  }
  static test(t) {
    return globalThis.HTMLImageElement && t instanceof HTMLImageElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap || globalThis.VideoFrame && t instanceof VideoFrame;
  }
}
Rr.extension = X.TextureSource;
var ch = /* @__PURE__ */ ((i) => (i[i.INTERACTION = 50] = "INTERACTION", i[i.HIGH = 25] = "HIGH", i[i.NORMAL = 0] = "NORMAL", i[i.LOW = -25] = "LOW", i[i.UTILITY = -50] = "UTILITY", i))(ch || {});
class Al {
  /**
   * Constructor
   * @private
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param priority - The priority for emitting
   * @param once - If the handler should fire once
   */
  constructor(t, e = null, n = 0, r = !1) {
    this.next = null, this.previous = null, this._destroyed = !1, this._fn = t, this._context = e, this.priority = n, this._once = r;
  }
  /**
   * Simple compare function to figure out if a function and context match.
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @returns `true` if the listener match the arguments
   */
  match(t, e = null) {
    return this._fn === t && this._context === e;
  }
  /**
   * Emit by calling the current function.
   * @param ticker - The ticker emitting.
   * @returns Next ticker
   */
  emit(t) {
    this._fn && (this._context ? this._fn.call(this._context, t) : this._fn(t));
    const e = this.next;
    return this._once && this.destroy(!0), this._destroyed && (this.next = null), e;
  }
  /**
   * Connect to the list.
   * @param previous - Input node, previous listener
   */
  connect(t) {
    this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this;
  }
  /**
   * Destroy and don't use after this.
   * @param hard - `true` to remove the `next` reference, this
   *        is considered a hard destroy. Soft destroy maintains the next reference.
   * @returns The listener to redirect while emitting or removing.
   */
  destroy(t = !1) {
    this._destroyed = !0, this._fn = null, this._context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
    const e = this.next;
    return this.next = t ? null : e, this.previous = null, e;
  }
}
const jf = class je {
  constructor() {
    this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new Al(null, null, 1 / 0), this.deltaMS = 1 / je.targetFPMS, this.elapsedMS = 1 / je.targetFPMS, this._tick = (t) => {
      this._requestId = null, this.started && (this.update(t), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));
    };
  }
  /**
   * Conditionally requests a new animation frame.
   * If a frame has not already been requested, and if the internal
   * emitter has listeners, a new frame is requested.
   * @private
   */
  _requestIfNeeded() {
    this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
  }
  /**
   * Conditionally cancels a pending animation frame.
   * @private
   */
  _cancelIfNeeded() {
    this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
  }
  /**
   * Conditionally requests a new animation frame.
   * If the ticker has been started it checks if a frame has not already
   * been requested, and if the internal emitter has listeners. If these
   * conditions are met, a new frame is requested. If the ticker has not
   * been started, but autoStart is `true`, then the ticker starts now,
   * and continues with the previous conditions to request a new frame.
   * @private
   */
  _startIfPossible() {
    this.started ? this._requestIfNeeded() : this.autoStart && this.start();
  }
  /**
   * Register a handler for tick events. Calls continuously unless
   * it is removed or the ticker is stopped.
   * @param fn - The listener function to be added for updates
   * @param context - The listener context
   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
   * @returns This instance of a ticker
   */
  add(t, e, n = ch.NORMAL) {
    return this._addListener(new Al(t, e, n));
  }
  /**
   * Add a handler for the tick event which is only execute once.
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
   * @returns This instance of a ticker
   */
  addOnce(t, e, n = ch.NORMAL) {
    return this._addListener(new Al(t, e, n, !0));
  }
  /**
   * Internally adds the event handler so that it can be sorted by priority.
   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
   * before the rendering.
   * @private
   * @param listener - Current listener being added.
   * @returns This instance of a ticker
   */
  _addListener(t) {
    let e = this._head.next, n = this._head;
    if (!e)
      t.connect(n);
    else {
      for (; e; ) {
        if (t.priority > e.priority) {
          t.connect(n);
          break;
        }
        n = e, e = e.next;
      }
      t.previous || t.connect(n);
    }
    return this._startIfPossible(), this;
  }
  /**
   * Removes any handlers matching the function and context parameters.
   * If no handlers are left after removing, then it cancels the animation frame.
   * @param fn - The listener function to be removed
   * @param context - The listener context to be removed
   * @returns This instance of a ticker
   */
  remove(t, e) {
    let n = this._head.next;
    for (; n; )
      n.match(t, e) ? n = n.destroy() : n = n.next;
    return this._head.next || this._cancelIfNeeded(), this;
  }
  /**
   * The number of listeners on this ticker, calculated by walking through linked list
   * @readonly
   * @member {number}
   */
  get count() {
    if (!this._head)
      return 0;
    let t = 0, e = this._head;
    for (; e = e.next; )
      t++;
    return t;
  }
  /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */
  start() {
    this.started || (this.started = !0, this._requestIfNeeded());
  }
  /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */
  stop() {
    this.started && (this.started = !1, this._cancelIfNeeded());
  }
  /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */
  destroy() {
    if (!this._protected) {
      this.stop();
      let t = this._head.next;
      for (; t; )
        t = t.destroy(!0);
      this._head.destroy(), this._head = null;
    }
  }
  /**
   * Triggers an update. An update entails setting the
   * current {@link ticker.Ticker#elapsedMS|elapsedMS},
   * the current {@link ticker.Ticker#deltaTime|deltaTime},
   * invoking all listeners with current deltaTime,
   * and then finally setting {@link ticker.Ticker#lastTime|lastTime}
   * with the value of currentTime that was provided.
   * This method will be called automatically by animation
   * frame callbacks if the ticker instance has been started
   * and listeners are added.
   * @param {number} [currentTime=performance.now()] - the current time of execution
   */
  update(t = performance.now()) {
    let e;
    if (t > this.lastTime) {
      if (e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {
        const s = t - this._lastFrame | 0;
        if (s < this._minElapsedMS)
          return;
        this._lastFrame = t - s % this._minElapsedMS;
      }
      this.deltaMS = e, this.deltaTime = this.deltaMS * je.targetFPMS;
      const n = this._head;
      let r = n.next;
      for (; r; )
        r = r.emit(this);
      n.next || this._cancelIfNeeded();
    } else
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    this.lastTime = t;
  }
  /**
   * The frames per second at which this ticker is running.
   * The default is approximately 60 in most modern browsers.
   * **Note:** This does not factor in the value of
   * {@link ticker.Ticker#speed|speed}, which is specific
   * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.
   * @member {number}
   * @readonly
   */
  get FPS() {
    return 1e3 / this.elapsedMS;
  }
  /**
   * Manages the maximum amount of milliseconds allowed to
   * elapse between invoking {@link ticker.Ticker#update|update}.
   * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},
   * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.
   * When setting this property it is clamped to a value between
   * `0` and `Ticker.targetFPMS * 1000`.
   * @member {number}
   * @default 10
   */
  get minFPS() {
    return 1e3 / this._maxElapsedMS;
  }
  set minFPS(t) {
    const e = Math.min(this.maxFPS, t), n = Math.min(Math.max(0, e) / 1e3, je.targetFPMS);
    this._maxElapsedMS = 1 / n;
  }
  /**
   * Manages the minimum amount of milliseconds required to
   * elapse between invoking {@link ticker.Ticker#update|update}.
   * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.
   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
   * Otherwise it will be at least `minFPS`
   * @member {number}
   * @default 0
   */
  get maxFPS() {
    return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
  }
  set maxFPS(t) {
    if (t === 0)
      this._minElapsedMS = 0;
    else {
      const e = Math.max(this.minFPS, t);
      this._minElapsedMS = 1 / (e / 1e3);
    }
  }
  /**
   * The shared ticker instance used by {@link AnimatedSprite} and by
   * {@link VideoResource} to update animation frames / video textures.
   *
   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.
   *
   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.
   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
   * @example
   * import { Ticker } from 'pixi.js';
   *
   * const ticker = Ticker.shared;
   * // Set this to prevent starting this ticker when listeners are added.
   * // By default this is true only for the Ticker.shared instance.
   * ticker.autoStart = false;
   *
   * // FYI, call this to ensure the ticker is stopped. It should be stopped
   * // if you have not attempted to render anything yet.
   * ticker.stop();
   *
   * // Call this when you are ready for a running shared ticker.
   * ticker.start();
   * @example
   * import { autoDetectRenderer, Container } from 'pixi.js';
   *
   * // You may use the shared ticker to render...
   * const renderer = autoDetectRenderer();
   * const stage = new Container();
   * document.body.appendChild(renderer.view);
   * ticker.add((time) => renderer.render(stage));
   *
   * // Or you can just update it manually.
   * ticker.autoStart = false;
   * ticker.stop();
   * const animate = (time) => {
   *     ticker.update(time);
   *     renderer.render(stage);
   *     requestAnimationFrame(animate);
   * };
   * animate(performance.now());
   * @member {ticker.Ticker}
   * @readonly
   * @static
   */
  static get shared() {
    if (!je._shared) {
      const t = je._shared = new je();
      t.autoStart = !0, t._protected = !0;
    }
    return je._shared;
  }
  /**
   * The system ticker instance used by {@link BasePrepare} for core timing
   * functionality that shouldn't usually need to be paused, unlike the `shared`
   * ticker which drives visual animations and rendering which may want to be paused.
   *
   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.
   * @member {ticker.Ticker}
   * @readonly
   * @static
   */
  static get system() {
    if (!je._system) {
      const t = je._system = new je();
      t.autoStart = !0, t._protected = !0;
    }
    return je._system;
  }
};
jf.targetFPMS = 0.06;
let Ii = jf, Sl;
async function Gf() {
  return Sl ?? (Sl = (async () => {
    var i;
    const t = document.createElement("canvas").getContext("webgl");
    if (!t)
      return "premultiply-alpha-on-upload";
    const e = await new Promise((o) => {
      const a = document.createElement("video");
      a.onloadeddata = () => o(a), a.onerror = () => o(null), a.autoplay = !1, a.crossOrigin = "anonymous", a.preload = "auto", a.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", a.load();
    });
    if (!e)
      return "premultiply-alpha-on-upload";
    const n = t.createTexture();
    t.bindTexture(t.TEXTURE_2D, n);
    const r = t.createFramebuffer();
    t.bindFramebuffer(t.FRAMEBUFFER, r), t.framebufferTexture2D(
      t.FRAMEBUFFER,
      t.COLOR_ATTACHMENT0,
      t.TEXTURE_2D,
      n,
      0
    ), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e);
    const s = new Uint8Array(4);
    return t.readPixels(0, 0, 1, 1, t.RGBA, t.UNSIGNED_BYTE, s), t.deleteFramebuffer(r), t.deleteTexture(n), (i = t.getExtension("WEBGL_lose_context")) == null || i.loseContext(), s[0] <= s[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
  })()), Sl;
}
const Ca = class Hf extends bi {
  constructor(t) {
    super(t), this.isReady = !1, this.uploadMethodId = "video", t = {
      ...Hf.defaultOptions,
      ...t
    }, this._autoUpdate = !0, this._isConnectedToTicker = !1, this._updateFPS = t.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = t.autoPlay !== !1, this.alphaMode = t.alphaMode ?? "premultiply-alpha-on-upload", this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onCanPlayThrough = this._onCanPlayThrough.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), t.autoLoad !== !1 && this.load();
  }
  /** Update the video frame if the source is not destroyed and meets certain conditions. */
  updateFrame() {
    if (!this.destroyed) {
      if (this._updateFPS) {
        const t = Ii.shared.elapsedMS * this.resource.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - t);
      }
      (!this._updateFPS || this._msToNextUpdate <= 0) && (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0), this.isValid && this.update();
    }
  }
  /** Callback to update the video frame and potentially request the next frame update. */
  _videoFrameRequestCallback() {
    this.updateFrame(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
      this._videoFrameRequestCallback
    );
  }
  /**
   * Checks if the resource has valid dimensions.
   * @returns {boolean} True if width and height are set, otherwise false.
   */
  get isValid() {
    return !!this.resource.videoWidth && !!this.resource.videoHeight;
  }
  /**
   * Start preloading the video resource.
   * @returns {Promise<this>} Handle the validate event
   */
  async load() {
    if (this._load)
      return this._load;
    const t = this.resource, e = this.options;
    return (t.readyState === t.HAVE_ENOUGH_DATA || t.readyState === t.HAVE_FUTURE_DATA) && t.width && t.height && (t.complete = !0), t.addEventListener("play", this._onPlayStart), t.addEventListener("pause", this._onPlayStop), t.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._mediaReady() : (e.preload || t.addEventListener("canplay", this._onCanPlay), t.addEventListener("canplaythrough", this._onCanPlayThrough), t.addEventListener("error", this._onError, !0)), this.alphaMode = await Gf(), this._load = new Promise((n, r) => {
      this.isValid ? n(this) : (this._resolve = n, this._reject = r, e.preloadTimeoutMs !== void 0 && (this._preloadTimeout = setTimeout(() => {
        this._onError(new ErrorEvent(`Preload exceeded timeout of ${e.preloadTimeoutMs}ms`));
      })), t.load());
    }), this._load;
  }
  /**
   * Handle video error events.
   * @param event - The error event
   */
  _onError(t) {
    this.resource.removeEventListener("error", this._onError, !0), this.emit("error", t), this._reject && (this._reject(t), this._reject = null, this._resolve = null);
  }
  /**
   * Checks if the underlying source is playing.
   * @returns True if playing.
   */
  _isSourcePlaying() {
    const t = this.resource;
    return !t.paused && !t.ended;
  }
  /**
   * Checks if the underlying source is ready for playing.
   * @returns True if ready.
   */
  _isSourceReady() {
    return this.resource.readyState > 2;
  }
  /** Runs the update loop when the video is ready to play. */
  _onPlayStart() {
    this.isValid || this._mediaReady(), this._configureAutoUpdate();
  }
  /** Stops the update loop when a pause event is triggered. */
  _onPlayStop() {
    this._configureAutoUpdate();
  }
  /** Handles behavior when the video completes seeking to the current playback position. */
  _onSeeked() {
    this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0);
  }
  _onCanPlay() {
    this.resource.removeEventListener("canplay", this._onCanPlay), this._mediaReady();
  }
  _onCanPlayThrough() {
    this.resource.removeEventListener("canplaythrough", this._onCanPlay), this._preloadTimeout && (clearTimeout(this._preloadTimeout), this._preloadTimeout = void 0), this._mediaReady();
  }
  /** Fired when the video is loaded and ready to play. */
  _mediaReady() {
    const t = this.resource;
    this.isValid && (this.isReady = !0, this.resize(t.videoWidth, t.videoHeight)), this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0, this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play();
  }
  /** Cleans up resources and event listeners associated with this texture. */
  destroy() {
    this._configureAutoUpdate();
    const t = this.resource;
    t && (t.removeEventListener("play", this._onPlayStart), t.removeEventListener("pause", this._onPlayStop), t.removeEventListener("seeked", this._onSeeked), t.removeEventListener("canplay", this._onCanPlay), t.removeEventListener("canplaythrough", this._onCanPlayThrough), t.removeEventListener("error", this._onError, !0), t.pause(), t.src = "", t.load()), super.destroy();
  }
  /** Should the base texture automatically update itself, set to true by default. */
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(t) {
    t !== this._autoUpdate && (this._autoUpdate = t, this._configureAutoUpdate());
  }
  /**
   * How many times a second to update the texture from the video.
   * Leave at 0 to update at every render.
   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
   */
  get updateFPS() {
    return this._updateFPS;
  }
  set updateFPS(t) {
    t !== this._updateFPS && (this._updateFPS = t, this._configureAutoUpdate());
  }
  /**
   * Configures the updating mechanism based on the current state and settings.
   *
   * This method decides between using the browser's native video frame callback or a custom ticker
   * for updating the video frame. It ensures optimal performance and responsiveness
   * based on the video's state, playback status, and the desired frames-per-second setting.
   *
   * - If `_autoUpdate` is enabled and the video source is playing:
   *   - It will prefer the native video frame callback if available and no specific FPS is set.
   *   - Otherwise, it will use a custom ticker for manual updates.
   * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.
   */
  _configureAutoUpdate() {
    this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.resource.requestVideoFrameCallback ? (this._isConnectedToTicker && (Ii.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
      this._videoFrameRequestCallback
    ))) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (Ii.shared.add(this.updateFrame, this), this._isConnectedToTicker = !0, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (Ii.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0));
  }
  static test(t) {
    return globalThis.HTMLVideoElement && t instanceof HTMLVideoElement;
  }
};
Ca.extension = X.TextureSource;
Ca.defaultOptions = {
  ...bi.defaultOptions,
  /** If true, the video will start loading immediately. */
  autoLoad: !0,
  /** If true, the video will start playing as soon as it is loaded. */
  autoPlay: !0,
  /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */
  updateFPS: 0,
  /** If true, the video will be loaded with the `crossorigin` attribute. */
  crossorigin: !0,
  /** If true, the video will loop when it ends. */
  loop: !1,
  /** If true, the video will be muted. */
  muted: !0,
  /** If true, the video will play inline. */
  playsinline: !0,
  /** If true, the video will be preloaded. */
  preload: !1
};
Ca.MIME_TYPES = {
  ogv: "video/ogg",
  mov: "video/quicktime",
  m4v: "video/mp4"
};
let Vo = Ca;
const si = (i, t, e = !1) => (Array.isArray(i) || (i = [i]), t ? i.map((n) => typeof n == "string" || e ? t(n) : n) : i);
class Vv {
  constructor() {
    this._parsers = [], this._cache = /* @__PURE__ */ new Map(), this._cacheMap = /* @__PURE__ */ new Map();
  }
  /** Clear all entries. */
  reset() {
    this._cacheMap.clear(), this._cache.clear();
  }
  /**
   * Check if the key exists
   * @param key - The key to check
   */
  has(t) {
    return this._cache.has(t);
  }
  /**
   * Fetch entry by key
   * @param key - The key of the entry to get
   */
  get(t) {
    const e = this._cache.get(t);
    return e || Lt(`[Assets] Asset id ${t} was not found in the Cache`), e;
  }
  /**
   * Set a value by key or keys name
   * @param key - The key or keys to set
   * @param value - The value to store in the cache or from which cacheable assets will be derived.
   */
  set(t, e) {
    const n = si(t);
    let r;
    for (let l = 0; l < this.parsers.length; l++) {
      const h = this.parsers[l];
      if (h.test(e)) {
        r = h.getCacheableAssets(n, e);
        break;
      }
    }
    const s = new Map(Object.entries(r || {}));
    r || n.forEach((l) => {
      s.set(l, e);
    });
    const o = [...s.keys()], a = {
      cacheKeys: o,
      keys: n
    };
    n.forEach((l) => {
      this._cacheMap.set(l, a);
    }), o.forEach((l) => {
      const h = r ? r[l] : e;
      this._cache.has(l) && this._cache.get(l) !== h && Lt("[Cache] already has key:", l), this._cache.set(l, s.get(l));
    });
  }
  /**
   * Remove entry by key
   *
   * This function will also remove any associated alias from the cache also.
   * @param key - The key of the entry to remove
   */
  remove(t) {
    if (!this._cacheMap.has(t)) {
      Lt(`[Assets] Asset id ${t} was not found in the Cache`);
      return;
    }
    const e = this._cacheMap.get(t);
    e.cacheKeys.forEach((n) => {
      this._cache.delete(n);
    }), e.keys.forEach((n) => {
      this._cacheMap.delete(n);
    });
  }
  /** All loader parsers registered */
  get parsers() {
    return this._parsers;
  }
}
const It = new Vv(), uh = [];
ge.handleByList(X.TextureSource, uh);
function Wf(i = {}) {
  const t = i && i.resource, e = t ? i.resource : i, n = t ? i : { resource: i };
  for (let r = 0; r < uh.length; r++) {
    const s = uh[r];
    if (s.test(e))
      return new s(n);
  }
  throw new Error(`Could not find a source type for resource: ${n.resource}`);
}
function Fv(i = {}, t = !1) {
  const e = i && i.resource, n = e ? i.resource : i, r = e ? i : { resource: i };
  if (!t && It.has(n))
    return It.get(n);
  const s = new nt({ source: Wf(r) });
  return s.on("destroy", () => {
    It.has(n) && It.remove(n);
  }), t || It.set(n, s), s;
}
function Lv(i, t = !1) {
  return typeof i == "string" ? It.get(i) : i instanceof bi ? new nt({ source: i }) : Fv(i, t);
}
nt.from = Lv;
bi.from = Wf;
ge.add(Lf, Nf, Uf, Vo, Rr, zf, uc);
var Li = /* @__PURE__ */ ((i) => (i[i.Low = 0] = "Low", i[i.Normal = 1] = "Normal", i[i.High = 2] = "High", i))(Li || {});
function ni(i) {
  if (typeof i != "string")
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(i)}`);
}
function $r(i) {
  return i.split("?")[0].split("#")[0];
}
function Nv(i) {
  return i.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Uv(i, t, e) {
  return i.replace(new RegExp(Nv(t), "g"), e);
}
function zv(i, t) {
  let e = "", n = 0, r = -1, s = 0, o = -1;
  for (let a = 0; a <= i.length; ++a) {
    if (a < i.length)
      o = i.charCodeAt(a);
    else {
      if (o === 47)
        break;
      o = 47;
    }
    if (o === 47) {
      if (!(r === a - 1 || s === 1)) if (r !== a - 1 && s === 2) {
        if (e.length < 2 || n !== 2 || e.charCodeAt(e.length - 1) !== 46 || e.charCodeAt(e.length - 2) !== 46) {
          if (e.length > 2) {
            const l = e.lastIndexOf("/");
            if (l !== e.length - 1) {
              l === -1 ? (e = "", n = 0) : (e = e.slice(0, l), n = e.length - 1 - e.lastIndexOf("/")), r = a, s = 0;
              continue;
            }
          } else if (e.length === 2 || e.length === 1) {
            e = "", n = 0, r = a, s = 0;
            continue;
          }
        }
      } else
        e.length > 0 ? e += `/${i.slice(r + 1, a)}` : e = i.slice(r + 1, a), n = a - r - 1;
      r = a, s = 0;
    } else o === 46 && s !== -1 ? ++s : s = -1;
  }
  return e;
}
const ae = {
  /**
   * Converts a path to posix format.
   * @param path - The path to convert to posix
   */
  toPosix(i) {
    return Uv(i, "\\", "/");
  },
  /**
   * Checks if the path is a URL e.g. http://, https://
   * @param path - The path to check
   */
  isUrl(i) {
    return /^https?:/.test(this.toPosix(i));
  },
  /**
   * Checks if the path is a data URL
   * @param path - The path to check
   */
  isDataUrl(i) {
    return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(i);
  },
  /**
   * Checks if the path is a blob URL
   * @param path - The path to check
   */
  isBlobUrl(i) {
    return i.startsWith("blob:");
  },
  /**
   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/
   * This will return true for windows file paths
   * @param path - The path to check
   */
  hasProtocol(i) {
    return /^[^/:]+:/.test(this.toPosix(i));
  },
  /**
   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/
   * @param path - The path to get the protocol from
   */
  getProtocol(i) {
    ni(i), i = this.toPosix(i);
    const t = /^file:\/\/\//.exec(i);
    if (t)
      return t[0];
    const e = /^[^/:]+:\/{0,2}/.exec(i);
    return e ? e[0] : "";
  },
  /**
   * Converts URL to an absolute path.
   * When loading from a Web Worker, we must use absolute paths.
   * If the URL is already absolute we return it as is
   * If it's not, we convert it
   * @param url - The URL to test
   * @param customBaseUrl - The base URL to use
   * @param customRootUrl - The root URL to use
   */
  toAbsolute(i, t, e) {
    if (ni(i), this.isDataUrl(i) || this.isBlobUrl(i))
      return i;
    const n = $r(this.toPosix(t ?? Mt.get().getBaseUrl())), r = $r(this.toPosix(e ?? this.rootname(n)));
    return i = this.toPosix(i), i.startsWith("/") ? ae.join(r, i.slice(1)) : this.isAbsolute(i) ? i : this.join(n, i);
  },
  /**
   * Normalizes the given path, resolving '..' and '.' segments
   * @param path - The path to normalize
   */
  normalize(i) {
    if (ni(i), i.length === 0)
      return ".";
    if (this.isDataUrl(i) || this.isBlobUrl(i))
      return i;
    i = this.toPosix(i);
    let t = "";
    const e = i.startsWith("/");
    this.hasProtocol(i) && (t = this.rootname(i), i = i.slice(t.length));
    const n = i.endsWith("/");
    return i = zv(i), i.length > 0 && n && (i += "/"), e ? `/${i}` : t + i;
  },
  /**
   * Determines if path is an absolute path.
   * Absolute paths can be urls, data urls, or paths on disk
   * @param path - The path to test
   */
  isAbsolute(i) {
    return ni(i), i = this.toPosix(i), this.hasProtocol(i) ? !0 : i.startsWith("/");
  },
  /**
   * Joins all given path segments together using the platform-specific separator as a delimiter,
   * then normalizes the resulting path
   * @param segments - The segments of the path to join
   */
  join(...i) {
    if (i.length === 0)
      return ".";
    let t;
    for (let e = 0; e < i.length; ++e) {
      const n = i[e];
      if (ni(n), n.length > 0)
        if (t === void 0)
          t = n;
        else {
          const r = i[e - 1] ?? "";
          this.joinExtensions.includes(this.extname(r).toLowerCase()) ? t += `/../${n}` : t += `/${n}`;
        }
    }
    return t === void 0 ? "." : this.normalize(t);
  },
  /**
   * Returns the directory name of a path
   * @param path - The path to parse
   */
  dirname(i) {
    if (ni(i), i.length === 0)
      return ".";
    i = this.toPosix(i);
    let t = i.charCodeAt(0);
    const e = t === 47;
    let n = -1, r = !0;
    const s = this.getProtocol(i), o = i;
    i = i.slice(s.length);
    for (let a = i.length - 1; a >= 1; --a)
      if (t = i.charCodeAt(a), t === 47) {
        if (!r) {
          n = a;
          break;
        }
      } else
        r = !1;
    return n === -1 ? e ? "/" : this.isUrl(o) ? s + i : s : e && n === 1 ? "//" : s + i.slice(0, n);
  },
  /**
   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
   * @param path - The path to parse
   */
  rootname(i) {
    ni(i), i = this.toPosix(i);
    let t = "";
    if (i.startsWith("/") ? t = "/" : t = this.getProtocol(i), this.isUrl(i)) {
      const e = i.indexOf("/", t.length);
      e !== -1 ? t = i.slice(0, e) : t = i, t.endsWith("/") || (t += "/");
    }
    return t;
  },
  /**
   * Returns the last portion of a path
   * @param path - The path to test
   * @param ext - Optional extension to remove
   */
  basename(i, t) {
    ni(i), t && ni(t), i = $r(this.toPosix(i));
    let e = 0, n = -1, r = !0, s;
    if (t !== void 0 && t.length > 0 && t.length <= i.length) {
      if (t.length === i.length && t === i)
        return "";
      let o = t.length - 1, a = -1;
      for (s = i.length - 1; s >= 0; --s) {
        const l = i.charCodeAt(s);
        if (l === 47) {
          if (!r) {
            e = s + 1;
            break;
          }
        } else
          a === -1 && (r = !1, a = s + 1), o >= 0 && (l === t.charCodeAt(o) ? --o === -1 && (n = s) : (o = -1, n = a));
      }
      return e === n ? n = a : n === -1 && (n = i.length), i.slice(e, n);
    }
    for (s = i.length - 1; s >= 0; --s)
      if (i.charCodeAt(s) === 47) {
        if (!r) {
          e = s + 1;
          break;
        }
      } else n === -1 && (r = !1, n = s + 1);
    return n === -1 ? "" : i.slice(e, n);
  },
  /**
   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
   * the first character of the basename of path, an empty string is returned.
   * @param path - The path to parse
   */
  extname(i) {
    ni(i), i = $r(this.toPosix(i));
    let t = -1, e = 0, n = -1, r = !0, s = 0;
    for (let o = i.length - 1; o >= 0; --o) {
      const a = i.charCodeAt(o);
      if (a === 47) {
        if (!r) {
          e = o + 1;
          break;
        }
        continue;
      }
      n === -1 && (r = !1, n = o + 1), a === 46 ? t === -1 ? t = o : s !== 1 && (s = 1) : t !== -1 && (s = -1);
    }
    return t === -1 || n === -1 || s === 0 || s === 1 && t === n - 1 && t === e + 1 ? "" : i.slice(t, n);
  },
  /**
   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
   * @param path - The path to parse
   */
  parse(i) {
    ni(i);
    const t = { root: "", dir: "", base: "", ext: "", name: "" };
    if (i.length === 0)
      return t;
    i = $r(this.toPosix(i));
    let e = i.charCodeAt(0);
    const n = this.isAbsolute(i);
    let r;
    t.root = this.rootname(i), n || this.hasProtocol(i) ? r = 1 : r = 0;
    let s = -1, o = 0, a = -1, l = !0, h = i.length - 1, c = 0;
    for (; h >= r; --h) {
      if (e = i.charCodeAt(h), e === 47) {
        if (!l) {
          o = h + 1;
          break;
        }
        continue;
      }
      a === -1 && (l = !1, a = h + 1), e === 46 ? s === -1 ? s = h : c !== 1 && (c = 1) : s !== -1 && (c = -1);
    }
    return s === -1 || a === -1 || c === 0 || c === 1 && s === a - 1 && s === o + 1 ? a !== -1 && (o === 0 && n ? t.base = t.name = i.slice(1, a) : t.base = t.name = i.slice(o, a)) : (o === 0 && n ? (t.name = i.slice(1, s), t.base = i.slice(1, a)) : (t.name = i.slice(o, s), t.base = i.slice(o, a)), t.ext = i.slice(s, a)), t.dir = this.dirname(i), t;
  },
  sep: "/",
  delimiter: ":",
  joinExtensions: [".html"]
};
function qf(i, t, e, n, r) {
  const s = t[e];
  for (let o = 0; o < s.length; o++) {
    const a = s[o];
    e < t.length - 1 ? qf(i.replace(n[e], a), t, e + 1, n, r) : r.push(i.replace(n[e], a));
  }
}
function jv(i) {
  const t = /\{(.*?)\}/g, e = i.match(t), n = [];
  if (e) {
    const r = [];
    e.forEach((s) => {
      const o = s.substring(1, s.length - 1).split(",");
      r.push(o);
    }), qf(i, r, 0, e, n);
  } else
    n.push(i);
  return n;
}
const Ko = (i) => !Array.isArray(i);
class kr {
  constructor() {
    this._defaultBundleIdentifierOptions = {
      connector: "-",
      createBundleAssetId: (t, e) => `${t}${this._bundleIdConnector}${e}`,
      extractAssetIdFromBundle: (t, e) => e.replace(`${t}${this._bundleIdConnector}`, "")
    }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {};
  }
  /**
   * Override how the resolver deals with generating bundle ids.
   * must be called before any bundles are added
   * @param bundleIdentifier - the bundle identifier options
   */
  setBundleIdentifier(t) {
    if (this._bundleIdConnector = t.connector ?? this._bundleIdConnector, this._createBundleAssetId = t.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = t.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar")
      throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
  }
  /**
   * Let the resolver know which assets you prefer to use when resolving assets.
   * Multiple prefer user defined rules can be added.
   * @example
   * resolver.prefer({
   *     // first look for something with the correct format, and then then correct resolution
   *     priority: ['format', 'resolution'],
   *     params:{
   *         format:'webp', // prefer webp images
   *         resolution: 2, // prefer a resolution of 2
   *     }
   * })
   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);
   * resolver.resolveUrl('foo') // => 'bar@2x.webp'
   * @param preferOrders - the prefer options
   */
  prefer(...t) {
    t.forEach((e) => {
      this._preferredOrder.push(e), e.priority || (e.priority = Object.keys(e.params));
    }), this._resolverHash = {};
  }
  /**
   * Set the base path to prepend to all urls when resolving
   * @example
   * resolver.basePath = 'https://home.com/';
   * resolver.add('foo', 'bar.ong');
   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'
   * @param basePath - the base path to use
   */
  set basePath(t) {
    this._basePath = t;
  }
  get basePath() {
    return this._basePath;
  }
  /**
   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the
   * default value for browsers is `window.location.origin`
   * @example
   * // Application hosted on https://home.com/some-path/index.html
   * resolver.basePath = 'https://home.com/some-path/';
   * resolver.rootPath = 'https://home.com/';
   * resolver.add('foo', '/bar.png');
   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'
   * @param rootPath - the root path to use
   */
  set rootPath(t) {
    this._rootPath = t;
  }
  get rootPath() {
    return this._rootPath;
  }
  /**
   * All the active URL parsers that help the parser to extract information and create
   * an asset object-based on parsing the URL itself.
   *
   * Can be added using the extensions API
   * @example
   * resolver.add('foo', [
   *     {
   *         resolution: 2,
   *         format: 'png',
   *         src: 'image@2x.png',
   *     },
   *     {
   *         resolution:1,
   *         format:'png',
   *         src: 'image.png',
   *     },
   * ]);
   *
   * // With a url parser the information such as resolution and file format could extracted from the url itself:
   * extensions.add({
   *     extension: ExtensionType.ResolveParser,
   *     test: loadTextures.test, // test if url ends in an image
   *     parse: (value: string) =>
   *     ({
   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),
   *         format: value.split('.').pop(),
   *         src: value,
   *     }),
   * });
   *
   * // Now resolution and format can be extracted from the url
   * resolver.add('foo', [
   *     'image@2x.png',
   *     'image.png',
   * ]);
   */
  get parsers() {
    return this._parsers;
  }
  /** Used for testing, this resets the resolver to its initial state */
  reset() {
    this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null;
  }
  /**
   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.
   * @param searchParams - the default url parameters to append when resolving urls
   */
  setDefaultSearchParams(t) {
    if (typeof t == "string")
      this._defaultSearchParams = t;
    else {
      const e = t;
      this._defaultSearchParams = Object.keys(e).map((n) => `${encodeURIComponent(n)}=${encodeURIComponent(e[n])}`).join("&");
    }
  }
  /**
   * Returns the aliases for a given asset
   * @param asset - the asset to get the aliases for
   */
  getAlias(t) {
    const { alias: e, src: n } = t;
    return si(
      e || n,
      (r) => typeof r == "string" ? r : Array.isArray(r) ? r.map((s) => (s == null ? void 0 : s.src) ?? s) : r != null && r.src ? r.src : r,
      !0
    );
  }
  /**
   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.
   * generally a manifest would be built using a tool.
   * @param manifest - the manifest to add to the resolver
   */
  addManifest(t) {
    this._manifest && Lt("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = t, t.bundles.forEach((e) => {
      this.addBundle(e.name, e.assets);
    });
  }
  /**
   * This adds a bundle of assets in one go so that you can resolve them as a group.
   * For example you could add a bundle for each screen in you pixi app
   * @example
   * resolver.addBundle('animals', [
   *  { alias: 'bunny', src: 'bunny.png' },
   *  { alias: 'chicken', src: 'chicken.png' },
   *  { alias: 'thumper', src: 'thumper.png' },
   * ]);
   * // or
   * resolver.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * const resolvedAssets = await resolver.resolveBundle('animals');
   * @param bundleId - The id of the bundle to add
   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key
   */
  addBundle(t, e) {
    const n = [];
    let r = e;
    Array.isArray(e) || (r = Object.entries(e).map(([s, o]) => typeof o == "string" || Array.isArray(o) ? { alias: s, src: o } : { alias: s, ...o })), r.forEach((s) => {
      const o = s.src, a = s.alias;
      let l;
      if (typeof a == "string") {
        const h = this._createBundleAssetId(t, a);
        n.push(h), l = [a, h];
      } else {
        const h = a.map((c) => this._createBundleAssetId(t, c));
        n.push(...h), l = [...a, ...h];
      }
      this.add({
        ...s,
        alias: l,
        src: o
      });
    }), this._bundles[t] = n;
  }
  /**
   * Tells the resolver what keys are associated with witch asset.
   * The most important thing the resolver does
   * @example
   * // Single key, single asset:
   * resolver.add({alias: 'foo', src: 'bar.png');
   * resolver.resolveUrl('foo') // => 'bar.png'
   *
   * // Multiple keys, single asset:
   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});
   * resolver.resolveUrl('foo') // => 'bar.png'
   * resolver.resolveUrl('boo') // => 'bar.png'
   *
   * // Multiple keys, multiple assets:
   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});
   * resolver.resolveUrl('foo') // => 'bar.png'
   *
   * // Add custom data attached to the resolver
   * Resolver.add({
   *     alias: 'bunnyBooBooSmooth',
   *     src: 'bunny{png,webp}',
   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options
   * });
   *
   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }
   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver
   */
  add(t) {
    const e = [];
    Array.isArray(t) ? e.push(...t) : e.push(t);
    let n;
    n = (r) => {
      this.hasKey(r) && Lt(`[Resolver] already has key: ${r} overwriting`);
    }, si(e).forEach((r) => {
      const { src: s } = r;
      let { data: o, format: a, loadParser: l } = r;
      const h = si(s).map((f) => typeof f == "string" ? jv(f) : Array.isArray(f) ? f : [f]), c = this.getAlias(r);
      Array.isArray(c) ? c.forEach(n) : n(c);
      const p = [];
      h.forEach((f) => {
        f.forEach((d) => {
          let m = {};
          if (typeof d != "object") {
            m.src = d;
            for (let g = 0; g < this._parsers.length; g++) {
              const y = this._parsers[g];
              if (y.test(d)) {
                m = y.parse(d);
                break;
              }
            }
          } else
            o = d.data ?? o, a = d.format ?? a, l = d.loadParser ?? l, m = {
              ...m,
              ...d
            };
          if (!c)
            throw new Error(`[Resolver] alias is undefined for this asset: ${m.src}`);
          m = this._buildResolvedAsset(m, {
            aliases: c,
            data: o,
            format: a,
            loadParser: l
          }), p.push(m);
        });
      }), c.forEach((f) => {
        this._assetMap[f] = p;
      });
    });
  }
  // TODO: this needs an overload like load did in Assets
  /**
   * If the resolver has had a manifest set via setManifest, this will return the assets urls for
   * a given bundleId or bundleIds.
   * @example
   * // Manifest Example
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'sunset.png',
   *                 },
   *                 {
   *                     alias: 'bar',
   *                     src: 'load-bar.{png,webp}',
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'character',
   *                     src: 'robot.png',
   *                 },
   *                 {
   *                     alias: 'enemy',
   *                     src: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * resolver.setManifest(manifest);
   * const resolved = resolver.resolveBundle('load-screen');
   * @param bundleIds - The bundle ids to resolve
   * @returns All the bundles assets or a hash of assets for each bundle specified
   */
  resolveBundle(t) {
    const e = Ko(t);
    t = si(t);
    const n = {};
    return t.forEach((r) => {
      const s = this._bundles[r];
      if (s) {
        const o = this.resolve(s), a = {};
        for (const l in o) {
          const h = o[l];
          a[this._extractAssetIdFromBundle(r, l)] = h;
        }
        n[r] = a;
      }
    }), e ? n[t[0]] : n;
  }
  /**
   * Does exactly what resolve does, but returns just the URL rather than the whole asset object
   * @param key - The key or keys to resolve
   * @returns - The URLs associated with the key(s)
   */
  resolveUrl(t) {
    const e = this.resolve(t);
    if (typeof t != "string") {
      const n = {};
      for (const r in e)
        n[r] = e[r].src;
      return n;
    }
    return e.src;
  }
  resolve(t) {
    const e = Ko(t);
    t = si(t);
    const n = {};
    return t.forEach((r) => {
      if (!this._resolverHash[r])
        if (this._assetMap[r]) {
          let s = this._assetMap[r];
          const o = this._getPreferredOrder(s);
          o == null || o.priority.forEach((a) => {
            o.params[a].forEach((l) => {
              const h = s.filter((c) => c[a] ? c[a] === l : !1);
              h.length && (s = h);
            });
          }), this._resolverHash[r] = s[0];
        } else
          this._resolverHash[r] = this._buildResolvedAsset({
            alias: [r],
            src: r
          }, {});
      n[r] = this._resolverHash[r];
    }), e ? n[t[0]] : n;
  }
  /**
   * Checks if an asset with a given key exists in the resolver
   * @param key - The key of the asset
   */
  hasKey(t) {
    return !!this._assetMap[t];
  }
  /**
   * Checks if a bundle with the given key exists in the resolver
   * @param key - The key of the bundle
   */
  hasBundle(t) {
    return !!this._bundles[t];
  }
  /**
   * Internal function for figuring out what prefer criteria an asset should use.
   * @param assets
   */
  _getPreferredOrder(t) {
    for (let e = 0; e < t.length; e++) {
      const n = t[0], r = this._preferredOrder.find((s) => s.params.format.includes(n.format));
      if (r)
        return r;
    }
    return this._preferredOrder[0];
  }
  /**
   * Appends the default url parameters to the url
   * @param url - The url to append the default parameters to
   * @returns - The url with the default parameters appended
   */
  _appendDefaultSearchParams(t) {
    if (!this._defaultSearchParams)
      return t;
    const e = /\?/.test(t) ? "&" : "?";
    return `${t}${e}${this._defaultSearchParams}`;
  }
  _buildResolvedAsset(t, e) {
    const { aliases: n, data: r, loadParser: s, format: o } = e;
    return (this._basePath || this._rootPath) && (t.src = ae.toAbsolute(t.src, this._basePath, this._rootPath)), t.alias = n ?? t.alias ?? [t.src], t.src = this._appendDefaultSearchParams(t.src), t.data = { ...r || {}, ...t.data }, t.loadParser = s ?? t.loadParser, t.format = o ?? t.format ?? Gv(t.src), t;
  }
}
kr.RETINA_PREFIX = /@([0-9\.]+)x/;
function Gv(i) {
  return i.split(".").pop().split("?").shift().split("#").shift();
}
const dh = (i, t) => {
  const e = t.split("?")[1];
  return e && (i += `?${e}`), i;
}, Yf = class as {
  /**
   * @param texture - Reference to the source BaseTexture object.
   * @param {object} data - Spritesheet image data.
   */
  constructor(t, e) {
    this.linkedSheets = [], this._texture = t instanceof nt ? t : null, this.textureSource = t.source, this.textures = {}, this.animations = {}, this.data = e;
    const n = parseFloat(e.meta.scale);
    n ? (this.resolution = n, t.source.resolution = this.resolution) : this.resolution = t.source._resolution, this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
  }
  /**
   * Parser spritesheet from loaded data. This is done asynchronously
   * to prevent creating too many Texture within a single process.
   */
  parse() {
    return new Promise((t) => {
      this._callback = t, this._batchIndex = 0, this._frameKeys.length <= as.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
    });
  }
  /**
   * Process a batch of frames
   * @param initialFrameIndex - The index of frame to start.
   */
  _processFrames(t) {
    let e = t;
    const n = as.BATCH_SIZE;
    for (; e - t < n && e < this._frameKeys.length; ) {
      const r = this._frameKeys[e], s = this._frames[r], o = s.frame;
      if (o) {
        let a = null, l = null;
        const h = s.trimmed !== !1 && s.sourceSize ? s.sourceSize : s.frame, c = new jt(
          0,
          0,
          Math.floor(h.w) / this.resolution,
          Math.floor(h.h) / this.resolution
        );
        s.rotated ? a = new jt(
          Math.floor(o.x) / this.resolution,
          Math.floor(o.y) / this.resolution,
          Math.floor(o.h) / this.resolution,
          Math.floor(o.w) / this.resolution
        ) : a = new jt(
          Math.floor(o.x) / this.resolution,
          Math.floor(o.y) / this.resolution,
          Math.floor(o.w) / this.resolution,
          Math.floor(o.h) / this.resolution
        ), s.trimmed !== !1 && s.spriteSourceSize && (l = new jt(
          Math.floor(s.spriteSourceSize.x) / this.resolution,
          Math.floor(s.spriteSourceSize.y) / this.resolution,
          Math.floor(o.w) / this.resolution,
          Math.floor(o.h) / this.resolution
        )), this.textures[r] = new nt({
          source: this.textureSource,
          frame: a,
          orig: c,
          trim: l,
          rotate: s.rotated ? 2 : 0,
          defaultAnchor: s.anchor,
          defaultBorders: s.borders,
          label: r.toString()
        });
      }
      e++;
    }
  }
  /** Parse animations config. */
  _processAnimations() {
    const t = this.data.animations || {};
    for (const e in t) {
      this.animations[e] = [];
      for (let n = 0; n < t[e].length; n++) {
        const r = t[e][n];
        this.animations[e].push(this.textures[r]);
      }
    }
  }
  /** The parse has completed. */
  _parseComplete() {
    const t = this._callback;
    this._callback = null, this._batchIndex = 0, t.call(this, this.textures);
  }
  /** Begin the next batch of textures. */
  _nextBatch() {
    this._processFrames(this._batchIndex * as.BATCH_SIZE), this._batchIndex++, setTimeout(() => {
      this._batchIndex * as.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete());
    }, 0);
  }
  /**
   * Destroy Spritesheet and don't use after this.
   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
   */
  destroy(t = !1) {
    var e;
    for (const n in this.textures)
      this.textures[n].destroy();
    this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && ((e = this._texture) == null || e.destroy(), this.textureSource.destroy()), this._texture = null, this.textureSource = null, this.linkedSheets = [];
  }
};
Yf.BATCH_SIZE = 1e3;
let Sd = Yf;
const Hv = [
  "jpg",
  "png",
  "jpeg",
  "avif",
  "webp",
  "basis",
  "etc2",
  "bc7",
  "bc6h",
  "bc5",
  "bc4",
  "bc3",
  "bc2",
  "bc1",
  "eac",
  "astc"
];
function Xf(i, t, e) {
  const n = {};
  if (i.forEach((r) => {
    n[r] = t;
  }), Object.keys(t.textures).forEach((r) => {
    n[r] = t.textures[r];
  }), !e) {
    const r = ae.dirname(i[0]);
    t.linkedSheets.forEach((s, o) => {
      const a = Xf([`${r}/${t.data.meta.related_multi_packs[o]}`], s, !0);
      Object.assign(n, a);
    });
  }
  return n;
}
const Wv = {
  extension: X.Asset,
  /** Handle the caching of the related Spritesheet Textures */
  cache: {
    test: (i) => i instanceof Sd,
    getCacheableAssets: (i, t) => Xf(i, t, !1)
  },
  /** Resolve the resolution of the asset. */
  resolver: {
    extension: {
      type: X.ResolveParser,
      name: "resolveSpritesheet"
    },
    test: (i) => {
      const t = i.split("?")[0].split("."), e = t.pop(), n = t.pop();
      return e === "json" && Hv.includes(n);
    },
    parse: (i) => {
      var t;
      const e = i.split(".");
      return {
        resolution: parseFloat(((t = kr.RETINA_PREFIX.exec(i)) == null ? void 0 : t[1]) ?? "1"),
        format: e[e.length - 2],
        src: i
      };
    }
  },
  /**
   * Loader plugin that parses sprite sheets!
   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.
   * If it is, we load the spritesheets image and parse the data into Spritesheet
   * All textures in the sprite sheet are then added to the cache
   */
  loader: {
    name: "spritesheetLoader",
    extension: {
      type: X.LoadParser,
      priority: Li.Normal,
      name: "spritesheetLoader"
    },
    async testParse(i, t) {
      return ae.extname(t.src).toLowerCase() === ".json" && !!i.frames;
    },
    async parse(i, t, e) {
      var n, r;
      const {
        texture: s,
        // if user need to use preloaded texture
        imageFilename: o
        // if user need to use custom filename (not from jsonFile.meta.image)
      } = (t == null ? void 0 : t.data) ?? {};
      let a = ae.dirname(t.src);
      a && a.lastIndexOf("/") !== a.length - 1 && (a += "/");
      let l;
      if (s instanceof nt)
        l = s;
      else {
        const p = dh(a + (o ?? i.meta.image), t.src);
        l = (await e.load([p]))[p];
      }
      const h = new Sd(
        l.source,
        i
      );
      await h.parse();
      const c = (n = i == null ? void 0 : i.meta) == null ? void 0 : n.related_multi_packs;
      if (Array.isArray(c)) {
        const p = [];
        for (const d of c) {
          if (typeof d != "string")
            continue;
          let m = a + d;
          (r = t.data) != null && r.ignoreMultiPack || (m = dh(m, t.src), p.push(e.load({
            src: m,
            data: {
              ignoreMultiPack: !0
            }
          })));
        }
        const f = await Promise.all(p);
        h.linkedSheets = f, f.forEach((d) => {
          d.linkedSheets = [h].concat(h.linkedSheets.filter((m) => m !== d));
        });
      }
      return h;
    },
    async unload(i, t, e) {
      await e.unload(i.textureSource._sourceOrigin), i.destroy(!1);
    }
  }
};
ge.add(Wv);
const Tl = /* @__PURE__ */ Object.create(null), Td = /* @__PURE__ */ Object.create(null);
function pc(i, t) {
  let e = Td[i];
  return e === void 0 && (Tl[t] === void 0 && (Tl[t] = 1), Td[i] = e = Tl[t]++), e;
}
let ts;
function Kf() {
  return (!ts || ts != null && ts.isContextLost()) && (ts = Mt.get().createCanvas().getContext("webgl", {})), ts;
}
let Ao;
function qv() {
  if (!Ao) {
    Ao = "mediump";
    const i = Kf();
    i && i.getShaderPrecisionFormat && (Ao = i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision ? "highp" : "mediump");
  }
  return Ao;
}
function Yv(i, t, e) {
  return t ? i : e ? (i = i.replace("out vec4 finalColor;", ""), `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${i}
        `) : `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${i}
        `;
}
function Xv(i, t, e) {
  const n = e ? t.maxSupportedFragmentPrecision : t.maxSupportedVertexPrecision;
  if (i.substring(0, 9) !== "precision") {
    let r = e ? t.requestedFragmentPrecision : t.requestedVertexPrecision;
    return r === "highp" && n !== "highp" && (r = "mediump"), `precision ${r} float;
${i}`;
  } else if (n !== "highp" && i.substring(0, 15) === "precision highp")
    return i.replace("precision highp", "precision mediump");
  return i;
}
function Kv(i, t) {
  return t ? `#version 300 es
${i}` : i;
}
const Qv = {}, Jv = {};
function Zv(i, { name: t = "pixi-program" }, e = !0) {
  t = t.replace(/\s+/g, "-"), t += e ? "-fragment" : "-vertex";
  const n = e ? Qv : Jv;
  return n[t] ? (n[t]++, t += `-${n[t]}`) : n[t] = 1, i.indexOf("#define SHADER_NAME") !== -1 ? i : `${`#define SHADER_NAME ${t}`}
${i}`;
}
function $v(i, t) {
  return t ? i.replace("#version 300 es", "") : i;
}
const El = {
  // strips any version headers..
  stripVersion: $v,
  // adds precision string if not already present
  ensurePrecision: Xv,
  // add some defines if WebGL1 to make it more compatible with WebGL2 shaders
  addProgramDefines: Yv,
  // add the program name to the shader
  setProgramName: Zv,
  // add the version string to the shader header
  insertVersion: Kv
}, Cl = /* @__PURE__ */ Object.create(null), Qf = class ph {
  /**
   * Creates a shiny new GlProgram. Used by WebGL renderer.
   * @param options - The options for the program.
   */
  constructor(t) {
    t = { ...ph.defaultOptions, ...t };
    const e = t.fragment.indexOf("#version 300 es") !== -1, n = {
      stripVersion: e,
      ensurePrecision: {
        requestedFragmentPrecision: t.preferredFragmentPrecision,
        requestedVertexPrecision: t.preferredVertexPrecision,
        maxSupportedVertexPrecision: "highp",
        maxSupportedFragmentPrecision: qv()
      },
      setProgramName: {
        name: t.name
      },
      addProgramDefines: e,
      insertVersion: e
    };
    let r = t.fragment, s = t.vertex;
    Object.keys(El).forEach((o) => {
      const a = n[o];
      r = El[o](r, a, !0), s = El[o](s, a, !1);
    }), this.fragment = r, this.vertex = s, this._key = pc(`${this.vertex}:${this.fragment}`, "gl-program");
  }
  /** destroys the program */
  destroy() {
    this.fragment = null, this.vertex = null, this._attributeData = null, this._uniformData = null, this._uniformBlockData = null, this.transformFeedbackVaryings = null;
  }
  /**
   * Helper function that creates a program for a given source.
   * It will check the program cache if the program has already been created.
   * If it has that one will be returned, if not a new one will be created and cached.
   * @param options - The options for the program.
   * @returns A program using the same source
   */
  static from(t) {
    const e = `${t.vertex}:${t.fragment}`;
    return Cl[e] || (Cl[e] = new ph(t)), Cl[e];
  }
};
Qf.defaultOptions = {
  preferredVertexPrecision: "highp",
  preferredFragmentPrecision: "mediump"
};
let Jf = Qf;
const Ed = {
  uint8x2: { size: 2, stride: 2, normalised: !1 },
  uint8x4: { size: 4, stride: 4, normalised: !1 },
  sint8x2: { size: 2, stride: 2, normalised: !1 },
  sint8x4: { size: 4, stride: 4, normalised: !1 },
  unorm8x2: { size: 2, stride: 2, normalised: !0 },
  unorm8x4: { size: 4, stride: 4, normalised: !0 },
  snorm8x2: { size: 2, stride: 2, normalised: !0 },
  snorm8x4: { size: 4, stride: 4, normalised: !0 },
  uint16x2: { size: 2, stride: 4, normalised: !1 },
  uint16x4: { size: 4, stride: 8, normalised: !1 },
  sint16x2: { size: 2, stride: 4, normalised: !1 },
  sint16x4: { size: 4, stride: 8, normalised: !1 },
  unorm16x2: { size: 2, stride: 4, normalised: !0 },
  unorm16x4: { size: 4, stride: 8, normalised: !0 },
  snorm16x2: { size: 2, stride: 4, normalised: !0 },
  snorm16x4: { size: 4, stride: 8, normalised: !0 },
  float16x2: { size: 2, stride: 4, normalised: !1 },
  float16x4: { size: 4, stride: 8, normalised: !1 },
  float32: { size: 1, stride: 4, normalised: !1 },
  float32x2: { size: 2, stride: 8, normalised: !1 },
  float32x3: { size: 3, stride: 12, normalised: !1 },
  float32x4: { size: 4, stride: 16, normalised: !1 },
  uint32: { size: 1, stride: 4, normalised: !1 },
  uint32x2: { size: 2, stride: 8, normalised: !1 },
  uint32x3: { size: 3, stride: 12, normalised: !1 },
  uint32x4: { size: 4, stride: 16, normalised: !1 },
  sint32: { size: 1, stride: 4, normalised: !1 },
  sint32x2: { size: 2, stride: 8, normalised: !1 },
  sint32x3: { size: 3, stride: 12, normalised: !1 },
  sint32x4: { size: 4, stride: 16, normalised: !1 }
};
function t_(i) {
  return Ed[i] ?? Ed.float32;
}
const e_ = {
  f32: "float32",
  "vec2<f32>": "float32x2",
  "vec3<f32>": "float32x3",
  "vec4<f32>": "float32x4",
  vec2f: "float32x2",
  vec3f: "float32x3",
  vec4f: "float32x4",
  i32: "sint32",
  "vec2<i32>": "sint32x2",
  "vec3<i32>": "sint32x3",
  "vec4<i32>": "sint32x4",
  u32: "uint32",
  "vec2<u32>": "uint32x2",
  "vec3<u32>": "uint32x3",
  "vec4<u32>": "uint32x4",
  bool: "uint32",
  "vec2<bool>": "uint32x2",
  "vec3<bool>": "uint32x3",
  "vec4<bool>": "uint32x4"
};
function i_({ source: i, entryPoint: t }) {
  const e = {}, n = i.indexOf(`fn ${t}`);
  if (n !== -1) {
    const r = i.indexOf("->", n);
    if (r !== -1) {
      const s = i.substring(n, r), o = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
      let a;
      for (; (a = o.exec(s)) !== null; ) {
        const l = e_[a[3]] ?? "float32";
        e[a[2]] = {
          location: parseInt(a[1], 10),
          format: l,
          stride: t_(l).stride,
          offset: 0,
          instance: !1,
          start: 0
        };
      }
    }
  }
  return e;
}
function Pl(i) {
  var t, e;
  const n = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g, r = /@group\((\d+)\)/, s = /@binding\((\d+)\)/, o = /var(<[^>]+>)? (\w+)/, a = /:\s*(\w+)/, l = /struct\s+(\w+)\s*{([^}]+)}/g, h = /(\w+)\s*:\s*([\w\<\>]+)/g, c = /struct\s+(\w+)/, p = (t = i.match(n)) == null ? void 0 : t.map((d) => ({
    group: parseInt(d.match(r)[1], 10),
    binding: parseInt(d.match(s)[1], 10),
    name: d.match(o)[2],
    isUniform: d.match(o)[1] === "<uniform>",
    type: d.match(a)[1]
  }));
  if (!p)
    return {
      groups: [],
      structs: []
    };
  const f = ((e = i.match(l)) == null ? void 0 : e.map((d) => {
    const m = d.match(c)[1], g = d.match(h).reduce((y, b) => {
      const [S, C] = b.split(":");
      return y[S.trim()] = C.trim(), y;
    }, {});
    return g ? { name: m, members: g } : null;
  }).filter(({ name: d }) => p.some((m) => m.type === d))) ?? [];
  return {
    groups: p,
    structs: f
  };
}
var ls = /* @__PURE__ */ ((i) => (i[i.VERTEX = 1] = "VERTEX", i[i.FRAGMENT = 2] = "FRAGMENT", i[i.COMPUTE = 4] = "COMPUTE", i))(ls || {});
function n_({ groups: i }) {
  const t = [];
  for (let e = 0; e < i.length; e++) {
    const n = i[e];
    t[n.group] || (t[n.group] = []), n.isUniform ? t[n.group].push({
      binding: n.binding,
      visibility: ls.VERTEX | ls.FRAGMENT,
      buffer: {
        type: "uniform"
      }
    }) : n.type === "sampler" ? t[n.group].push({
      binding: n.binding,
      visibility: ls.FRAGMENT,
      sampler: {
        type: "filtering"
      }
    }) : n.type === "texture_2d" && t[n.group].push({
      binding: n.binding,
      visibility: ls.FRAGMENT,
      texture: {
        sampleType: "float",
        viewDimension: "2d",
        multisampled: !1
      }
    });
  }
  return t;
}
function r_({ groups: i }) {
  const t = [];
  for (let e = 0; e < i.length; e++) {
    const n = i[e];
    t[n.group] || (t[n.group] = {}), t[n.group][n.name] = n.binding;
  }
  return t;
}
function s_(i, t) {
  const e = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set(), r = [...i.structs, ...t.structs].filter((o) => e.has(o.name) ? !1 : (e.add(o.name), !0)), s = [...i.groups, ...t.groups].filter((o) => {
    const a = `${o.name}-${o.binding}`;
    return n.has(a) ? !1 : (n.add(a), !0);
  });
  return { structs: r, groups: s };
}
const Il = /* @__PURE__ */ Object.create(null);
class Pa {
  /**
   * Create a new GpuProgram
   * @param options - The options for the gpu program
   */
  constructor(t) {
    var e, n;
    this._layoutKey = 0, this._attributeLocationsKey = 0;
    const { fragment: r, vertex: s, layout: o, gpuLayout: a, name: l } = t;
    if (this.name = l, this.fragment = r, this.vertex = s, r.source === s.source) {
      const h = Pl(r.source);
      this.structsAndGroups = h;
    } else {
      const h = Pl(s.source), c = Pl(r.source);
      this.structsAndGroups = s_(h, c);
    }
    this.layout = o ?? r_(this.structsAndGroups), this.gpuLayout = a ?? n_(this.structsAndGroups), this.autoAssignGlobalUniforms = ((e = this.layout[0]) == null ? void 0 : e.globalUniforms) !== void 0, this.autoAssignLocalUniforms = ((n = this.layout[1]) == null ? void 0 : n.localUniforms) !== void 0, this._generateProgramKey();
  }
  // TODO maker this pure
  _generateProgramKey() {
    const { vertex: t, fragment: e } = this, n = t.source + e.source + t.entryPoint + e.entryPoint;
    this._layoutKey = pc(n, "program");
  }
  get attributeData() {
    return this._attributeData ?? (this._attributeData = i_(this.vertex)), this._attributeData;
  }
  /** destroys the program */
  destroy() {
    this.gpuLayout = null, this.layout = null, this.structsAndGroups = null, this.fragment = null, this.vertex = null;
  }
  /**
   * Helper function that creates a program for a given source.
   * It will check the program cache if the program has already been created.
   * If it has that one will be returned, if not a new one will be created and cached.
   * @param options - The options for the program.
   * @returns A program using the same source
   */
  static from(t) {
    const e = `${t.vertex.source}:${t.fragment.source}:${t.fragment.entryPoint}:${t.vertex.entryPoint}`;
    return Il[e] || (Il[e] = new Pa(t)), Il[e];
  }
}
const Zf = [
  "f32",
  "i32",
  "vec2<f32>",
  "vec3<f32>",
  "vec4<f32>",
  "mat2x2<f32>",
  "mat3x3<f32>",
  "mat4x4<f32>",
  "mat3x2<f32>",
  "mat4x2<f32>",
  "mat2x3<f32>",
  "mat4x3<f32>",
  "mat2x4<f32>",
  "mat3x4<f32>"
], o_ = Zf.reduce((i, t) => (i[t] = !0, i), {});
function a_(i, t) {
  switch (i) {
    case "f32":
      return 0;
    case "vec2<f32>":
      return new Float32Array(2 * t);
    case "vec3<f32>":
      return new Float32Array(3 * t);
    case "vec4<f32>":
      return new Float32Array(4 * t);
    case "mat2x2<f32>":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3x3<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4x4<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
const $f = class tm {
  /**
   * Create a new Uniform group
   * @param uniformStructures - The structures of the uniform group
   * @param options - The optional parameters of this uniform group
   */
  constructor(t, e) {
    this._touched = 0, this.uid = qt("uniform"), this._resourceType = "uniformGroup", this._resourceId = qt("resource"), this.isUniformGroup = !0, this._dirtyId = 0, this.destroyed = !1, e = { ...tm.defaultOptions, ...e }, this.uniformStructures = t;
    const n = {};
    for (const r in t) {
      const s = t[r];
      if (s.name = r, s.size = s.size ?? 1, !o_[s.type])
        throw new Error(`Uniform type ${s.type} is not supported. Supported uniform types are: ${Zf.join(", ")}`);
      s.value ?? (s.value = a_(s.type, s.size)), n[r] = s.value;
    }
    this.uniforms = n, this._dirtyId = 1, this.ubo = e.ubo, this.isStatic = e.isStatic, this._signature = pc(Object.keys(n).map(
      (r) => `${r}-${t[r].type}`
    ).join("-"), "uniform-group");
  }
  /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */
  update() {
    this._dirtyId++;
  }
};
$f.defaultOptions = {
  /** if true the UniformGroup is handled as an Uniform buffer object. */
  ubo: !1,
  /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */
  isStatic: !1
};
let em = $f;
class Fo {
  /**
   * Create a new instance eof the Bind Group.
   * @param resources - The resources that are bound together for use by a shader.
   */
  constructor(t) {
    this.resources = /* @__PURE__ */ Object.create(null), this._dirty = !0;
    let e = 0;
    for (const n in t) {
      const r = t[n];
      this.setResource(r, e++);
    }
    this._updateKey();
  }
  /**
   * Updates the key if its flagged as dirty. This is used internally to
   * match this bind group to a WebGPU BindGroup.
   * @internal
   * @ignore
   */
  _updateKey() {
    if (!this._dirty)
      return;
    this._dirty = !1;
    const t = [];
    let e = 0;
    for (const n in this.resources)
      t[e++] = this.resources[n]._resourceId;
    this._key = t.join("|");
  }
  /**
   * Set a resource at a given index. this function will
   * ensure that listeners will be removed from the current resource
   * and added to the new resource.
   * @param resource - The resource to set.
   * @param index - The index to set the resource at.
   */
  setResource(t, e) {
    var n, r;
    const s = this.resources[e];
    t !== s && (s && ((n = t.off) == null || n.call(t, "change", this.onResourceChange, this)), (r = t.on) == null || r.call(t, "change", this.onResourceChange, this), this.resources[e] = t, this._dirty = !0);
  }
  /**
   * Returns the resource at the current specified index.
   * @param index - The index of the resource to get.
   * @returns - The resource at the specified index.
   */
  getResource(t) {
    return this.resources[t];
  }
  /**
   * Used internally to 'touch' each resource, to ensure that the GC
   * knows that all resources in this bind group are still being used.
   * @param tick - The current tick.
   * @internal
   * @ignore
   */
  _touch(t) {
    const e = this.resources;
    for (const n in e)
      e[n]._touched = t;
  }
  /** Destroys this bind group and removes all listeners. */
  destroy() {
    var t;
    const e = this.resources;
    for (const n in e) {
      const r = e[n];
      (t = r.off) == null || t.call(r, "change", this.onResourceChange, this);
    }
    this.resources = null;
  }
  onResourceChange(t) {
    if (this._dirty = !0, t.destroyed) {
      const e = this.resources;
      for (const n in e)
        e[n] === t && (e[n] = null);
    } else
      this._updateKey();
  }
}
var fh = /* @__PURE__ */ ((i) => (i[i.WEBGL = 1] = "WEBGL", i[i.WEBGPU = 2] = "WEBGPU", i[i.BOTH = 3] = "BOTH", i))(fh || {});
class fc extends xe {
  constructor(t) {
    super(), this._uniformBindMap = /* @__PURE__ */ Object.create(null), this._ownedBindGroups = [];
    let {
      gpuProgram: e,
      glProgram: n,
      groups: r,
      resources: s,
      compatibleRenderers: o,
      groupMap: a
    } = t;
    this.gpuProgram = e, this.glProgram = n, o === void 0 && (o = 0, e && (o |= fh.WEBGPU), n && (o |= fh.WEBGL)), this.compatibleRenderers = o;
    const l = {};
    if (!s && !r && (s = {}), s && r)
      throw new Error("[Shader] Cannot have both resources and groups");
    if (!e && r && !a)
      throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
    if (!e && r && a)
      for (const h in a)
        for (const c in a[h]) {
          const p = a[h][c];
          l[p] = {
            group: h,
            binding: c,
            name: p
          };
        }
    else if (e && r && !a) {
      const h = e.structsAndGroups.groups;
      a = {}, h.forEach((c) => {
        a[c.group] = a[c.group] || {}, a[c.group][c.binding] = c.name, l[c.name] = c;
      });
    } else if (s) {
      r = {}, a = {}, e && e.structsAndGroups.groups.forEach((c) => {
        a[c.group] = a[c.group] || {}, a[c.group][c.binding] = c.name, l[c.name] = c;
      });
      let h = 0;
      for (const c in s)
        l[c] || (r[99] || (r[99] = new Fo(), this._ownedBindGroups.push(r[99])), l[c] = { group: 99, binding: h, name: c }, a[99] = a[99] || {}, a[99][h] = c, h++);
      for (const c in s) {
        const p = c;
        let f = s[c];
        !f.source && !f._resourceType && (f = new em(f));
        const d = l[p];
        d && (r[d.group] || (r[d.group] = new Fo(), this._ownedBindGroups.push(r[d.group])), r[d.group].setResource(f, d.binding));
      }
    }
    this.groups = r, this._uniformBindMap = a, this.resources = this._buildResourceAccessor(r, l);
  }
  /**
   * Sometimes a resource group will be provided later (for example global uniforms)
   * In such cases, this method can be used to let the shader know about the group.
   * @param name - the name of the resource group
   * @param groupIndex - the index of the group (should match the webGPU shader group location)
   * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)
   */
  addResource(t, e, n) {
    var r, s;
    (r = this._uniformBindMap)[e] || (r[e] = {}), (s = this._uniformBindMap[e])[n] || (s[n] = t), this.groups[e] || (this.groups[e] = new Fo(), this._ownedBindGroups.push(this.groups[e]));
  }
  _buildResourceAccessor(t, e) {
    const n = {};
    for (const r in e) {
      const s = e[r];
      Object.defineProperty(n, s.name, {
        get() {
          return t[s.group].getResource(s.binding);
        },
        set(o) {
          t[s.group].setResource(o, s.binding);
        }
      });
    }
    return n;
  }
  /**
   * Use to destroy the shader when its not longer needed.
   * It will destroy the resources and remove listeners.
   * @param destroyPrograms - if the programs should be destroyed as well.
   * Make sure its not being used by other shaders!
   */
  destroy(t = !1) {
    var e, n;
    this.emit("destroy", this), t && ((e = this.gpuProgram) == null || e.destroy(), (n = this.glProgram) == null || n.destroy()), this.gpuProgram = null, this.glProgram = null, this.removeAllListeners(), this._uniformBindMap = null, this._ownedBindGroups.forEach((r) => {
      r.destroy();
    }), this._ownedBindGroups = null, this.resources = null, this.groups = null;
  }
  static from(t) {
    const { gpu: e, gl: n, ...r } = t;
    let s, o;
    return e && (s = Pa.from(e)), n && (o = Jf.from(n)), new fc({
      gpuProgram: s,
      glProgram: o,
      ...r
    });
  }
}
const mh = [];
ge.handleByNamedList(X.Environment, mh);
async function l_(i) {
  if (!i)
    for (let t = 0; t < mh.length; t++) {
      const e = mh[t];
      if (e.value.test()) {
        await e.value.load();
        return;
      }
    }
}
let es;
function h_() {
  if (typeof es == "boolean")
    return es;
  try {
    es = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({ a: "b" }, "a", "b") === !0;
  } catch {
    es = !1;
  }
  return es;
}
var mc = { exports: {} };
mc.exports = Ia;
mc.exports.default = Ia;
function Ia(i, t, e) {
  e = e || 2;
  var n = t && t.length, r = n ? t[0] * e : i.length, s = im(i, 0, r, e, !0), o = [];
  if (!s || s.next === s.prev) return o;
  var a, l, h, c, p, f, d;
  if (n && (s = f_(i, t, s, e)), i.length > 80 * e) {
    a = h = i[0], l = c = i[1];
    for (var m = e; m < r; m += e)
      p = i[m], f = i[m + 1], p < a && (a = p), f < l && (l = f), p > h && (h = p), f > c && (c = f);
    d = Math.max(h - a, c - l), d = d !== 0 ? 32767 / d : 0;
  }
  return Cs(s, o, e, a, l, d, 0), o;
}
function im(i, t, e, n, r) {
  var s, o;
  if (r === vh(i, t, e, n) > 0)
    for (s = t; s < e; s += n) o = Cd(s, i[s], i[s + 1], o);
  else
    for (s = e - n; s >= t; s -= n) o = Cd(s, i[s], i[s + 1], o);
  return o && Ra(o, o.next) && (Is(o), o = o.next), o;
}
function On(i, t) {
  if (!i) return i;
  t || (t = i);
  var e = i, n;
  do
    if (n = !1, !e.steiner && (Ra(e, e.next) || Rt(e.prev, e, e.next) === 0)) {
      if (Is(e), e = t = e.prev, e === e.next) break;
      n = !0;
    } else
      e = e.next;
  while (n || e !== t);
  return t;
}
function Cs(i, t, e, n, r, s, o) {
  if (i) {
    !o && s && __(i, n, r, s);
    for (var a = i, l, h; i.prev !== i.next; ) {
      if (l = i.prev, h = i.next, s ? u_(i, n, r, s) : c_(i)) {
        t.push(l.i / e | 0), t.push(i.i / e | 0), t.push(h.i / e | 0), Is(i), i = h.next, a = h.next;
        continue;
      }
      if (i = h, i === a) {
        o ? o === 1 ? (i = d_(On(i), t, e), Cs(i, t, e, n, r, s, 2)) : o === 2 && p_(i, t, e, n, r, s) : Cs(On(i), t, e, n, r, s, 1);
        break;
      }
    }
  }
}
function c_(i) {
  var t = i.prev, e = i, n = i.next;
  if (Rt(t, e, n) >= 0) return !1;
  for (var r = t.x, s = e.x, o = n.x, a = t.y, l = e.y, h = n.y, c = r < s ? r < o ? r : o : s < o ? s : o, p = a < l ? a < h ? a : h : l < h ? l : h, f = r > s ? r > o ? r : o : s > o ? s : o, d = a > l ? a > h ? a : h : l > h ? l : h, m = n.next; m !== t; ) {
    if (m.x >= c && m.x <= f && m.y >= p && m.y <= d && rr(r, a, s, l, o, h, m.x, m.y) && Rt(m.prev, m, m.next) >= 0) return !1;
    m = m.next;
  }
  return !0;
}
function u_(i, t, e, n) {
  var r = i.prev, s = i, o = i.next;
  if (Rt(r, s, o) >= 0) return !1;
  for (var a = r.x, l = s.x, h = o.x, c = r.y, p = s.y, f = o.y, d = a < l ? a < h ? a : h : l < h ? l : h, m = c < p ? c < f ? c : f : p < f ? p : f, g = a > l ? a > h ? a : h : l > h ? l : h, y = c > p ? c > f ? c : f : p > f ? p : f, b = gh(d, m, t, e, n), S = gh(g, y, t, e, n), C = i.prevZ, I = i.nextZ; C && C.z >= b && I && I.z <= S; ) {
    if (C.x >= d && C.x <= g && C.y >= m && C.y <= y && C !== r && C !== o && rr(a, c, l, p, h, f, C.x, C.y) && Rt(C.prev, C, C.next) >= 0 || (C = C.prevZ, I.x >= d && I.x <= g && I.y >= m && I.y <= y && I !== r && I !== o && rr(a, c, l, p, h, f, I.x, I.y) && Rt(I.prev, I, I.next) >= 0)) return !1;
    I = I.nextZ;
  }
  for (; C && C.z >= b; ) {
    if (C.x >= d && C.x <= g && C.y >= m && C.y <= y && C !== r && C !== o && rr(a, c, l, p, h, f, C.x, C.y) && Rt(C.prev, C, C.next) >= 0) return !1;
    C = C.prevZ;
  }
  for (; I && I.z <= S; ) {
    if (I.x >= d && I.x <= g && I.y >= m && I.y <= y && I !== r && I !== o && rr(a, c, l, p, h, f, I.x, I.y) && Rt(I.prev, I, I.next) >= 0) return !1;
    I = I.nextZ;
  }
  return !0;
}
function d_(i, t, e) {
  var n = i;
  do {
    var r = n.prev, s = n.next.next;
    !Ra(r, s) && nm(r, n, n.next, s) && Ps(r, s) && Ps(s, r) && (t.push(r.i / e | 0), t.push(n.i / e | 0), t.push(s.i / e | 0), Is(n), Is(n.next), n = i = s), n = n.next;
  } while (n !== i);
  return On(n);
}
function p_(i, t, e, n, r, s) {
  var o = i;
  do {
    for (var a = o.next.next; a !== o.prev; ) {
      if (o.i !== a.i && w_(o, a)) {
        var l = rm(o, a);
        o = On(o, o.next), l = On(l, l.next), Cs(o, t, e, n, r, s, 0), Cs(l, t, e, n, r, s, 0);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== i);
}
function f_(i, t, e, n) {
  var r = [], s, o, a, l, h;
  for (s = 0, o = t.length; s < o; s++)
    a = t[s] * n, l = s < o - 1 ? t[s + 1] * n : i.length, h = im(i, a, l, n, !1), h === h.next && (h.steiner = !0), r.push(b_(h));
  for (r.sort(m_), s = 0; s < r.length; s++)
    e = g_(r[s], e);
  return e;
}
function m_(i, t) {
  return i.x - t.x;
}
function g_(i, t) {
  var e = y_(i, t);
  if (!e)
    return t;
  var n = rm(e, i);
  return On(n, n.next), On(e, e.next);
}
function y_(i, t) {
  var e = t, n = i.x, r = i.y, s = -1 / 0, o;
  do {
    if (r <= e.y && r >= e.next.y && e.next.y !== e.y) {
      var a = e.x + (r - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
      if (a <= n && a > s && (s = a, o = e.x < e.next.x ? e : e.next, a === n))
        return o;
    }
    e = e.next;
  } while (e !== t);
  if (!o) return null;
  var l = o, h = o.x, c = o.y, p = 1 / 0, f;
  e = o;
  do
    n >= e.x && e.x >= h && n !== e.x && rr(r < c ? n : s, r, h, c, r < c ? s : n, r, e.x, e.y) && (f = Math.abs(r - e.y) / (n - e.x), Ps(e, i) && (f < p || f === p && (e.x > o.x || e.x === o.x && v_(o, e))) && (o = e, p = f)), e = e.next;
  while (e !== l);
  return o;
}
function v_(i, t) {
  return Rt(i.prev, i, t.prev) < 0 && Rt(t.next, i, i.next) < 0;
}
function __(i, t, e, n) {
  var r = i;
  do
    r.z === 0 && (r.z = gh(r.x, r.y, t, e, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  while (r !== i);
  r.prevZ.nextZ = null, r.prevZ = null, x_(r);
}
function x_(i) {
  var t, e, n, r, s, o, a, l, h = 1;
  do {
    for (e = i, i = null, s = null, o = 0; e; ) {
      for (o++, n = e, a = 0, t = 0; t < h && (a++, n = n.nextZ, !!n); t++)
        ;
      for (l = h; a > 0 || l > 0 && n; )
        a !== 0 && (l === 0 || !n || e.z <= n.z) ? (r = e, e = e.nextZ, a--) : (r = n, n = n.nextZ, l--), s ? s.nextZ = r : i = r, r.prevZ = s, s = r;
      e = n;
    }
    s.nextZ = null, h *= 2;
  } while (o > 1);
  return i;
}
function gh(i, t, e, n, r) {
  return i = (i - e) * r | 0, t = (t - n) * r | 0, i = (i | i << 8) & 16711935, i = (i | i << 4) & 252645135, i = (i | i << 2) & 858993459, i = (i | i << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, i | t << 1;
}
function b_(i) {
  var t = i, e = i;
  do
    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
  while (t !== i);
  return e;
}
function rr(i, t, e, n, r, s, o, a) {
  return (r - o) * (t - a) >= (i - o) * (s - a) && (i - o) * (n - a) >= (e - o) * (t - a) && (e - o) * (s - a) >= (r - o) * (n - a);
}
function w_(i, t) {
  return i.next.i !== t.i && i.prev.i !== t.i && !A_(i, t) && // dones't intersect other edges
  (Ps(i, t) && Ps(t, i) && S_(i, t) && // locally visible
  (Rt(i.prev, i, t.prev) || Rt(i, t.prev, t)) || // does not create opposite-facing sectors
  Ra(i, t) && Rt(i.prev, i, i.next) > 0 && Rt(t.prev, t, t.next) > 0);
}
function Rt(i, t, e) {
  return (t.y - i.y) * (e.x - t.x) - (t.x - i.x) * (e.y - t.y);
}
function Ra(i, t) {
  return i.x === t.x && i.y === t.y;
}
function nm(i, t, e, n) {
  var r = To(Rt(i, t, e)), s = To(Rt(i, t, n)), o = To(Rt(e, n, i)), a = To(Rt(e, n, t));
  return !!(r !== s && o !== a || r === 0 && So(i, e, t) || s === 0 && So(i, n, t) || o === 0 && So(e, i, n) || a === 0 && So(e, t, n));
}
function So(i, t, e) {
  return t.x <= Math.max(i.x, e.x) && t.x >= Math.min(i.x, e.x) && t.y <= Math.max(i.y, e.y) && t.y >= Math.min(i.y, e.y);
}
function To(i) {
  return i > 0 ? 1 : i < 0 ? -1 : 0;
}
function A_(i, t) {
  var e = i;
  do {
    if (e.i !== i.i && e.next.i !== i.i && e.i !== t.i && e.next.i !== t.i && nm(e, e.next, i, t)) return !0;
    e = e.next;
  } while (e !== i);
  return !1;
}
function Ps(i, t) {
  return Rt(i.prev, i, i.next) < 0 ? Rt(i, t, i.next) >= 0 && Rt(i, i.prev, t) >= 0 : Rt(i, t, i.prev) < 0 || Rt(i, i.next, t) < 0;
}
function S_(i, t) {
  var e = i, n = !1, r = (i.x + t.x) / 2, s = (i.y + t.y) / 2;
  do
    e.y > s != e.next.y > s && e.next.y !== e.y && r < (e.next.x - e.x) * (s - e.y) / (e.next.y - e.y) + e.x && (n = !n), e = e.next;
  while (e !== i);
  return n;
}
function rm(i, t) {
  var e = new yh(i.i, i.x, i.y), n = new yh(t.i, t.x, t.y), r = i.next, s = t.prev;
  return i.next = t, t.prev = i, e.next = r, r.prev = e, n.next = e, e.prev = n, s.next = n, n.prev = s, n;
}
function Cd(i, t, e, n) {
  var r = new yh(i, t, e);
  return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r;
}
function Is(i) {
  i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
}
function yh(i, t, e) {
  this.i = i, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
Ia.deviation = function(i, t, e, n) {
  var r = t && t.length, s = r ? t[0] * e : i.length, o = Math.abs(vh(i, 0, s, e));
  if (r)
    for (var a = 0, l = t.length; a < l; a++) {
      var h = t[a] * e, c = a < l - 1 ? t[a + 1] * e : i.length;
      o -= Math.abs(vh(i, h, c, e));
    }
  var p = 0;
  for (a = 0; a < n.length; a += 3) {
    var f = n[a] * e, d = n[a + 1] * e, m = n[a + 2] * e;
    p += Math.abs(
      (i[f] - i[m]) * (i[d + 1] - i[f + 1]) - (i[f] - i[d]) * (i[m + 1] - i[f + 1])
    );
  }
  return o === 0 && p === 0 ? 0 : Math.abs((p - o) / o);
};
function vh(i, t, e, n) {
  for (var r = 0, s = t, o = e - n; s < e; s += n)
    r += (i[o] - i[s]) * (i[s + 1] + i[o + 1]), o = s;
  return r;
}
Ia.flatten = function(i) {
  for (var t = i[0][0].length, e = { vertices: [], holes: [], dimensions: t }, n = 0, r = 0; r < i.length; r++) {
    for (var s = 0; s < i[r].length; s++)
      for (var o = 0; o < t; o++) e.vertices.push(i[r][s][o]);
    r > 0 && (n += i[r - 1].length, e.holes.push(n));
  }
  return e;
};
var T_ = mc.exports;
const E_ = /* @__PURE__ */ cc(T_);
var sm = /* @__PURE__ */ ((i) => (i[i.NONE = 0] = "NONE", i[i.COLOR = 16384] = "COLOR", i[i.STENCIL = 1024] = "STENCIL", i[i.DEPTH = 256] = "DEPTH", i[i.COLOR_DEPTH = 16640] = "COLOR_DEPTH", i[i.COLOR_STENCIL = 17408] = "COLOR_STENCIL", i[i.DEPTH_STENCIL = 1280] = "DEPTH_STENCIL", i[i.ALL = 17664] = "ALL", i))(sm || {});
class C_ {
  /**
   * @param name - The function name that will be executed on the listeners added to this Runner.
   */
  constructor(t) {
    this.items = [], this._name = t;
  }
  /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */
  /**
   * Dispatch/Broadcast Runner to all listeners added to the queue.
   * @param {...any} params - (optional) parameters to pass to each listener
   */
  /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */
  emit(t, e, n, r, s, o, a, l) {
    const { name: h, items: c } = this;
    for (let p = 0, f = c.length; p < f; p++)
      c[p][h](t, e, n, r, s, o, a, l);
    return this;
  }
  /**
   * Add a listener to the Runner
   *
   * Runners do not need to have scope or functions passed to them.
   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
   * as the name provided to the Runner when it was created.
   *
   * Eg A listener passed to this Runner will require a 'complete' function.
   *
   * ```
   * import { Runner } from 'pixi.js';
   *
   * const complete = new Runner('complete');
   * ```
   *
   * The scope used will be the object itself.
   * @param {any} item - The object that will be listening.
   */
  add(t) {
    return t[this._name] && (this.remove(t), this.items.push(t)), this;
  }
  /**
   * Remove a single listener from the dispatch queue.
   * @param {any} item - The listener that you would like to remove.
   */
  remove(t) {
    const e = this.items.indexOf(t);
    return e !== -1 && this.items.splice(e, 1), this;
  }
  /**
   * Check to see if the listener is already in the Runner
   * @param {any} item - The listener that you would like to check.
   */
  contains(t) {
    return this.items.indexOf(t) !== -1;
  }
  /** Remove all listeners from the Runner */
  removeAll() {
    return this.items.length = 0, this;
  }
  /** Remove all references, don't use after this. */
  destroy() {
    this.removeAll(), this.items = null, this._name = null;
  }
  /**
   * `true` if there are no this Runner contains no listeners
   * @readonly
   */
  get empty() {
    return this.items.length === 0;
  }
  /**
   * The name of the runner.
   * @readonly
   */
  get name() {
    return this._name;
  }
}
const P_ = [
  "init",
  "destroy",
  "contextChange",
  "resolutionChange",
  "reset",
  "renderEnd",
  "renderStart",
  "render",
  "update",
  "postrender",
  "prerender"
], om = class am extends xe {
  /**
   * Set up a system with a collection of SystemClasses and runners.
   * Systems are attached dynamically to this class when added.
   * @param config - the config for the system manager
   */
  constructor(t) {
    super(), this.runners = /* @__PURE__ */ Object.create(null), this.renderPipes = /* @__PURE__ */ Object.create(null), this._initOptions = {}, this._systemsHash = /* @__PURE__ */ Object.create(null), this.type = t.type, this.name = t.name, this.config = t;
    const e = [...P_, ...this.config.runners ?? []];
    this._addRunners(...e), this._unsafeEvalCheck();
  }
  /**
   * Initialize the renderer.
   * @param options - The options to use to create the renderer.
   */
  async init(t = {}) {
    const e = t.skipExtensionImports === !0 ? !0 : t.manageImports === !1;
    await l_(e), this._addSystems(this.config.systems), this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
    for (const n in this._systemsHash)
      t = { ...this._systemsHash[n].constructor.defaultOptions, ...t };
    t = { ...am.defaultOptions, ...t }, this._roundPixels = t.roundPixels ? 1 : 0;
    for (let n = 0; n < this.runners.init.items.length; n++)
      await this.runners.init.items[n].init(t);
    this._initOptions = t;
  }
  render(t, e) {
    let n = t;
    if (n instanceof Te && (n = { container: n }, e && (ut(dt, "passing a second argument is deprecated, please use render options instead"), n.target = e.renderTexture)), n.target || (n.target = this.view.renderTarget), n.target === this.view.renderTarget && (this._lastObjectRendered = n.container, n.clearColor = this.background.colorRgba), n.clearColor) {
      const r = Array.isArray(n.clearColor) && n.clearColor.length === 4;
      n.clearColor = r ? n.clearColor : Gt.shared.setValue(n.clearColor).toArray();
    }
    n.transform || (n.container.updateLocalTransform(), n.transform = n.container.localTransform), this.runners.prerender.emit(n), this.runners.renderStart.emit(n), this.runners.render.emit(n), this.runners.renderEnd.emit(n), this.runners.postrender.emit(n);
  }
  /**
   * Resizes the WebGL view to the specified width and height.
   * @param desiredScreenWidth - The desired width of the screen.
   * @param desiredScreenHeight - The desired height of the screen.
   * @param resolution - The resolution / device pixel ratio of the renderer.
   */
  resize(t, e, n) {
    const r = this.view.resolution;
    this.view.resize(t, e, n), this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution), n !== void 0 && n !== r && this.runners.resolutionChange.emit(n);
  }
  clear(t = {}) {
    const e = this;
    t.target || (t.target = e.renderTarget.renderTarget), t.clearColor || (t.clearColor = this.background.colorRgba), t.clear ?? (t.clear = sm.ALL);
    const { clear: n, clearColor: r, target: s } = t;
    Gt.shared.setValue(r ?? this.background.colorRgba), e.renderTarget.clear(s, n, Gt.shared.toArray());
  }
  /** The resolution / device pixel ratio of the renderer. */
  get resolution() {
    return this.view.resolution;
  }
  set resolution(t) {
    this.view.resolution = t, this.runners.resolutionChange.emit(t);
  }
  /**
   * Same as view.width, actual number of pixels in the canvas by horizontal.
   * @member {number}
   * @readonly
   * @default 800
   */
  get width() {
    return this.view.texture.frame.width;
  }
  /**
   * Same as view.height, actual number of pixels in the canvas by vertical.
   * @default 600
   */
  get height() {
    return this.view.texture.frame.height;
  }
  // NOTE: this was `view` in v7
  /**
   * The canvas element that everything is drawn to.
   * @type {environment.ICanvas}
   */
  get canvas() {
    return this.view.canvas;
  }
  /**
   * the last object rendered by the renderer. Useful for other plugins like interaction managers
   * @readonly
   */
  get lastObjectRendered() {
    return this._lastObjectRendered;
  }
  /**
   * Flag if we are rendering to the screen vs renderTexture
   * @readonly
   * @default true
   */
  get renderingToScreen() {
    return this.renderTarget.renderingToScreen;
  }
  /**
   * Measurements of the screen. (0, 0, screenWidth, screenHeight).
   *
   * Its safe to use as filterArea or hitArea for the whole stage.
   */
  get screen() {
    return this.view.screen;
  }
  /**
   * Create a bunch of runners based of a collection of ids
   * @param runnerIds - the runner ids to add
   */
  _addRunners(...t) {
    t.forEach((e) => {
      this.runners[e] = new C_(e);
    });
  }
  _addSystems(t) {
    let e;
    for (e in t) {
      const n = t[e];
      this._addSystem(n.value, n.name);
    }
  }
  /**
   * Add a new system to the renderer.
   * @param ClassRef - Class reference
   * @param name - Property name for system, if not specified
   *        will use a static `name` property on the class itself. This
   *        name will be assigned as s property on the Renderer so make
   *        sure it doesn't collide with properties on Renderer.
   * @returns Return instance of renderer
   */
  _addSystem(t, e) {
    const n = new t(this);
    if (this[e])
      throw new Error(`Whoops! The name "${e}" is already in use`);
    this[e] = n, this._systemsHash[e] = n;
    for (const r in this.runners)
      this.runners[r].add(n);
    return this;
  }
  _addPipes(t, e) {
    const n = e.reduce((r, s) => (r[s.name] = s.value, r), {});
    t.forEach((r) => {
      const s = r.value, o = r.name, a = n[o];
      this.renderPipes[o] = new s(
        this,
        a ? new a() : null
      );
    });
  }
  destroy(t = !1) {
    this.runners.destroy.items.reverse(), this.runners.destroy.emit(t), Object.values(this.runners).forEach((e) => {
      e.destroy();
    }), this._systemsHash = null, this.renderPipes = null;
  }
  /**
   * Generate a texture from a container.
   * @param options - options or container target to use when generating the texture
   * @returns a texture
   */
  generateTexture(t) {
    return this.textureGenerator.generateTexture(t);
  }
  /**
   * Whether the renderer will round coordinates to whole pixels when rendering.
   * Can be overridden on a per scene item basis.
   */
  get roundPixels() {
    return !!this._roundPixels;
  }
  /**
   * Overridable function by `pixi.js/unsafe-eval` to silence
   * throwing an error if platform doesn't support unsafe-evals.
   * @private
   * @ignore
   */
  _unsafeEvalCheck() {
    if (!h_())
      throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
  }
};
om.defaultOptions = {
  /**
   * Default resolution / device pixel ratio of the renderer.
   * @default 1
   */
  resolution: 1,
  /**
   * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`
   * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be
   * performance issues when using WebGL.
   *
   * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many
   * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or
   * driver version blacklisted by the
   * browser.
   *
   * If your application requires high performance rendering, you may wish to set this to false.
   * We recommend one of two options if you decide to set this flag to false:
   *
   * 1: Use the Canvas renderer as a fallback in case high performance WebGL is
   *    not supported.
   *
   * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a
   *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their
   *    device & browser combination does not support high performance WebGL.
   *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.
   * @default false
   */
  failIfMajorPerformanceCaveat: !1,
  /**
   * Should round pixels be forced when rendering?
   * @default false
   */
  roundPixels: !1
};
let lm = om, Rl;
function I_(i) {
  return Rl !== void 0 || (Rl = (() => {
    var t;
    const e = {
      stencil: !0,
      failIfMajorPerformanceCaveat: i ?? lm.defaultOptions.failIfMajorPerformanceCaveat
    };
    try {
      if (!Mt.get().getWebGLRenderingContext())
        return !1;
      let n = Mt.get().createCanvas().getContext("webgl", e);
      const r = !!((t = n == null ? void 0 : n.getContextAttributes()) != null && t.stencil);
      if (n) {
        const s = n.getExtension("WEBGL_lose_context");
        s && s.loseContext();
      }
      return n = null, r;
    } catch {
      return !1;
    }
  })()), Rl;
}
let kl;
async function R_(i = {}) {
  return kl !== void 0 || (kl = await (async () => {
    const t = Mt.get().getNavigator().gpu;
    if (!t)
      return !1;
    try {
      return await (await t.requestAdapter(i)).requestDevice(), !0;
    } catch {
      return !1;
    }
  })()), kl;
}
const Pd = ["webgl", "webgpu", "canvas"];
async function k_(i) {
  let t = [];
  i.preference ? (t.push(i.preference), Pd.forEach((s) => {
    s !== i.preference && t.push(s);
  })) : t = Pd.slice();
  let e, n = {};
  for (let s = 0; s < t.length; s++) {
    const o = t[s];
    if (o === "webgpu" && await R_()) {
      const { WebGPURenderer: a } = await import("./WebGPURenderer-CFR6AS1D-imfn_sWo.js");
      e = a, n = { ...i, ...i.webgpu };
      break;
    } else if (o === "webgl" && I_(
      i.failIfMajorPerformanceCaveat ?? lm.defaultOptions.failIfMajorPerformanceCaveat
    )) {
      const { WebGLRenderer: a } = await import("./WebGLRenderer-Di-BqfWs-DBwmEFUF.js");
      e = a, n = { ...i, ...i.webgl };
      break;
    } else if (o === "canvas")
      throw n = { ...i }, new Error("CanvasRenderer is not yet implemented");
  }
  if (delete n.webgpu, delete n.webgl, !e)
    throw new Error("No available renderer for the current environment");
  const r = new e();
  return await r.init(n), r;
}
const hm = "8.5.2";
class cm {
  static init() {
    var t;
    (t = globalThis.__PIXI_APP_INIT__) == null || t.call(globalThis, this, hm);
  }
  static destroy() {
  }
}
cm.extension = X.Application;
class M_ {
  constructor(t) {
    this._renderer = t;
  }
  init() {
    var t;
    (t = globalThis.__PIXI_RENDERER_INIT__) == null || t.call(globalThis, this._renderer, hm);
  }
  destroy() {
    this._renderer = null;
  }
}
M_.extension = {
  type: [
    X.WebGLSystem,
    X.WebGPUSystem
  ],
  name: "initHook",
  priority: -10
};
const um = class _h {
  /** @ignore */
  constructor(...t) {
    this.stage = new Te(), t[0] !== void 0 && ut(dt, "Application constructor options are deprecated, please use Application.init() instead.");
  }
  /**
   * @param options - The optional application and renderer parameters.
   */
  async init(t) {
    t = { ...t }, this.renderer = await k_(t), _h._plugins.forEach((e) => {
      e.init.call(this, t);
    });
  }
  /** Render the current stage. */
  render() {
    this.renderer.render({ container: this.stage });
  }
  /**
   * Reference to the renderer's canvas element.
   * @readonly
   * @member {HTMLCanvasElement}
   */
  get canvas() {
    return this.renderer.canvas;
  }
  /**
   * Reference to the renderer's canvas element.
   * @member {HTMLCanvasElement}
   * @deprecated since 8.0.0
   */
  get view() {
    return ut(dt, "Application.view is deprecated, please use Application.canvas instead."), this.renderer.canvas;
  }
  /**
   * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
   * @readonly
   */
  get screen() {
    return this.renderer.screen;
  }
  /**
   * Destroys the application and all of its resources.
   * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.
   * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.
   * @param {object|boolean} [options=false] - The options for destroying the stage.
   * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method
   * called as well. `options` will be passed on to those calls.
   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.
   * If options.children is set to true,
   * it should destroy the texture of the child sprite.
   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
   *  If options.children is set to true,
   * it should destroy the texture source of the child sprite.
   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
   * If options.children is set to true,
   * it should destroy the context of the child graphics.
   */
  destroy(t = !1, e = !1) {
    const n = _h._plugins.slice(0);
    n.reverse(), n.forEach((r) => {
      r.destroy.call(this);
    }), this.stage.destroy(e), this.stage = null, this.renderer.destroy(t), this.renderer = null;
  }
};
um._plugins = [];
let dm = um;
ge.handleByList(X.Application, dm._plugins);
ge.add(cm);
class pm extends xe {
  constructor() {
    super(...arguments), this.chars = /* @__PURE__ */ Object.create(null), this.lineHeight = 0, this.fontFamily = "", this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 }, this.baseLineOffset = 0, this.distanceField = { type: "none", range: 0 }, this.pages = [], this.applyFillAsTint = !0, this.baseMeasurementFontSize = 100, this.baseRenderedFontSize = 100;
  }
  /**
   * The name of the font face.
   * @deprecated since 8.0.0 Use `fontFamily` instead.
   */
  get font() {
    return ut(dt, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."), this.fontFamily;
  }
  /**
   * The map of base page textures (i.e., sheets of glyphs).
   * @deprecated since 8.0.0 Use `pages` instead.
   */
  get pageTextures() {
    return ut(dt, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages;
  }
  /**
   * The size of the font face in pixels.
   * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.
   */
  get size() {
    return ut(dt, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."), this.fontMetrics.fontSize;
  }
  /**
   * The kind of distance field for this font or "none".
   * @deprecated since 8.0.0 Use `distanceField.type` instead.
   */
  get distanceFieldRange() {
    return ut(dt, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."), this.distanceField.range;
  }
  /**
   * The range of the distance field in pixels.
   * @deprecated since 8.0.0 Use `distanceField.range` instead.
   */
  get distanceFieldType() {
    return ut(dt, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."), this.distanceField.type;
  }
  destroy(t = !1) {
    var e;
    this.emit("destroy", this), this.removeAllListeners();
    for (const n in this.chars)
      (e = this.chars[n].texture) == null || e.destroy();
    this.chars = null, t && (this.pages.forEach((n) => n.texture.destroy(!0)), this.pages = null);
  }
}
const fm = class xh {
  constructor(t, e, n, r) {
    this.uid = qt("fillGradient"), this.type = "linear", this.gradientStops = [], this._styleKey = null, this.x0 = t, this.y0 = e, this.x1 = n, this.y1 = r;
  }
  addColorStop(t, e) {
    return this.gradientStops.push({ offset: t, color: Gt.shared.setValue(e).toHexa() }), this._styleKey = null, this;
  }
  // TODO move to the system!
  buildLinearGradient() {
    const t = xh.defaultTextureSize, { gradientStops: e } = this, n = Mt.get().createCanvas();
    n.width = t, n.height = t;
    const r = n.getContext("2d"), s = r.createLinearGradient(0, 0, xh.defaultTextureSize, 1);
    for (let g = 0; g < e.length; g++) {
      const y = e[g];
      s.addColorStop(y.offset, y.color);
    }
    r.fillStyle = s, r.fillRect(0, 0, t, t), this.texture = new nt({
      source: new Rr({
        resource: n,
        addressModeU: "clamp-to-edge",
        addressModeV: "repeat"
      })
    });
    const { x0: o, y0: a, x1: l, y1: h } = this, c = new ct(), p = l - o, f = h - a, d = Math.sqrt(p * p + f * f), m = Math.atan2(f, p);
    c.translate(-o, -a), c.scale(1 / t, 1 / t), c.rotate(-m), c.scale(256 / d, 1), this.transform = c, this._styleKey = null;
  }
  get styleKey() {
    if (this._styleKey)
      return this._styleKey;
    const t = this.gradientStops.map((r) => `${r.offset}-${r.color}`).join("-"), e = this.texture.uid, n = this.transform.toArray().join("-");
    return `fill-gradient-${this.uid}-${t}-${e}-${n}-${this.x0}-${this.y0}-${this.x1}-${this.y1}`;
  }
};
fm.defaultTextureSize = 256;
let Rs = fm;
const Id = {
  repeat: {
    addressModeU: "repeat",
    addressModeV: "repeat"
  },
  "repeat-x": {
    addressModeU: "repeat",
    addressModeV: "clamp-to-edge"
  },
  "repeat-y": {
    addressModeU: "clamp-to-edge",
    addressModeV: "repeat"
  },
  "no-repeat": {
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge"
  }
};
class ka {
  constructor(t, e) {
    this.uid = qt("fillPattern"), this.transform = new ct(), this._styleKey = null, this.texture = t, this.transform.scale(
      1 / t.frame.width,
      1 / t.frame.height
    ), e && (t.source.style.addressModeU = Id[e].addressModeU, t.source.style.addressModeV = Id[e].addressModeV);
  }
  setTransform(t) {
    const e = this.texture;
    this.transform.copyFrom(t), this.transform.invert(), this.transform.scale(
      1 / e.frame.width,
      1 / e.frame.height
    ), this._styleKey = null;
  }
  get styleKey() {
    return this._styleKey ? this._styleKey : (this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`, this._styleKey);
  }
}
var O_ = B_, Ml = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 }, D_ = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
function B_(i) {
  var t = [];
  return i.replace(D_, function(e, n, r) {
    var s = n.toLowerCase();
    for (r = F_(r), s == "m" && r.length > 2 && (t.push([n].concat(r.splice(0, 2))), s = "l", n = n == "m" ? "l" : "L"); ; ) {
      if (r.length == Ml[s])
        return r.unshift(n), t.push(r);
      if (r.length < Ml[s]) throw new Error("malformed path data");
      t.push([n].concat(r.splice(0, Ml[s])));
    }
  }), t;
}
var V_ = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
function F_(i) {
  var t = i.match(V_);
  return t ? t.map(Number) : [];
}
const L_ = /* @__PURE__ */ cc(O_);
function N_(i, t) {
  const e = L_(i), n = [];
  let r = null, s = 0, o = 0;
  for (let a = 0; a < e.length; a++) {
    const l = e[a], h = l[0], c = l;
    switch (h) {
      case "M":
        s = c[1], o = c[2], t.moveTo(s, o);
        break;
      case "m":
        s += c[1], o += c[2], t.moveTo(s, o);
        break;
      case "H":
        s = c[1], t.lineTo(s, o);
        break;
      case "h":
        s += c[1], t.lineTo(s, o);
        break;
      case "V":
        o = c[1], t.lineTo(s, o);
        break;
      case "v":
        o += c[1], t.lineTo(s, o);
        break;
      case "L":
        s = c[1], o = c[2], t.lineTo(s, o);
        break;
      case "l":
        s += c[1], o += c[2], t.lineTo(s, o);
        break;
      case "C":
        s = c[5], o = c[6], t.bezierCurveTo(
          c[1],
          c[2],
          c[3],
          c[4],
          s,
          o
        );
        break;
      case "c":
        t.bezierCurveTo(
          s + c[1],
          o + c[2],
          s + c[3],
          o + c[4],
          s + c[5],
          o + c[6]
        ), s += c[5], o += c[6];
        break;
      case "S":
        s = c[3], o = c[4], t.bezierCurveToShort(
          c[1],
          c[2],
          s,
          o
        );
        break;
      case "s":
        t.bezierCurveToShort(
          s + c[1],
          o + c[2],
          s + c[3],
          o + c[4]
        ), s += c[3], o += c[4];
        break;
      case "Q":
        s = c[3], o = c[4], t.quadraticCurveTo(
          c[1],
          c[2],
          s,
          o
        );
        break;
      case "q":
        t.quadraticCurveTo(
          s + c[1],
          o + c[2],
          s + c[3],
          o + c[4]
        ), s += c[3], o += c[4];
        break;
      case "T":
        s = c[1], o = c[2], t.quadraticCurveToShort(
          s,
          o
        );
        break;
      case "t":
        s += c[1], o += c[2], t.quadraticCurveToShort(
          s,
          o
        );
        break;
      case "A":
        s = c[6], o = c[7], t.arcToSvg(
          c[1],
          c[2],
          c[3],
          c[4],
          c[5],
          s,
          o
        );
        break;
      case "a":
        s += c[6], o += c[7], t.arcToSvg(
          c[1],
          c[2],
          c[3],
          c[4],
          c[5],
          s,
          o
        );
        break;
      case "Z":
      case "z":
        t.closePath(), n.length > 0 && (r = n.pop(), r ? (s = r.startX, o = r.startY) : (s = 0, o = 0)), r = null;
        break;
      default:
        Lt(`Unknown SVG path command: ${h}`);
    }
    h !== "Z" && h !== "z" && r === null && (r = { startX: s, startY: o }, n.push(r));
  }
  return t;
}
class Ma {
  /**
   * @param x - The X coordinate of the center of this circle
   * @param y - The Y coordinate of the center of this circle
   * @param radius - The radius of the circle
   */
  constructor(t = 0, e = 0, n = 0) {
    this.type = "circle", this.x = t, this.y = e, this.radius = n;
  }
  /**
   * Creates a clone of this Circle instance
   * @returns A copy of the Circle
   */
  clone() {
    return new Ma(this.x, this.y, this.radius);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Circle
   */
  contains(t, e) {
    if (this.radius <= 0)
      return !1;
    const n = this.radius * this.radius;
    let r = this.x - t, s = this.y - e;
    return r *= r, s *= s, r + s <= n;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle including the stroke.
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param width - The width of the line to check
   * @returns Whether the x/y coordinates are within this Circle
   */
  strokeContains(t, e, n) {
    if (this.radius === 0)
      return !1;
    const r = this.x - t, s = this.y - e, o = this.radius, a = n / 2, l = Math.sqrt(r * r + s * s);
    return l < o + a && l > o - a;
  }
  /**
   * Returns the framing rectangle of the circle as a Rectangle object
   * @param out
   * @returns The framing rectangle
   */
  getBounds(t) {
    return t = t || new jt(), t.x = this.x - this.radius, t.y = this.y - this.radius, t.width = this.radius * 2, t.height = this.radius * 2, t;
  }
  /**
   * Copies another circle to this one.
   * @param circle - The circle to copy from.
   * @returns Returns itself.
   */
  copyFrom(t) {
    return this.x = t.x, this.y = t.y, this.radius = t.radius, this;
  }
  /**
   * Copies this circle to another one.
   * @param circle - The circle to copy to.
   * @returns Returns given parameter.
   */
  copyTo(t) {
    return t.copyFrom(this), t;
  }
  toString() {
    return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
  }
}
class gc {
  /**
   * @param x - The X coordinate of the center of this ellipse
   * @param y - The Y coordinate of the center of this ellipse
   * @param halfWidth - The half width of this ellipse
   * @param halfHeight - The half height of this ellipse
   */
  constructor(t = 0, e = 0, n = 0, r = 0) {
    this.type = "ellipse", this.x = t, this.y = e, this.halfWidth = n, this.halfHeight = r;
  }
  /**
   * Creates a clone of this Ellipse instance
   * @returns {Ellipse} A copy of the ellipse
   */
  clone() {
    return new gc(this.x, this.y, this.halfWidth, this.halfHeight);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coords are within this ellipse
   */
  contains(t, e) {
    if (this.halfWidth <= 0 || this.halfHeight <= 0)
      return !1;
    let n = (t - this.x) / this.halfWidth, r = (e - this.y) / this.halfHeight;
    return n *= n, r *= r, n + r <= 1;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse including stroke
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param width
   * @returns Whether the x/y coords are within this ellipse
   */
  strokeContains(t, e, n) {
    const { halfWidth: r, halfHeight: s } = this;
    if (r <= 0 || s <= 0)
      return !1;
    const o = n / 2, a = r - o, l = s - o, h = r + o, c = s + o, p = t - this.x, f = e - this.y, d = p * p / (a * a) + f * f / (l * l), m = p * p / (h * h) + f * f / (c * c);
    return d > 1 && m <= 1;
  }
  /**
   * Returns the framing rectangle of the ellipse as a Rectangle object
   * @param out
   * @returns The framing rectangle
   */
  getBounds(t) {
    return t = t || new jt(), t.x = this.x - this.halfWidth, t.y = this.y - this.halfHeight, t.width = this.halfWidth * 2, t.height = this.halfHeight * 2, t;
  }
  /**
   * Copies another ellipse to this one.
   * @param ellipse - The ellipse to copy from.
   * @returns Returns itself.
   */
  copyFrom(t) {
    return this.x = t.x, this.y = t.y, this.halfWidth = t.halfWidth, this.halfHeight = t.halfHeight, this;
  }
  /**
   * Copies this ellipse to another one.
   * @param ellipse - The ellipse to copy to.
   * @returns Returns given parameter.
   */
  copyTo(t) {
    return t.copyFrom(this), t;
  }
  toString() {
    return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
  }
}
function U_(i, t, e, n, r, s) {
  const o = i - e, a = t - n, l = r - e, h = s - n, c = o * l + a * h, p = l * l + h * h;
  let f = -1;
  p !== 0 && (f = c / p);
  let d, m;
  f < 0 ? (d = e, m = n) : f > 1 ? (d = r, m = s) : (d = e + f * l, m = n + f * h);
  const g = i - d, y = t - m;
  return g * g + y * y;
}
class lr {
  /**
   * @param points - This can be an array of Points
   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
   *  the arguments passed can be all the points of the polygon e.g.
   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
   */
  constructor(...t) {
    this.type = "polygon";
    let e = Array.isArray(t[0]) ? t[0] : t;
    if (typeof e[0] != "number") {
      const n = [];
      for (let r = 0, s = e.length; r < s; r++)
        n.push(e[r].x, e[r].y);
      e = n;
    }
    this.points = e, this.closePath = !0;
  }
  /**
   * Creates a clone of this polygon.
   * @returns - A copy of the polygon.
   */
  clone() {
    const t = this.points.slice(), e = new lr(t);
    return e.closePath = this.closePath, e;
  }
  /**
   * Checks whether the x and y coordinates passed to this function are contained within this polygon.
   * @param x - The X coordinate of the point to test.
   * @param y - The Y coordinate of the point to test.
   * @returns - Whether the x/y coordinates are within this polygon.
   */
  contains(t, e) {
    let n = !1;
    const r = this.points.length / 2;
    for (let s = 0, o = r - 1; s < r; o = s++) {
      const a = this.points[s * 2], l = this.points[s * 2 + 1], h = this.points[o * 2], c = this.points[o * 2 + 1];
      l > e != c > e && t < (h - a) * ((e - l) / (c - l)) + a && (n = !n);
    }
    return n;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @returns Whether the x/y coordinates are within this polygon
   */
  strokeContains(t, e, n) {
    const r = n / 2, s = r * r, { points: o } = this, a = o.length - (this.closePath ? 0 : 2);
    for (let l = 0; l < a; l += 2) {
      const h = o[l], c = o[l + 1], p = o[(l + 2) % o.length], f = o[(l + 3) % o.length];
      if (U_(t, e, h, c, p, f) <= s)
        return !0;
    }
    return !1;
  }
  /**
   * Returns the framing rectangle of the polygon as a Rectangle object
   * @param out - optional rectangle to store the result
   * @returns The framing rectangle
   */
  getBounds(t) {
    t = t || new jt();
    const e = this.points;
    let n = 1 / 0, r = -1 / 0, s = 1 / 0, o = -1 / 0;
    for (let a = 0, l = e.length; a < l; a += 2) {
      const h = e[a], c = e[a + 1];
      n = h < n ? h : n, r = h > r ? h : r, s = c < s ? c : s, o = c > o ? c : o;
    }
    return t.x = n, t.width = r - n, t.y = s, t.height = o - s, t;
  }
  /**
   * Copies another polygon to this one.
   * @param polygon - The polygon to copy from.
   * @returns Returns itself.
   */
  copyFrom(t) {
    return this.points = t.points.slice(), this.closePath = t.closePath, this;
  }
  /**
   * Copies this polygon to another one.
   * @param polygon - The polygon to copy to.
   * @returns Returns given parameter.
   */
  copyTo(t) {
    return t.copyFrom(this), t;
  }
  toString() {
    return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((t, e) => `${t}, ${e}`, "")}]`;
  }
  /**
   * Get the last X coordinate of the polygon
   * @readonly
   */
  get lastX() {
    return this.points[this.points.length - 2];
  }
  /**
   * Get the last Y coordinate of the polygon
   * @readonly
   */
  get lastY() {
    return this.points[this.points.length - 1];
  }
  /**
   * Get the first X coordinate of the polygon
   * @readonly
   */
  get x() {
    return this.points[this.points.length - 2];
  }
  /**
   * Get the first Y coordinate of the polygon
   * @readonly
   */
  get y() {
    return this.points[this.points.length - 1];
  }
}
const Eo = (i, t, e, n, r, s) => {
  const o = i - e, a = t - n, l = Math.sqrt(o * o + a * a);
  return l >= r - s && l <= r + s;
};
class Oa {
  /**
   * @param x - The X coordinate of the upper-left corner of the rounded rectangle
   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
   * @param width - The overall width of this rounded rectangle
   * @param height - The overall height of this rounded rectangle
   * @param radius - Controls the radius of the rounded corners
   */
  constructor(t = 0, e = 0, n = 0, r = 0, s = 20) {
    this.type = "roundedRectangle", this.x = t, this.y = e, this.width = n, this.height = r, this.radius = s;
  }
  /**
   * Returns the framing rectangle of the rounded rectangle as a Rectangle object
   * @param out - optional rectangle to store the result
   * @returns The framing rectangle
   */
  getBounds(t) {
    return t = t || new jt(), t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t;
  }
  /**
   * Creates a clone of this Rounded Rectangle.
   * @returns - A copy of the rounded rectangle.
   */
  clone() {
    return new Oa(this.x, this.y, this.width, this.height, this.radius);
  }
  /**
   * Copies another rectangle to this one.
   * @param rectangle - The rectangle to copy from.
   * @returns Returns itself.
   */
  copyFrom(t) {
    return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
  }
  /**
   * Copies this rectangle to another one.
   * @param rectangle - The rectangle to copy to.
   * @returns Returns given parameter.
   */
  copyTo(t) {
    return t.copyFrom(this), t;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
   * @param x - The X coordinate of the point to test.
   * @param y - The Y coordinate of the point to test.
   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.
   */
  contains(t, e) {
    if (this.width <= 0 || this.height <= 0)
      return !1;
    if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
      const n = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
      if (e >= this.y + n && e <= this.y + this.height - n || t >= this.x + n && t <= this.x + this.width - n)
        return !0;
      let r = t - (this.x + n), s = e - (this.y + n);
      const o = n * n;
      if (r * r + s * s <= o || (r = t - (this.x + this.width - n), r * r + s * s <= o) || (s = e - (this.y + this.height - n), r * r + s * s <= o) || (r = t - (this.x + n), r * r + s * s <= o))
        return !0;
    }
    return !1;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
   * @param pX - The X coordinate of the point to test
   * @param pY - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @returns Whether the x/y coordinates are within this rectangle
   */
  strokeContains(t, e, n) {
    const { x: r, y: s, width: o, height: a, radius: l } = this, h = n / 2, c = r + l, p = s + l, f = o - l * 2, d = a - l * 2, m = r + o, g = s + a;
    return (t >= r - h && t <= r + h || t >= m - h && t <= m + h) && e >= p && e <= p + d || (e >= s - h && e <= s + h || e >= g - h && e <= g + h) && t >= c && t <= c + f ? !0 : (
      // Top-left
      t < c && e < p && Eo(t, e, c, p, l, h) || t > m - l && e < p && Eo(t, e, m - l, p, l, h) || t > m - l && e > g - l && Eo(t, e, m - l, g - l, l, h) || t < c && e > g - l && Eo(t, e, c, g - l, l, h)
    );
  }
  toString() {
    return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
  }
}
const z_ = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join(`
`);
function j_(i) {
  let t = "";
  for (let e = 0; e < i; ++e)
    e > 0 && (t += `
else `), e < i - 1 && (t += `if(test == ${e}.0){}`);
  return t;
}
function G_(i, t) {
  if (i === 0)
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  const e = t.createShader(t.FRAGMENT_SHADER);
  try {
    for (; ; ) {
      const n = z_.replace(/%forloop%/gi, j_(i));
      if (t.shaderSource(e, n), t.compileShader(e), !t.getShaderParameter(e, t.COMPILE_STATUS))
        i = i / 2 | 0;
      else
        break;
    }
  } finally {
    t.deleteShader(e);
  }
  return i;
}
let Zn = null;
function mm() {
  var i;
  if (Zn)
    return Zn;
  const t = Kf();
  return Zn = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), Zn = G_(
    Zn,
    t
  ), (i = t.getExtension("WEBGL_lose_context")) == null || i.loseContext(), Zn;
}
const gm = {};
function H_(i, t) {
  let e = 2166136261;
  for (let n = 0; n < t; n++)
    e ^= i[n].uid, e = Math.imul(e, 16777619), e >>>= 0;
  return gm[e] || W_(i, t, e);
}
let Ol = 0;
function W_(i, t, e) {
  const n = {};
  let r = 0;
  Ol || (Ol = mm());
  for (let o = 0; o < Ol; o++) {
    const a = o < t ? i[o] : nt.EMPTY.source;
    n[r++] = a.source, n[r++] = a.style;
  }
  const s = new Fo(n);
  return gm[e] = s, s;
}
class Rd {
  constructor(t) {
    typeof t == "number" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData), this.size = this.rawBinaryData.byteLength;
  }
  /** View on the raw binary data as a `Int8Array`. */
  get int8View() {
    return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
  }
  /** View on the raw binary data as a `Uint8Array`. */
  get uint8View() {
    return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
  }
  /**  View on the raw binary data as a `Int16Array`. */
  get int16View() {
    return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
  }
  /** View on the raw binary data as a `Int32Array`. */
  get int32View() {
    return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
  }
  /** View on the raw binary data as a `Float64Array`. */
  get float64View() {
    return this._float64Array || (this._float64Array = new Float64Array(this.rawBinaryData)), this._float64Array;
  }
  /** View on the raw binary data as a `BigUint64Array`. */
  get bigUint64View() {
    return this._bigUint64Array || (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)), this._bigUint64Array;
  }
  /**
   * Returns the view of the given type.
   * @param type - One of `int8`, `uint8`, `int16`,
   *    `uint16`, `int32`, `uint32`, and `float32`.
   * @returns - typed array of given type
   */
  view(t) {
    return this[`${t}View`];
  }
  /** Destroys all buffer references. Do not use after calling this. */
  destroy() {
    this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this.uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
  }
  /**
   * Returns the size of the given type in bytes.
   * @param type - One of `int8`, `uint8`, `int16`,
   *   `uint16`, `int32`, `uint32`, and `float32`.
   * @returns - size of the type in bytes
   */
  static sizeOf(t) {
    switch (t) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(`${t} isn't a valid view type`);
    }
  }
}
function kd(i, t) {
  const e = i.byteLength / 8 | 0, n = new Float64Array(i, 0, e);
  new Float64Array(t, 0, e).set(n);
  const r = i.byteLength - e * 8;
  if (r > 0) {
    const s = new Uint8Array(i, e * 8, r);
    new Uint8Array(t, e * 8, r).set(s);
  }
}
const q_ = {
  normal: "normal-npm",
  add: "add-npm",
  screen: "screen-npm"
};
var Y_ = /* @__PURE__ */ ((i) => (i[i.DISABLED = 0] = "DISABLED", i[i.RENDERING_MASK_ADD = 1] = "RENDERING_MASK_ADD", i[i.MASK_ACTIVE = 2] = "MASK_ACTIVE", i[i.INVERSE_MASK_ACTIVE = 3] = "INVERSE_MASK_ACTIVE", i[i.RENDERING_MASK_REMOVE = 4] = "RENDERING_MASK_REMOVE", i[i.NONE = 5] = "NONE", i))(Y_ || {});
function Md(i, t) {
  return t.alphaMode === "no-premultiply-alpha" && q_[i] || i;
}
class X_ {
  constructor() {
    this.ids = /* @__PURE__ */ Object.create(null), this.textures = [], this.count = 0;
  }
  /** Clear the textures and their locations. */
  clear() {
    for (let t = 0; t < this.count; t++) {
      const e = this.textures[t];
      this.textures[t] = null, this.ids[e.uid] = null;
    }
    this.count = 0;
  }
}
class K_ {
  constructor() {
    this.renderPipeId = "batch", this.action = "startBatch", this.start = 0, this.size = 0, this.textures = new X_(), this.blendMode = "normal", this.canBundle = !0;
  }
  destroy() {
    this.textures = null, this.gpuBindGroup = null, this.bindGroup = null, this.batcher = null;
  }
}
const ym = [];
let bh = 0;
function Od() {
  return bh > 0 ? ym[--bh] : new K_();
}
function Dd(i) {
  ym[bh++] = i;
}
let is = 0;
const vm = class Lo {
  constructor(t = {}) {
    this.uid = qt("batcher"), this.dirty = !0, this.batchIndex = 0, this.batches = [], this._elements = [], Lo.defaultOptions.maxTextures = Lo.defaultOptions.maxTextures ?? mm(), t = { ...Lo.defaultOptions, ...t };
    const { maxTextures: e, attributesInitialSize: n, indicesInitialSize: r } = t;
    this.attributeBuffer = new Rd(n * 4), this.indexBuffer = new Uint16Array(r), this.maxTextures = e;
  }
  begin() {
    this.elementSize = 0, this.elementStart = 0, this.indexSize = 0, this.attributeSize = 0;
    for (let t = 0; t < this.batchIndex; t++)
      Dd(this.batches[t]);
    this.batchIndex = 0, this._batchIndexStart = 0, this._batchIndexSize = 0, this.dirty = !0;
  }
  add(t) {
    this._elements[this.elementSize++] = t, t._indexStart = this.indexSize, t._attributeStart = this.attributeSize, t._batcher = this, this.indexSize += t.indexSize, this.attributeSize += t.attributeSize * this.vertexSize;
  }
  checkAndUpdateTexture(t, e) {
    const n = t._batch.textures.ids[e._source.uid];
    return !n && n !== 0 ? !1 : (t._textureId = n, t.texture = e, !0);
  }
  updateElement(t) {
    this.dirty = !0;
    const e = this.attributeBuffer;
    t.packAsQuad ? this.packQuadAttributes(
      t,
      e.float32View,
      e.uint32View,
      t._attributeStart,
      t._textureId
    ) : this.packAttributes(
      t,
      e.float32View,
      e.uint32View,
      t._attributeStart,
      t._textureId
    );
  }
  /**
   * breaks the batcher. This happens when a batch gets too big,
   * or we need to switch to a different type of rendering (a filter for example)
   * @param instructionSet
   */
  break(t) {
    const e = this._elements;
    if (!e[this.elementStart])
      return;
    let n = Od(), r = n.textures;
    r.clear();
    const s = e[this.elementStart];
    let o = Md(s.blendMode, s.texture._source);
    this.attributeSize * 4 > this.attributeBuffer.size && this._resizeAttributeBuffer(this.attributeSize * 4), this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize);
    const a = this.attributeBuffer.float32View, l = this.attributeBuffer.uint32View, h = this.indexBuffer;
    let c = this._batchIndexSize, p = this._batchIndexStart, f = "startBatch";
    const d = this.maxTextures;
    for (let m = this.elementStart; m < this.elementSize; ++m) {
      const g = e[m];
      e[m] = null;
      const y = g.texture._source, b = Md(g.blendMode, y), S = o !== b;
      if (y._batchTick === is && !S) {
        g._textureId = y._textureBindLocation, c += g.indexSize, g.packAsQuad ? (this.packQuadAttributes(
          g,
          a,
          l,
          g._attributeStart,
          g._textureId
        ), this.packQuadIndex(
          h,
          g._indexStart,
          g._attributeStart / this.vertexSize
        )) : (this.packAttributes(
          g,
          a,
          l,
          g._attributeStart,
          g._textureId
        ), this.packIndex(
          g,
          h,
          g._indexStart,
          g._attributeStart / this.vertexSize
        )), g._batch = n;
        continue;
      }
      y._batchTick = is, (r.count >= d || S) && (this._finishBatch(
        n,
        p,
        c - p,
        r,
        o,
        t,
        f
      ), f = "renderBatch", p = c, o = b, n = Od(), r = n.textures, r.clear(), ++is), g._textureId = y._textureBindLocation = r.count, r.ids[y.uid] = r.count, r.textures[r.count++] = y, g._batch = n, c += g.indexSize, g.packAsQuad ? (this.packQuadAttributes(
        g,
        a,
        l,
        g._attributeStart,
        g._textureId
      ), this.packQuadIndex(
        h,
        g._indexStart,
        g._attributeStart / this.vertexSize
      )) : (this.packAttributes(
        g,
        a,
        l,
        g._attributeStart,
        g._textureId
      ), this.packIndex(
        g,
        h,
        g._indexStart,
        g._attributeStart / this.vertexSize
      ));
    }
    r.count > 0 && (this._finishBatch(
      n,
      p,
      c - p,
      r,
      o,
      t,
      f
    ), p = c, ++is), this.elementStart = this.elementSize, this._batchIndexStart = p, this._batchIndexSize = c;
  }
  _finishBatch(t, e, n, r, s, o, a) {
    t.gpuBindGroup = null, t.bindGroup = null, t.action = a, t.batcher = this, t.textures = r, t.blendMode = s, t.start = e, t.size = n, ++is, this.batches[this.batchIndex++] = t, o.add(t);
  }
  finish(t) {
    this.break(t);
  }
  /**
   * Resizes the attribute buffer to the given size (1 = 1 float32)
   * @param size - the size in vertices to ensure (not bytes!)
   */
  ensureAttributeBuffer(t) {
    t * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(t * 4);
  }
  /**
   * Resizes the index buffer to the given size (1 = 1 float32)
   * @param size - the size in vertices to ensure (not bytes!)
   */
  ensureIndexBuffer(t) {
    t <= this.indexBuffer.length || this._resizeIndexBuffer(t);
  }
  _resizeAttributeBuffer(t) {
    const e = Math.max(t, this.attributeBuffer.size * 2), n = new Rd(e);
    kd(this.attributeBuffer.rawBinaryData, n.rawBinaryData), this.attributeBuffer = n;
  }
  _resizeIndexBuffer(t) {
    const e = this.indexBuffer;
    let n = Math.max(t, e.length * 1.5);
    n += n % 2;
    const r = n > 65535 ? new Uint32Array(n) : new Uint16Array(n);
    if (r.BYTES_PER_ELEMENT !== e.BYTES_PER_ELEMENT)
      for (let s = 0; s < e.length; s++)
        r[s] = e[s];
    else
      kd(e.buffer, r.buffer);
    this.indexBuffer = r;
  }
  packQuadIndex(t, e, n) {
    t[e] = n + 0, t[e + 1] = n + 1, t[e + 2] = n + 2, t[e + 3] = n + 0, t[e + 4] = n + 2, t[e + 5] = n + 3;
  }
  packIndex(t, e, n, r) {
    const s = t.indices, o = t.indexSize, a = t.indexOffset, l = t.attributeOffset;
    for (let h = 0; h < o; h++)
      e[n++] = r + s[h + a] - l;
  }
  destroy() {
    for (let t = 0; t < this.batches.length; t++)
      Dd(this.batches[t]);
    this.batches = null;
    for (let t = 0; t < this._elements.length; t++)
      this._elements[t]._batch = null;
    this._elements = null, this.indexBuffer = null, this.attributeBuffer.destroy(), this.attributeBuffer = null;
  }
};
vm.defaultOptions = {
  maxTextures: null,
  attributesInitialSize: 4,
  indicesInitialSize: 6
};
let Q_ = vm;
var Pe = /* @__PURE__ */ ((i) => (i[i.MAP_READ = 1] = "MAP_READ", i[i.MAP_WRITE = 2] = "MAP_WRITE", i[i.COPY_SRC = 4] = "COPY_SRC", i[i.COPY_DST = 8] = "COPY_DST", i[i.INDEX = 16] = "INDEX", i[i.VERTEX = 32] = "VERTEX", i[i.UNIFORM = 64] = "UNIFORM", i[i.STORAGE = 128] = "STORAGE", i[i.INDIRECT = 256] = "INDIRECT", i[i.QUERY_RESOLVE = 512] = "QUERY_RESOLVE", i[i.STATIC = 1024] = "STATIC", i))(Pe || {});
class ks extends xe {
  /**
   * Creates a new Buffer with the given options
   * @param options - the options for the buffer
   */
  constructor(t) {
    let { data: e, size: n } = t;
    const { usage: r, label: s, shrinkToFit: o } = t;
    super(), this.uid = qt("buffer"), this._resourceType = "buffer", this._resourceId = qt("resource"), this._touched = 0, this._updateID = 1, this.shrinkToFit = !0, this.destroyed = !1, e instanceof Array && (e = new Float32Array(e)), this._data = e, n = n ?? (e == null ? void 0 : e.byteLength);
    const a = !!e;
    this.descriptor = {
      size: n,
      usage: r,
      mappedAtCreation: a,
      label: s
    }, this.shrinkToFit = o ?? !0;
  }
  /** the data in the buffer */
  get data() {
    return this._data;
  }
  set data(t) {
    this.setDataWithSize(t, t.length, !0);
  }
  /** whether the buffer is static or not */
  get static() {
    return !!(this.descriptor.usage & Pe.STATIC);
  }
  set static(t) {
    t ? this.descriptor.usage |= Pe.STATIC : this.descriptor.usage &= ~Pe.STATIC;
  }
  /**
   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.
   * If you only want to update a subset of the buffer, you can pass in the size of the data.
   * @param value - the data to set
   * @param size - the size of the data in bytes
   * @param syncGPU - should the buffer be updated on the GPU immediately?
   */
  setDataWithSize(t, e, n) {
    if (this._updateID++, this._updateSize = e * t.BYTES_PER_ELEMENT, this._data === t) {
      n && this.emit("update", this);
      return;
    }
    const r = this._data;
    if (this._data = t, r.length !== t.length) {
      !this.shrinkToFit && t.byteLength < r.byteLength ? n && this.emit("update", this) : (this.descriptor.size = t.byteLength, this._resourceId = qt("resource"), this.emit("change", this));
      return;
    }
    n && this.emit("update", this);
  }
  /**
   * updates the buffer on the GPU to reflect the data in the buffer.
   * By default it will update the entire buffer. If you only want to update a subset of the buffer,
   * you can pass in the size of the buffer to update.
   * @param sizeInBytes - the new size of the buffer in bytes
   */
  update(t) {
    this._updateSize = t ?? this._updateSize, this._updateID++, this.emit("update", this);
  }
  /** Destroys the buffer */
  destroy() {
    this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this._data = null, this.descriptor = null, this.removeAllListeners();
  }
}
function _m(i, t) {
  if (!(i instanceof ks)) {
    let e = t ? Pe.INDEX : Pe.VERTEX;
    i instanceof Array && (t ? (i = new Uint32Array(i), e = Pe.INDEX | Pe.COPY_DST) : (i = new Float32Array(i), e = Pe.VERTEX | Pe.COPY_DST)), i = new ks({
      data: i,
      label: t ? "index-mesh-buffer" : "vertex-mesh-buffer",
      usage: e
    });
  }
  return i;
}
function J_(i, t, e) {
  const n = i.getAttribute(t);
  if (!n)
    return e.minX = 0, e.minY = 0, e.maxX = 0, e.maxY = 0, e;
  const r = n.buffer.data;
  let s = 1 / 0, o = 1 / 0, a = -1 / 0, l = -1 / 0;
  const h = r.BYTES_PER_ELEMENT, c = (n.offset || 0) / h, p = (n.stride || 2 * 4) / h;
  for (let f = c; f < r.length; f += p) {
    const d = r[f], m = r[f + 1];
    d > a && (a = d), m > l && (l = m), d < s && (s = d), m < o && (o = m);
  }
  return e.minX = s, e.minY = o, e.maxX = a, e.maxY = l, e;
}
function Z_(i) {
  return (i instanceof ks || Array.isArray(i) || i.BYTES_PER_ELEMENT) && (i = {
    buffer: i
  }), i.buffer = _m(i.buffer, !1), i;
}
class $_ extends xe {
  /**
   * Create a new instance of a geometry
   * @param options - The options for the geometry.
   */
  constructor(t = {}) {
    super(), this.uid = qt("geometry"), this._layoutKey = 0, this.instanceCount = 1, this._bounds = new Ji(), this._boundsDirty = !0;
    const { attributes: e, indexBuffer: n, topology: r } = t;
    if (this.buffers = [], this.attributes = {}, e)
      for (const s in e)
        this.addAttribute(s, e[s]);
    this.instanceCount = t.instanceCount || 1, n && this.addIndex(n), this.topology = r || "triangle-list";
  }
  onBufferUpdate() {
    this._boundsDirty = !0, this.emit("update", this);
  }
  /**
   * Returns the requested attribute.
   * @param id - The name of the attribute required
   * @returns - The attribute requested.
   */
  getAttribute(t) {
    return this.attributes[t];
  }
  /**
   * Returns the index buffer
   * @returns - The index buffer.
   */
  getIndex() {
    return this.indexBuffer;
  }
  /**
   * Returns the requested buffer.
   * @param id - The name of the buffer required.
   * @returns - The buffer requested.
   */
  getBuffer(t) {
    return this.getAttribute(t).buffer;
  }
  /**
   * Used to figure out how many vertices there are in this geometry
   * @returns the number of vertices in the geometry
   */
  getSize() {
    for (const t in this.attributes) {
      const e = this.attributes[t];
      return e.buffer.data.length / (e.stride / 4 || e.size);
    }
    return 0;
  }
  /**
   * Adds an attribute to the geometry.
   * @param name - The name of the attribute to add.
   * @param attributeOption - The attribute option to add.
   */
  addAttribute(t, e) {
    const n = Z_(e);
    this.buffers.indexOf(n.buffer) === -1 && (this.buffers.push(n.buffer), n.buffer.on("update", this.onBufferUpdate, this), n.buffer.on("change", this.onBufferUpdate, this)), this.attributes[t] = n;
  }
  /**
   * Adds an index buffer to the geometry.
   * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.
   */
  addIndex(t) {
    this.indexBuffer = _m(t, !0), this.buffers.push(this.indexBuffer);
  }
  /** Returns the bounds of the geometry. */
  get bounds() {
    return this._boundsDirty ? (this._boundsDirty = !1, J_(this, "aPosition", this._bounds)) : this._bounds;
  }
  /**
   * destroys the geometry.
   * @param destroyBuffers - destroy the buffers associated with this geometry
   */
  destroy(t = !1) {
    this.emit("destroy", this), this.removeAllListeners(), t && this.buffers.forEach((e) => e.destroy()), this.attributes = null, this.buffers = null, this.indexBuffer = null, this._bounds = null;
  }
}
const tx = new Float32Array(1), ex = new Uint32Array(1);
class ix extends $_ {
  constructor() {
    const t = new ks({
      data: tx,
      label: "attribute-batch-buffer",
      usage: Pe.VERTEX | Pe.COPY_DST,
      shrinkToFit: !1
    }), e = new ks({
      data: ex,
      label: "index-batch-buffer",
      usage: Pe.INDEX | Pe.COPY_DST,
      // | BufferUsage.STATIC,
      shrinkToFit: !1
    }), n = 6 * 4;
    super({
      attributes: {
        aPosition: {
          buffer: t,
          format: "float32x2",
          stride: n,
          offset: 0
        },
        aUV: {
          buffer: t,
          format: "float32x2",
          stride: n,
          offset: 2 * 4
        },
        aColor: {
          buffer: t,
          format: "unorm8x4",
          stride: n,
          offset: 4 * 4
        },
        aTextureIdAndRound: {
          buffer: t,
          format: "uint16x2",
          stride: n,
          offset: 5 * 4
        }
      },
      indexBuffer: e
    });
  }
}
function Bd(i, t, e) {
  if (i)
    for (const n in i) {
      const r = n.toLocaleLowerCase(), s = t[r];
      if (s) {
        let o = i[n];
        n === "header" && (o = o.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")), e && s.push(`//----${e}----//`), s.push(o);
      } else
        Lt(`${n} placement hook does not exist in shader`);
    }
}
const nx = /\{\{(.*?)\}\}/g;
function Vd(i) {
  var t;
  const e = {};
  return (((t = i.match(nx)) == null ? void 0 : t.map((n) => n.replace(/[{()}]/g, ""))) ?? []).forEach((n) => {
    e[n] = [];
  }), e;
}
function Fd(i, t) {
  let e;
  const n = /@in\s+([^;]+);/g;
  for (; (e = n.exec(i)) !== null; )
    t.push(e[1]);
}
function Ld(i, t, e = !1) {
  const n = [];
  Fd(t, n), i.forEach((a) => {
    a.header && Fd(a.header, n);
  });
  const r = n;
  e && r.sort();
  const s = r.map((a, l) => `       @location(${l}) ${a},`).join(`
`);
  let o = t.replace(/@in\s+[^;]+;\s*/g, "");
  return o = o.replace("{{in}}", `
${s}
`), o;
}
function Nd(i, t) {
  let e;
  const n = /@out\s+([^;]+);/g;
  for (; (e = n.exec(i)) !== null; )
    t.push(e[1]);
}
function rx(i) {
  const t = /\b(\w+)\s*:/g.exec(i);
  return t ? t[1] : "";
}
function sx(i) {
  const t = /@.*?\s+/g;
  return i.replace(t, "");
}
function ox(i, t) {
  const e = [];
  Nd(t, e), i.forEach((l) => {
    l.header && Nd(l.header, e);
  });
  let n = 0;
  const r = e.sort().map((l) => l.indexOf("builtin") > -1 ? l : `@location(${n++}) ${l}`).join(`,
`), s = e.sort().map((l) => `       var ${sx(l)};`).join(`
`), o = `return VSOutput(
                ${e.sort().map((l) => ` ${rx(l)}`).join(`,
`)});`;
  let a = t.replace(/@out\s+[^;]+;\s*/g, "");
  return a = a.replace("{{struct}}", `
${r}
`), a = a.replace("{{start}}", `
${s}
`), a = a.replace("{{return}}", `
${o}
`), a;
}
function Ud(i, t) {
  let e = i;
  for (const n in t) {
    const r = t[n];
    r.join(`
`).length ? e = e.replace(`{{${n}}}`, `//-----${n} START-----//
${r.join(`
`)}
//----${n} FINISH----//`) : e = e.replace(`{{${n}}}`, "");
  }
  return e;
}
const bn = /* @__PURE__ */ Object.create(null), Dl = /* @__PURE__ */ new Map();
let ax = 0;
function lx({
  template: i,
  bits: t
}) {
  const e = xm(i, t);
  if (bn[e])
    return bn[e];
  const { vertex: n, fragment: r } = cx(i, t);
  return bn[e] = bm(n, r, t), bn[e];
}
function hx({
  template: i,
  bits: t
}) {
  const e = xm(i, t);
  return bn[e] || (bn[e] = bm(i.vertex, i.fragment, t)), bn[e];
}
function cx(i, t) {
  const e = t.map((o) => o.vertex).filter((o) => !!o), n = t.map((o) => o.fragment).filter((o) => !!o);
  let r = Ld(e, i.vertex, !0);
  r = ox(e, r);
  const s = Ld(n, i.fragment, !0);
  return {
    vertex: r,
    fragment: s
  };
}
function xm(i, t) {
  return t.map((e) => (Dl.has(e) || Dl.set(e, ax++), Dl.get(e))).sort((e, n) => e - n).join("-") + i.vertex + i.fragment;
}
function bm(i, t, e) {
  const n = Vd(i), r = Vd(t);
  return e.forEach((s) => {
    Bd(s.vertex, n, s.name), Bd(s.fragment, r, s.name);
  }), {
    vertex: Ud(i, n),
    fragment: Ud(t, r)
  };
}
const ux = (
  /* wgsl */
  `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`
), dx = (
  /* wgsl */
  `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`
), px = (
  /* glsl */
  `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`
), fx = (
  /* glsl */
  `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
        
        {{end}}
    }
`
), mx = {
  name: "global-uniforms-bit",
  vertex: {
    header: (
      /* wgsl */
      `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
    )
  }
}, gx = {
  name: "global-uniforms-bit",
  vertex: {
    header: (
      /* glsl */
      `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
    )
  }
};
function yx({ bits: i, name: t }) {
  const e = lx({
    template: {
      fragment: dx,
      vertex: ux
    },
    bits: [
      mx,
      ...i
    ]
  });
  return Pa.from({
    name: t,
    vertex: {
      source: e.vertex,
      entryPoint: "main"
    },
    fragment: {
      source: e.fragment,
      entryPoint: "main"
    }
  });
}
function vx({ bits: i, name: t }) {
  return new Jf({
    name: t,
    ...hx({
      template: {
        vertex: px,
        fragment: fx
      },
      bits: [
        gx,
        ...i
      ]
    })
  });
}
const _x = {
  name: "color-bit",
  vertex: {
    header: (
      /* wgsl */
      `
            @in aColor: vec4<f32>;
        `
    ),
    main: (
      /* wgsl */
      `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
    )
  }
}, xx = {
  name: "color-bit",
  vertex: {
    header: (
      /* glsl */
      `
            in vec4 aColor;
        `
    ),
    main: (
      /* glsl */
      `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
    )
  }
}, Bl = {};
function bx(i) {
  const t = [];
  if (i === 1)
    t.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"), t.push("@group(1) @binding(1) var textureSampler1: sampler;");
  else {
    let e = 0;
    for (let n = 0; n < i; n++)
      t.push(`@group(1) @binding(${e++}) var textureSource${n + 1}: texture_2d<f32>;`), t.push(`@group(1) @binding(${e++}) var textureSampler${n + 1}: sampler;`);
  }
  return t.join(`
`);
}
function wx(i) {
  const t = [];
  if (i === 1)
    t.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
  else {
    t.push("switch vTextureId {");
    for (let e = 0; e < i; e++)
      e === i - 1 ? t.push("  default:{") : t.push(`  case ${e}:{`), t.push(`      outColor = textureSampleGrad(textureSource${e + 1}, textureSampler${e + 1}, vUV, uvDx, uvDy);`), t.push("      break;}");
    t.push("}");
  }
  return t.join(`
`);
}
function Ax(i) {
  return Bl[i] || (Bl[i] = {
    name: "texture-batch-bit",
    vertex: {
      header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
      main: `
                vTextureId = aTextureIdAndRound.y;
            `,
      end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
    },
    fragment: {
      header: `
                @in @interpolate(flat) vTextureId: u32;

                ${bx(i)}
            `,
      main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${wx(i)}
            `
    }
  }), Bl[i];
}
const Vl = {};
function Sx(i) {
  const t = [];
  for (let e = 0; e < i; e++)
    e > 0 && t.push("else"), e < i - 1 && t.push(`if(vTextureId < ${e}.5)`), t.push("{"), t.push(`	outColor = texture(uTextures[${e}], vUV);`), t.push("}");
  return t.join(`
`);
}
function Tx(i) {
  return Vl[i] || (Vl[i] = {
    name: "texture-batch-bit",
    vertex: {
      header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
      main: `
                vTextureId = aTextureIdAndRound.y;
            `,
      end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
    },
    fragment: {
      header: `
                in float vTextureId;

                uniform sampler2D uTextures[${i}];

            `,
      main: `

                ${Sx(i)}
            `
    }
  }), Vl[i];
}
const Ex = {
  name: "round-pixels-bit",
  vertex: {
    header: (
      /* wgsl */
      `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    )
  }
}, Cx = {
  name: "round-pixels-bit",
  vertex: {
    header: (
      /* glsl */
      `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    )
  }
}, zd = {};
function Px(i) {
  let t = zd[i];
  if (t)
    return t;
  const e = new Int32Array(i);
  for (let n = 0; n < i; n++)
    e[n] = n;
  return t = zd[i] = new em({
    uTextures: { value: e, type: "i32", size: i }
  }, { isStatic: !0 }), t;
}
class Ix extends fc {
  constructor(t) {
    const e = vx({
      name: "batch",
      bits: [
        xx,
        Tx(t),
        Cx
      ]
    }), n = yx({
      name: "batch",
      bits: [
        _x,
        Ax(t),
        Ex
      ]
    });
    super({
      glProgram: e,
      gpuProgram: n,
      resources: {
        batchSamplers: Px(t)
      }
    });
  }
}
let jd = null;
const wm = class Am extends Q_ {
  constructor() {
    super(...arguments), this.geometry = new ix(), this.shader = jd || (jd = new Ix(this.maxTextures)), this.name = Am.extension.name, this.vertexSize = 6;
  }
  /**
   * Packs the attributes of a DefaultBatchableMeshElement into the provided views.
   * @param element - The DefaultBatchableMeshElement to pack.
   * @param float32View - The Float32Array view to pack into.
   * @param uint32View - The Uint32Array view to pack into.
   * @param index - The starting index in the views.
   * @param textureId - The texture ID to use.
   */
  packAttributes(t, e, n, r, s) {
    const o = s << 16 | t.roundPixels & 65535, a = t.transform, l = a.a, h = a.b, c = a.c, p = a.d, f = a.tx, d = a.ty, { positions: m, uvs: g } = t, y = t.color, b = t.attributeOffset, S = b + t.attributeSize;
    for (let C = b; C < S; C++) {
      const I = C * 2, T = m[I], R = m[I + 1];
      e[r++] = l * T + c * R + f, e[r++] = p * R + h * T + d, e[r++] = g[I], e[r++] = g[I + 1], n[r++] = y, n[r++] = o;
    }
  }
  /**
   * Packs the attributes of a DefaultBatchableQuadElement into the provided views.
   * @param element - The DefaultBatchableQuadElement to pack.
   * @param float32View - The Float32Array view to pack into.
   * @param uint32View - The Uint32Array view to pack into.
   * @param index - The starting index in the views.
   * @param textureId - The texture ID to use.
   */
  packQuadAttributes(t, e, n, r, s) {
    const o = t.texture, a = t.transform, l = a.a, h = a.b, c = a.c, p = a.d, f = a.tx, d = a.ty, m = t.bounds, g = m.maxX, y = m.minX, b = m.maxY, S = m.minY, C = o.uvs, I = t.color, T = s << 16 | t.roundPixels & 65535;
    e[r + 0] = l * y + c * S + f, e[r + 1] = p * S + h * y + d, e[r + 2] = C.x0, e[r + 3] = C.y0, n[r + 4] = I, n[r + 5] = T, e[r + 6] = l * g + c * S + f, e[r + 7] = p * S + h * g + d, e[r + 8] = C.x1, e[r + 9] = C.y1, n[r + 10] = I, n[r + 11] = T, e[r + 12] = l * g + c * b + f, e[r + 13] = p * b + h * g + d, e[r + 14] = C.x2, e[r + 15] = C.y2, n[r + 16] = I, n[r + 17] = T, e[r + 18] = l * y + c * b + f, e[r + 19] = p * b + h * y + d, e[r + 20] = C.x3, e[r + 21] = C.y3, n[r + 22] = I, n[r + 23] = T;
  }
};
wm.extension = {
  type: [
    X.Batcher
  ],
  name: "default"
};
let Rx = wm;
function kx(i, t, e, n, r, s, o, a = null) {
  let l = 0;
  e *= t, r *= s;
  const h = a.a, c = a.b, p = a.c, f = a.d, d = a.tx, m = a.ty;
  for (; l < o; ) {
    const g = i[e], y = i[e + 1];
    n[r] = h * g + p * y + d, n[r + 1] = c * g + f * y + m, r += s, e += t, l++;
  }
}
function Mx(i, t, e, n) {
  let r = 0;
  for (t *= e; r < n; )
    i[t] = 0, i[t + 1] = 0, t += e, r++;
}
function Sm(i, t, e, n, r) {
  const s = t.a, o = t.b, a = t.c, l = t.d, h = t.tx, c = t.ty;
  e = e || 0, n = n || 2, r = r || i.length / n - e;
  let p = e * n;
  for (let f = 0; f < r; f++) {
    const d = i[p], m = i[p + 1];
    i[p] = s * d + a * m + h, i[p + 1] = o * d + l * m + c, p += n;
  }
}
function Ox(i, t) {
  if (i === 16777215 || !t)
    return t;
  if (t === 16777215 || !i)
    return i;
  const e = i >> 16 & 255, n = i >> 8 & 255, r = i & 255, s = t >> 16 & 255, o = t >> 8 & 255, a = t & 255, l = e * s / 255, h = n * o / 255, c = r * a / 255;
  return (l << 16) + (h << 8) + c;
}
const Dx = new ct();
class Tm {
  constructor() {
    this.packAsQuad = !1, this.batcherName = "default", this.applyTransform = !0, this.roundPixels = 0, this._batcher = null, this._batch = null;
  }
  get uvs() {
    return this.geometryData.uvs;
  }
  get positions() {
    return this.geometryData.vertices;
  }
  get indices() {
    return this.geometryData.indices;
  }
  get blendMode() {
    return this.applyTransform ? this.renderable.groupBlendMode : "normal";
  }
  get color() {
    const t = this.baseColor, e = t >> 16 | t & 65280 | (t & 255) << 16, n = this.renderable;
    return n ? Ox(e, n.groupColor) + (this.alpha * n.groupAlpha * 255 << 24) : e + (this.alpha * 255 << 24);
  }
  get transform() {
    var t;
    return ((t = this.renderable) == null ? void 0 : t.groupTransform) || Dx;
  }
  copyTo(t) {
    t.indexOffset = this.indexOffset, t.indexSize = this.indexSize, t.attributeOffset = this.attributeOffset, t.attributeSize = this.attributeSize, t.baseColor = this.baseColor, t.alpha = this.alpha, t.texture = this.texture, t.geometryData = this.geometryData;
  }
  reset() {
    this.applyTransform = !0, this.renderable = null;
  }
}
const Ms = {
  extension: {
    type: X.ShapeBuilder,
    name: "circle"
  },
  build(i, t) {
    let e, n, r, s, o, a;
    if (i.type === "circle") {
      const I = i;
      e = I.x, n = I.y, o = a = I.radius, r = s = 0;
    } else if (i.type === "ellipse") {
      const I = i;
      e = I.x, n = I.y, o = I.halfWidth, a = I.halfHeight, r = s = 0;
    } else {
      const I = i, T = I.width / 2, R = I.height / 2;
      e = I.x + T, n = I.y + R, o = a = Math.max(0, Math.min(I.radius, Math.min(T, R))), r = T - o, s = R - a;
    }
    if (!(o >= 0 && a >= 0 && r >= 0 && s >= 0))
      return t;
    const l = Math.ceil(2.3 * Math.sqrt(o + a)), h = l * 8 + (r ? 4 : 0) + (s ? 4 : 0);
    if (h === 0)
      return t;
    if (l === 0)
      return t[0] = t[6] = e + r, t[1] = t[3] = n + s, t[2] = t[4] = e - r, t[5] = t[7] = n - s, t;
    let c = 0, p = l * 4 + (r ? 2 : 0) + 2, f = p, d = h, m = r + o, g = s, y = e + m, b = e - m, S = n + g;
    if (t[c++] = y, t[c++] = S, t[--p] = S, t[--p] = b, s) {
      const I = n - g;
      t[f++] = b, t[f++] = I, t[--d] = I, t[--d] = y;
    }
    for (let I = 1; I < l; I++) {
      const T = Math.PI / 2 * (I / l), R = r + Math.cos(T) * o, w = s + Math.sin(T) * a, v = e + R, x = e - R, A = n + w, P = n - w;
      t[c++] = v, t[c++] = A, t[--p] = A, t[--p] = x, t[f++] = x, t[f++] = P, t[--d] = P, t[--d] = v;
    }
    m = r, g = s + a, y = e + m, b = e - m, S = n + g;
    const C = n - g;
    return t[c++] = y, t[c++] = S, t[--d] = C, t[--d] = y, r && (t[c++] = b, t[c++] = S, t[--d] = C, t[--d] = b), t;
  },
  triangulate(i, t, e, n, r, s) {
    if (i.length === 0)
      return;
    let o = 0, a = 0;
    for (let c = 0; c < i.length; c += 2)
      o += i[c], a += i[c + 1];
    o /= i.length / 2, a /= i.length / 2;
    let l = n;
    t[l * e] = o, t[l * e + 1] = a;
    const h = l++;
    for (let c = 0; c < i.length; c += 2)
      t[l * e] = i[c], t[l * e + 1] = i[c + 1], c > 0 && (r[s++] = l, r[s++] = h, r[s++] = l - 1), l++;
    r[s++] = h + 1, r[s++] = h, r[s++] = l - 1;
  }
}, Bx = { ...Ms, extension: { ...Ms.extension, name: "ellipse" } }, Vx = { ...Ms, extension: { ...Ms.extension, name: "roundedRectangle" } }, Fx = 1e-4, Gd = 1e-4;
function Lx(i) {
  const t = i.length;
  if (t < 6)
    return 1;
  let e = 0;
  for (let n = 0, r = i[t - 2], s = i[t - 1]; n < t; n += 2) {
    const o = i[n], a = i[n + 1];
    e += (o - r) * (a + s), r = o, s = a;
  }
  return e < 0 ? -1 : 1;
}
function Hd(i, t, e, n, r, s, o, a) {
  const l = i - e * r, h = t - n * r, c = i + e * s, p = t + n * s;
  let f, d;
  o ? (f = n, d = -e) : (f = -n, d = e);
  const m = l + f, g = h + d, y = c + f, b = p + d;
  return a.push(m, g), a.push(y, b), 2;
}
function un(i, t, e, n, r, s, o, a) {
  const l = e - i, h = n - t;
  let c = Math.atan2(l, h), p = Math.atan2(r - i, s - t);
  a && c < p ? c += Math.PI * 2 : !a && c > p && (p += Math.PI * 2);
  let f = c;
  const d = p - c, m = Math.abs(d), g = Math.sqrt(l * l + h * h), y = (15 * m * Math.sqrt(g) / Math.PI >> 0) + 1, b = d / y;
  if (f += b, a) {
    o.push(i, t), o.push(e, n);
    for (let S = 1, C = f; S < y; S++, C += b)
      o.push(i, t), o.push(
        i + Math.sin(C) * g,
        t + Math.cos(C) * g
      );
    o.push(i, t), o.push(r, s);
  } else {
    o.push(e, n), o.push(i, t);
    for (let S = 1, C = f; S < y; S++, C += b)
      o.push(
        i + Math.sin(C) * g,
        t + Math.cos(C) * g
      ), o.push(i, t);
    o.push(r, s), o.push(i, t);
  }
  return y * 2;
}
function Nx(i, t, e, n, r, s, o, a, l) {
  const h = Fx;
  if (i.length === 0)
    return;
  const c = t;
  let p = c.alignment;
  if (t.alignment !== 0.5) {
    let Q = Lx(i);
    p = (p - 0.5) * Q + 0.5;
  }
  const f = new me(i[0], i[1]), d = new me(i[i.length - 2], i[i.length - 1]), m = n, g = Math.abs(f.x - d.x) < h && Math.abs(f.y - d.y) < h;
  if (m) {
    i = i.slice(), g && (i.pop(), i.pop(), d.set(i[i.length - 2], i[i.length - 1]));
    const Q = (f.x + d.x) * 0.5, J = (d.y + f.y) * 0.5;
    i.unshift(Q, J), i.push(Q, J);
  }
  const y = r, b = i.length / 2;
  let S = i.length;
  const C = y.length / 2, I = c.width / 2, T = I * I, R = c.miterLimit * c.miterLimit;
  let w = i[0], v = i[1], x = i[2], A = i[3], P = 0, M = 0, k = -(v - A), B = w - x, V = 0, N = 0, U = Math.sqrt(k * k + B * B);
  k /= U, B /= U, k *= I, B *= I;
  const K = p, j = (1 - K) * 2, H = K * 2;
  m || (c.cap === "round" ? S += un(
    w - k * (j - H) * 0.5,
    v - B * (j - H) * 0.5,
    w - k * j,
    v - B * j,
    w + k * H,
    v + B * H,
    y,
    !0
  ) + 2 : c.cap === "square" && (S += Hd(w, v, k, B, j, H, !0, y))), y.push(
    w - k * j,
    v - B * j
  ), y.push(
    w + k * H,
    v + B * H
  );
  for (let Q = 1; Q < b - 1; ++Q) {
    w = i[(Q - 1) * 2], v = i[(Q - 1) * 2 + 1], x = i[Q * 2], A = i[Q * 2 + 1], P = i[(Q + 1) * 2], M = i[(Q + 1) * 2 + 1], k = -(v - A), B = w - x, U = Math.sqrt(k * k + B * B), k /= U, B /= U, k *= I, B *= I, V = -(A - M), N = x - P, U = Math.sqrt(V * V + N * N), V /= U, N /= U, V *= I, N *= I;
    const J = x - w, bt = v - A, St = x - P, $ = M - A, Ht = J * St + bt * $, Tt = bt * St - $ * J, Fe = Tt < 0;
    if (Math.abs(Tt) < 1e-3 * Math.abs(Ht)) {
      y.push(
        x - k * j,
        A - B * j
      ), y.push(
        x + k * H,
        A + B * H
      ), Ht >= 0 && (c.join === "round" ? S += un(
        x,
        A,
        x - k * j,
        A - B * j,
        x - V * j,
        A - N * j,
        y,
        !1
      ) + 4 : S += 2, y.push(
        x - V * H,
        A - N * H
      ), y.push(
        x + V * j,
        A + N * j
      ));
      continue;
    }
    const Yt = (-k + w) * (-B + A) - (-k + x) * (-B + v), Xt = (-V + P) * (-N + A) - (-V + x) * (-N + M), Et = (J * Xt - St * Yt) / Tt, ci = ($ * Yt - bt * Xt) / Tt, wi = (Et - x) * (Et - x) + (ci - A) * (ci - A), Le = x + (Et - x) * j, Ne = A + (ci - A) * j, Xe = x - (Et - x) * H, Ue = A - (ci - A) * H, Ee = Math.min(J * J + bt * bt, St * St + $ * $), Ai = Fe ? j : H, Ni = Ee + Ai * Ai * T;
    wi <= Ni ? c.join === "bevel" || wi / T > R ? (Fe ? (y.push(Le, Ne), y.push(x + k * H, A + B * H), y.push(Le, Ne), y.push(x + V * H, A + N * H)) : (y.push(x - k * j, A - B * j), y.push(Xe, Ue), y.push(x - V * j, A - N * j), y.push(Xe, Ue)), S += 2) : c.join === "round" ? Fe ? (y.push(Le, Ne), y.push(x + k * H, A + B * H), S += un(
      x,
      A,
      x + k * H,
      A + B * H,
      x + V * H,
      A + N * H,
      y,
      !0
    ) + 4, y.push(Le, Ne), y.push(x + V * H, A + N * H)) : (y.push(x - k * j, A - B * j), y.push(Xe, Ue), S += un(
      x,
      A,
      x - k * j,
      A - B * j,
      x - V * j,
      A - N * j,
      y,
      !1
    ) + 4, y.push(x - V * j, A - N * j), y.push(Xe, Ue)) : (y.push(Le, Ne), y.push(Xe, Ue)) : (y.push(x - k * j, A - B * j), y.push(x + k * H, A + B * H), c.join === "round" ? Fe ? S += un(
      x,
      A,
      x + k * H,
      A + B * H,
      x + V * H,
      A + N * H,
      y,
      !0
    ) + 2 : S += un(
      x,
      A,
      x - k * j,
      A - B * j,
      x - V * j,
      A - N * j,
      y,
      !1
    ) + 2 : c.join === "miter" && wi / T <= R && (Fe ? (y.push(Xe, Ue), y.push(Xe, Ue)) : (y.push(Le, Ne), y.push(Le, Ne)), S += 2), y.push(x - V * j, A - N * j), y.push(x + V * H, A + N * H), S += 2);
  }
  w = i[(b - 2) * 2], v = i[(b - 2) * 2 + 1], x = i[(b - 1) * 2], A = i[(b - 1) * 2 + 1], k = -(v - A), B = w - x, U = Math.sqrt(k * k + B * B), k /= U, B /= U, k *= I, B *= I, y.push(x - k * j, A - B * j), y.push(x + k * H, A + B * H), m || (c.cap === "round" ? S += un(
    x - k * (j - H) * 0.5,
    A - B * (j - H) * 0.5,
    x - k * j,
    A - B * j,
    x + k * H,
    A + B * H,
    y,
    !1
  ) + 2 : c.cap === "square" && (S += Hd(x, A, k, B, j, H, !1, y)));
  const pt = Gd * Gd;
  for (let Q = C; Q < S + C - 2; ++Q)
    w = y[Q * 2], v = y[Q * 2 + 1], x = y[(Q + 1) * 2], A = y[(Q + 1) * 2 + 1], P = y[(Q + 2) * 2], M = y[(Q + 2) * 2 + 1], !(Math.abs(w * (A - M) + x * (M - v) + P * (v - A)) < pt) && a.push(Q, Q + 1, Q + 2);
}
function Em(i, t, e, n, r, s, o) {
  const a = E_(i, t, 2);
  if (!a)
    return;
  for (let h = 0; h < a.length; h += 3)
    s[o++] = a[h] + r, s[o++] = a[h + 1] + r, s[o++] = a[h + 2] + r;
  let l = r * n;
  for (let h = 0; h < i.length; h += 2)
    e[l] = i[h], e[l + 1] = i[h + 1], l += n;
}
const Ux = [], zx = {
  extension: {
    type: X.ShapeBuilder,
    name: "polygon"
  },
  build(i, t) {
    for (let e = 0; e < i.points.length; e++)
      t[e] = i.points[e];
    return t;
  },
  triangulate(i, t, e, n, r, s) {
    Em(i, Ux, t, e, n, r, s);
  }
}, jx = {
  extension: {
    type: X.ShapeBuilder,
    name: "rectangle"
  },
  build(i, t) {
    const e = i, n = e.x, r = e.y, s = e.width, o = e.height;
    return s >= 0 && o >= 0 && (t[0] = n, t[1] = r, t[2] = n + s, t[3] = r, t[4] = n + s, t[5] = r + o, t[6] = n, t[7] = r + o), t;
  },
  triangulate(i, t, e, n, r, s) {
    let o = 0;
    n *= e, t[n + o] = i[0], t[n + o + 1] = i[1], o += e, t[n + o] = i[2], t[n + o + 1] = i[3], o += e, t[n + o] = i[6], t[n + o + 1] = i[7], o += e, t[n + o] = i[4], t[n + o + 1] = i[5], o += e;
    const a = n / e;
    r[s++] = a, r[s++] = a + 1, r[s++] = a + 2, r[s++] = a + 1, r[s++] = a + 3, r[s++] = a + 2;
  }
}, Gx = {
  extension: {
    type: X.ShapeBuilder,
    name: "triangle"
  },
  build(i, t) {
    return t[0] = i.x, t[1] = i.y, t[2] = i.x2, t[3] = i.y2, t[4] = i.x3, t[5] = i.y3, t;
  },
  triangulate(i, t, e, n, r, s) {
    let o = 0;
    n *= e, t[n + o] = i[0], t[n + o + 1] = i[1], o += e, t[n + o] = i[2], t[n + o + 1] = i[3], o += e, t[n + o] = i[4], t[n + o + 1] = i[5];
    const a = n / e;
    r[s++] = a, r[s++] = a + 1, r[s++] = a + 2;
  }
}, Da = {};
ge.handleByMap(X.ShapeBuilder, Da);
ge.add(jx, zx, Gx, Ms, Bx, Vx);
const Hx = new jt();
function Wx(i, t) {
  const { geometryData: e, batches: n } = t;
  n.length = 0, e.indices.length = 0, e.vertices.length = 0, e.uvs.length = 0;
  for (let r = 0; r < i.instructions.length; r++) {
    const s = i.instructions[r];
    if (s.action === "texture")
      qx(s.data, n, e);
    else if (s.action === "fill" || s.action === "stroke") {
      const o = s.action === "stroke", a = s.data.path.shapePath, l = s.data.style, h = s.data.hole;
      o && h && Wd(h.shapePath, l, null, !0, n, e), Wd(a, l, h, o, n, e);
    }
  }
}
function qx(i, t, e) {
  const { vertices: n, uvs: r, indices: s } = e, o = s.length, a = n.length / 2, l = [], h = Da.rectangle, c = Hx, p = i.image;
  c.x = i.dx, c.y = i.dy, c.width = i.dw, c.height = i.dh;
  const f = i.transform;
  h.build(c, l), f && Sm(l, f), h.triangulate(l, n, 2, a, s, o);
  const d = p.uvs;
  r.push(
    d.x0,
    d.y0,
    d.x1,
    d.y1,
    d.x3,
    d.y3,
    d.x2,
    d.y2
  );
  const m = Ri.get(Tm);
  m.indexOffset = o, m.indexSize = s.length - o, m.attributeOffset = a, m.attributeSize = n.length / 2 - a, m.baseColor = i.style, m.alpha = i.alpha, m.texture = p, m.geometryData = e, t.push(m);
}
function Wd(i, t, e, n, r, s) {
  const { vertices: o, uvs: a, indices: l } = s, h = i.shapePrimitives.length - 1;
  i.shapePrimitives.forEach(({ shape: c, transform: p }, f) => {
    const d = l.length, m = o.length / 2, g = [], y = Da[c.type];
    if (y.build(c, g), p && Sm(g, p), n) {
      const I = c.closePath ?? !0;
      Nx(g, t, !1, I, o, 2, m, l);
    } else if (e && h === f) {
      h !== 0 && console.warn("[Pixi Graphics] only the last shape have be cut out");
      const I = [], T = g.slice();
      Yx(e.shapePath).forEach((R) => {
        I.push(T.length / 2), T.push(...R);
      }), Em(T, I, o, 2, m, l, d);
    } else
      y.triangulate(g, o, 2, m, l, d);
    const b = a.length / 2, S = t.texture;
    if (S !== nt.WHITE) {
      const I = t.matrix;
      I && (p && I.append(p.clone().invert()), kx(o, 2, m, a, b, 2, o.length / 2 - m, I));
    } else
      Mx(a, b, 2, o.length / 2 - m);
    const C = Ri.get(Tm);
    C.indexOffset = d, C.indexSize = l.length - d, C.attributeOffset = m, C.attributeSize = o.length / 2 - m, C.baseColor = t.color, C.alpha = t.alpha, C.texture = S, C.geometryData = s, r.push(C);
  });
}
function Yx(i) {
  if (!i)
    return [];
  const t = i.shapePrimitives, e = [];
  for (let n = 0; n < t.length; n++) {
    const r = t[n].shape, s = [];
    Da[r.type].build(r, s), e.push(s);
  }
  return e;
}
class Xx {
  constructor() {
    this.batches = [], this.geometryData = {
      vertices: [],
      uvs: [],
      indices: []
    };
  }
}
class Kx {
  constructor() {
    this.batcher = new Rx(), this.instructions = new Df();
  }
  init() {
    this.instructions.reset();
  }
  /**
   * @deprecated since version 8.0.0
   * Use `batcher.geometry` instead.
   * @see {Batcher#geometry}
   */
  get geometry() {
    return ut(iv, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."), this.batcher.geometry;
  }
}
const yc = class wh {
  constructor(t) {
    this._gpuContextHash = {}, this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null), t.renderableGC.addManagedHash(this, "_gpuContextHash"), t.renderableGC.addManagedHash(this, "_graphicsDataContextHash");
  }
  /**
   * Runner init called, update the default options
   * @ignore
   */
  init(t) {
    wh.defaultOptions.bezierSmoothness = (t == null ? void 0 : t.bezierSmoothness) ?? wh.defaultOptions.bezierSmoothness;
  }
  getContextRenderData(t) {
    return this._graphicsDataContextHash[t.uid] || this._initContextRenderData(t);
  }
  // Context management functions
  updateGpuContext(t) {
    let e = this._gpuContextHash[t.uid] || this._initContext(t);
    if (t.dirty) {
      e ? this._cleanGraphicsContextData(t) : e = this._initContext(t), Wx(t, e);
      const n = t.batchMode;
      t.customShader || n === "no-batch" ? e.isBatchable = !1 : n === "auto" && (e.isBatchable = e.geometryData.vertices.length < 400), t.dirty = !1;
    }
    return e;
  }
  getGpuContext(t) {
    return this._gpuContextHash[t.uid] || this._initContext(t);
  }
  _initContextRenderData(t) {
    const e = Ri.get(Kx), { batches: n, geometryData: r } = this._gpuContextHash[t.uid], s = r.vertices.length, o = r.indices.length;
    for (let c = 0; c < n.length; c++)
      n[c].applyTransform = !1;
    const a = e.batcher;
    a.ensureAttributeBuffer(s), a.ensureIndexBuffer(o), a.begin();
    for (let c = 0; c < n.length; c++) {
      const p = n[c];
      a.add(p);
    }
    a.finish(e.instructions);
    const l = a.geometry;
    l.indexBuffer.setDataWithSize(a.indexBuffer, a.indexSize, !0), l.buffers[0].setDataWithSize(a.attributeBuffer.float32View, a.attributeSize, !0);
    const h = a.batches;
    for (let c = 0; c < h.length; c++) {
      const p = h[c];
      p.bindGroup = H_(p.textures.textures, p.textures.count);
    }
    return this._graphicsDataContextHash[t.uid] = e, e;
  }
  _initContext(t) {
    const e = new Xx();
    return e.context = t, this._gpuContextHash[t.uid] = e, t.on("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[t.uid];
  }
  onGraphicsContextDestroy(t) {
    this._cleanGraphicsContextData(t), t.off("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[t.uid] = null;
  }
  _cleanGraphicsContextData(t) {
    const e = this._gpuContextHash[t.uid];
    e.isBatchable || this._graphicsDataContextHash[t.uid] && (Ri.return(this.getContextRenderData(t)), this._graphicsDataContextHash[t.uid] = null), e.batches && e.batches.forEach((n) => {
      Ri.return(n);
    });
  }
  destroy() {
    for (const t in this._gpuContextHash)
      this._gpuContextHash[t] && this.onGraphicsContextDestroy(this._gpuContextHash[t].context);
  }
};
yc.extension = {
  type: [
    X.WebGLSystem,
    X.WebGPUSystem,
    X.CanvasSystem
  ],
  name: "graphicsContext"
};
yc.defaultOptions = {
  /**
   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)
   * @default 0.5
   */
  bezierSmoothness: 0.5
};
let Cm = yc;
const Qx = 8, Co = 11920929e-14, Jx = 1;
function Pm(i, t, e, n, r, s, o, a, l, h) {
  const c = Math.min(
    0.99,
    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
    Math.max(0, h ?? Cm.defaultOptions.bezierSmoothness)
  );
  let p = (Jx - c) / 1;
  return p *= p, Zx(t, e, n, r, s, o, a, l, i, p), i;
}
function Zx(i, t, e, n, r, s, o, a, l, h) {
  Ah(i, t, e, n, r, s, o, a, l, h, 0), l.push(o, a);
}
function Ah(i, t, e, n, r, s, o, a, l, h, c) {
  if (c > Qx)
    return;
  const p = (i + e) / 2, f = (t + n) / 2, d = (e + r) / 2, m = (n + s) / 2, g = (r + o) / 2, y = (s + a) / 2, b = (p + d) / 2, S = (f + m) / 2, C = (d + g) / 2, I = (m + y) / 2, T = (b + C) / 2, R = (S + I) / 2;
  if (c > 0) {
    let w = o - i, v = a - t;
    const x = Math.abs((e - o) * v - (n - a) * w), A = Math.abs((r - o) * v - (s - a) * w);
    if (x > Co && A > Co) {
      if ((x + A) * (x + A) <= h * (w * w + v * v)) {
        l.push(T, R);
        return;
      }
    } else if (x > Co) {
      if (x * x <= h * (w * w + v * v)) {
        l.push(T, R);
        return;
      }
    } else if (A > Co) {
      if (A * A <= h * (w * w + v * v)) {
        l.push(T, R);
        return;
      }
    } else if (w = T - (i + o) / 2, v = R - (t + a) / 2, w * w + v * v <= h) {
      l.push(T, R);
      return;
    }
  }
  Ah(i, t, p, f, b, S, T, R, l, h, c + 1), Ah(T, R, C, I, g, y, o, a, l, h, c + 1);
}
const $x = 8, tb = 11920929e-14, eb = 1;
function ib(i, t, e, n, r, s, o, a) {
  const l = Math.min(
    0.99,
    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
    Math.max(0, a ?? Cm.defaultOptions.bezierSmoothness)
  );
  let h = (eb - l) / 1;
  return h *= h, nb(t, e, n, r, s, o, i, h), i;
}
function nb(i, t, e, n, r, s, o, a) {
  Sh(o, i, t, e, n, r, s, a, 0), o.push(r, s);
}
function Sh(i, t, e, n, r, s, o, a, l) {
  if (l > $x)
    return;
  const h = (t + n) / 2, c = (e + r) / 2, p = (n + s) / 2, f = (r + o) / 2, d = (h + p) / 2, m = (c + f) / 2;
  let g = s - t, y = o - e;
  const b = Math.abs((n - s) * y - (r - o) * g);
  if (b > tb) {
    if (b * b <= a * (g * g + y * y)) {
      i.push(d, m);
      return;
    }
  } else if (g = d - (t + s) / 2, y = m - (e + o) / 2, g * g + y * y <= a) {
    i.push(d, m);
    return;
  }
  Sh(i, t, e, h, c, d, m, a, l + 1), Sh(i, d, m, p, f, s, o, a, l + 1);
}
function Im(i, t, e, n, r, s, o, a) {
  let l = Math.abs(r - s);
  (!o && r > s || o && s > r) && (l = 2 * Math.PI - l), a = a || Math.max(6, Math.floor(6 * Math.pow(n, 1 / 3) * (l / Math.PI))), a = Math.max(a, 3);
  let h = l / a, c = r;
  h *= o ? -1 : 1;
  for (let p = 0; p < a + 1; p++) {
    const f = Math.cos(c), d = Math.sin(c), m = t + f * n, g = e + d * n;
    i.push(m, g), c += h;
  }
}
function rb(i, t, e, n, r, s) {
  const o = i[i.length - 2], a = i[i.length - 1] - e, l = o - t, h = r - e, c = n - t, p = Math.abs(a * c - l * h);
  if (p < 1e-8 || s === 0) {
    (i[i.length - 2] !== t || i[i.length - 1] !== e) && i.push(t, e);
    return;
  }
  const f = a * a + l * l, d = h * h + c * c, m = a * h + l * c, g = s * Math.sqrt(f) / p, y = s * Math.sqrt(d) / p, b = g * m / f, S = y * m / d, C = g * c + y * l, I = g * h + y * a, T = l * (y + b), R = a * (y + b), w = c * (g + S), v = h * (g + S), x = Math.atan2(R - I, T - C), A = Math.atan2(v - I, w - C);
  Im(
    i,
    C + t,
    I + e,
    s,
    x,
    A,
    l * h > c * a
  );
}
const ys = Math.PI * 2, Fl = {
  centerX: 0,
  centerY: 0,
  ang1: 0,
  ang2: 0
}, Ll = ({ x: i, y: t }, e, n, r, s, o, a, l) => {
  i *= e, t *= n;
  const h = r * i - s * t, c = s * i + r * t;
  return l.x = h + o, l.y = c + a, l;
};
function sb(i, t) {
  const e = t === -1.5707963267948966 ? -0.551915024494 : 1.3333333333333333 * Math.tan(t / 4), n = t === 1.5707963267948966 ? 0.551915024494 : e, r = Math.cos(i), s = Math.sin(i), o = Math.cos(i + t), a = Math.sin(i + t);
  return [
    {
      x: r - s * n,
      y: s + r * n
    },
    {
      x: o + a * n,
      y: a - o * n
    },
    {
      x: o,
      y: a
    }
  ];
}
const qd = (i, t, e, n) => {
  const r = i * n - t * e < 0 ? -1 : 1;
  let s = i * e + t * n;
  return s > 1 && (s = 1), s < -1 && (s = -1), r * Math.acos(s);
}, ob = (i, t, e, n, r, s, o, a, l, h, c, p, f) => {
  const d = Math.pow(r, 2), m = Math.pow(s, 2), g = Math.pow(c, 2), y = Math.pow(p, 2);
  let b = d * m - d * y - m * g;
  b < 0 && (b = 0), b /= d * y + m * g, b = Math.sqrt(b) * (o === a ? -1 : 1);
  const S = b * r / s * p, C = b * -s / r * c, I = h * S - l * C + (i + e) / 2, T = l * S + h * C + (t + n) / 2, R = (c - S) / r, w = (p - C) / s, v = (-c - S) / r, x = (-p - C) / s, A = qd(1, 0, R, w);
  let P = qd(R, w, v, x);
  a === 0 && P > 0 && (P -= ys), a === 1 && P < 0 && (P += ys), f.centerX = I, f.centerY = T, f.ang1 = A, f.ang2 = P;
};
function ab(i, t, e, n, r, s, o, a = 0, l = 0, h = 0) {
  if (s === 0 || o === 0)
    return;
  const c = Math.sin(a * ys / 360), p = Math.cos(a * ys / 360), f = p * (t - n) / 2 + c * (e - r) / 2, d = -c * (t - n) / 2 + p * (e - r) / 2;
  if (f === 0 && d === 0)
    return;
  s = Math.abs(s), o = Math.abs(o);
  const m = Math.pow(f, 2) / Math.pow(s, 2) + Math.pow(d, 2) / Math.pow(o, 2);
  m > 1 && (s *= Math.sqrt(m), o *= Math.sqrt(m)), ob(
    t,
    e,
    n,
    r,
    s,
    o,
    l,
    h,
    c,
    p,
    f,
    d,
    Fl
  );
  let { ang1: g, ang2: y } = Fl;
  const { centerX: b, centerY: S } = Fl;
  let C = Math.abs(y) / (ys / 4);
  Math.abs(1 - C) < 1e-7 && (C = 1);
  const I = Math.max(Math.ceil(C), 1);
  y /= I;
  let T = i[i.length - 2], R = i[i.length - 1];
  const w = { x: 0, y: 0 };
  for (let v = 0; v < I; v++) {
    const x = sb(g, y), { x: A, y: P } = Ll(x[0], s, o, p, c, b, S, w), { x: M, y: k } = Ll(x[1], s, o, p, c, b, S, w), { x: B, y: V } = Ll(x[2], s, o, p, c, b, S, w);
    Pm(
      i,
      T,
      R,
      A,
      P,
      M,
      k,
      B,
      V
    ), T = B, R = V, g += y;
  }
}
function lb(i, t, e) {
  const n = (o, a) => {
    const l = a.x - o.x, h = a.y - o.y, c = Math.sqrt(l * l + h * h), p = l / c, f = h / c;
    return { len: c, nx: p, ny: f };
  }, r = (o, a) => {
    o === 0 ? i.moveTo(a.x, a.y) : i.lineTo(a.x, a.y);
  };
  let s = t[t.length - 1];
  for (let o = 0; o < t.length; o++) {
    const a = t[o % t.length], l = a.radius ?? e;
    if (l <= 0) {
      r(o, a), s = a;
      continue;
    }
    const h = t[(o + 1) % t.length], c = n(a, s), p = n(a, h);
    if (c.len < 1e-4 || p.len < 1e-4) {
      r(o, a), s = a;
      continue;
    }
    let f = Math.asin(c.nx * p.ny - c.ny * p.nx), d = 1, m = !1;
    c.nx * p.nx - c.ny * -p.ny < 0 ? f < 0 ? f = Math.PI + f : (f = Math.PI - f, d = -1, m = !0) : f > 0 && (d = -1, m = !0);
    const g = f / 2;
    let y, b = Math.abs(
      Math.cos(g) * l / Math.sin(g)
    );
    b > Math.min(c.len / 2, p.len / 2) ? (b = Math.min(c.len / 2, p.len / 2), y = Math.abs(b * Math.sin(g) / Math.cos(g))) : y = l;
    const S = a.x + p.nx * b + -p.ny * y * d, C = a.y + p.ny * b + p.nx * y * d, I = Math.atan2(c.ny, c.nx) + Math.PI / 2 * d, T = Math.atan2(p.ny, p.nx) - Math.PI / 2 * d;
    o === 0 && i.moveTo(
      S + Math.cos(I) * y,
      C + Math.sin(I) * y
    ), i.arc(S, C, y, I, T, m), s = a;
  }
}
function hb(i, t, e, n) {
  const r = (a, l) => Math.sqrt((a.x - l.x) ** 2 + (a.y - l.y) ** 2), s = (a, l, h) => ({
    x: a.x + (l.x - a.x) * h,
    y: a.y + (l.y - a.y) * h
  }), o = t.length;
  for (let a = 0; a < o; a++) {
    const l = t[(a + 1) % o], h = l.radius ?? e;
    if (h <= 0) {
      a === 0 ? i.moveTo(l.x, l.y) : i.lineTo(l.x, l.y);
      continue;
    }
    const c = t[a], p = t[(a + 2) % o], f = r(c, l);
    let d;
    if (f < 1e-4)
      d = l;
    else {
      const y = Math.min(f / 2, h);
      d = s(
        l,
        c,
        y / f
      );
    }
    const m = r(p, l);
    let g;
    if (m < 1e-4)
      g = l;
    else {
      const y = Math.min(m / 2, h);
      g = s(
        l,
        p,
        y / m
      );
    }
    a === 0 ? i.moveTo(d.x, d.y) : i.lineTo(d.x, d.y), i.quadraticCurveTo(l.x, l.y, g.x, g.y, n);
  }
}
const cb = new jt();
class ub {
  constructor(t) {
    this.shapePrimitives = [], this._currentPoly = null, this._bounds = new Ji(), this._graphicsPath2D = t;
  }
  /**
   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
   * @param x - The x-coordinate for the starting point.
   * @param y - The y-coordinate for the starting point.
   * @returns The instance of the current object for chaining.
   */
  moveTo(t, e) {
    return this.startPoly(t, e), this;
  }
  /**
   * Connects the current point to a new point with a straight line. This method updates the current path.
   * @param x - The x-coordinate of the new point to connect to.
   * @param y - The y-coordinate of the new point to connect to.
   * @returns The instance of the current object for chaining.
   */
  lineTo(t, e) {
    this._ensurePoly();
    const n = this._currentPoly.points, r = n[n.length - 2], s = n[n.length - 1];
    return (r !== t || s !== e) && n.push(t, e), this;
  }
  /**
   * Adds an arc to the path. The arc is centered at (x, y)
   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.
   * @param x - The x-coordinate of the arc's center.
   * @param y - The y-coordinate of the arc's center.
   * @param radius - The radius of the arc.
   * @param startAngle - The starting angle of the arc, in radians.
   * @param endAngle - The ending angle of the arc, in radians.
   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.
   * @returns The instance of the current object for chaining.
   */
  arc(t, e, n, r, s, o) {
    this._ensurePoly(!1);
    const a = this._currentPoly.points;
    return Im(a, t, e, n, r, s, o), this;
  }
  /**
   * Adds an arc to the path with the arc tangent to the line joining two specified points.
   * The arc radius is specified by `radius`.
   * @param x1 - The x-coordinate of the first point.
   * @param y1 - The y-coordinate of the first point.
   * @param x2 - The x-coordinate of the second point.
   * @param y2 - The y-coordinate of the second point.
   * @param radius - The radius of the arc.
   * @returns The instance of the current object for chaining.
   */
  arcTo(t, e, n, r, s) {
    this._ensurePoly();
    const o = this._currentPoly.points;
    return rb(o, t, e, n, r, s), this;
  }
  /**
   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
   * @param rx - The x-radius of the ellipse.
   * @param ry - The y-radius of the ellipse.
   * @param xAxisRotation - The rotation of the ellipse's x-axis relative
   * to the x-axis of the coordinate system, in degrees.
   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
   * @param x - The x-coordinate of the arc's end point.
   * @param y - The y-coordinate of the arc's end point.
   * @returns The instance of the current object for chaining.
   */
  arcToSvg(t, e, n, r, s, o, a) {
    const l = this._currentPoly.points;
    return ab(
      l,
      this._currentPoly.lastX,
      this._currentPoly.lastY,
      o,
      a,
      t,
      e,
      n,
      r,
      s
    ), this;
  }
  /**
   * Adds a cubic Bezier curve to the path.
   * It requires three points: the first two are control points and the third one is the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the first control point.
   * @param cp1y - The y-coordinate of the first control point.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  bezierCurveTo(t, e, n, r, s, o, a) {
    this._ensurePoly();
    const l = this._currentPoly;
    return Pm(
      this._currentPoly.points,
      l.lastX,
      l.lastY,
      t,
      e,
      n,
      r,
      s,
      o,
      a
    ), this;
  }
  /**
   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the control point.
   * @param cp1y - The y-coordinate of the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothing - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  quadraticCurveTo(t, e, n, r, s) {
    this._ensurePoly();
    const o = this._currentPoly;
    return ib(
      this._currentPoly.points,
      o.lastX,
      o.lastY,
      t,
      e,
      n,
      r,
      s
    ), this;
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    return this.endPoly(!0), this;
  }
  /**
   * Adds another path to the current path. This method allows for the combination of multiple paths into one.
   * @param path - The `GraphicsPath` object representing the path to add.
   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.
   * @returns The instance of the current object for chaining.
   */
  addPath(t, e) {
    this.endPoly(), e && !e.isIdentity() && (t = t.clone(!0), t.transform(e));
    for (let n = 0; n < t.instructions.length; n++) {
      const r = t.instructions[n];
      this[r.action](...r.data);
    }
    return this;
  }
  /**
   * Finalizes the drawing of the current path. Optionally, it can close the path.
   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.
   */
  finish(t = !1) {
    this.endPoly(t);
  }
  /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */
  rect(t, e, n, r, s) {
    return this.drawShape(new jt(t, e, n, r), s), this;
  }
  /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @param transform - An optional `Matrix` object to apply a transformation to the circle.
   * @returns The instance of the current object for chaining.
   */
  circle(t, e, n, r) {
    return this.drawShape(new Ma(t, e, n), r), this;
  }
  /**
   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.
   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
   * representing the x and y coordinates of the polygon's vertices, in sequence.
   * @param close - A boolean indicating whether to close the polygon path. True by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */
  poly(t, e, n) {
    const r = new lr(t);
    return r.closePath = e, this.drawShape(r, n), this;
  }
  /**
   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */
  regularPoly(t, e, n, r, s = 0, o) {
    r = Math.max(r | 0, 3);
    const a = -1 * Math.PI / 2 + s, l = Math.PI * 2 / r, h = [];
    for (let c = 0; c < r; c++) {
      const p = c * l + a;
      h.push(
        t + n * Math.cos(p),
        e + n * Math.sin(p)
      );
    }
    return this.poly(h, !0, o), this;
  }
  /**
   * Draws a polygon with rounded corners.
   * Similar to `regularPoly` but with the ability to round the corners of the polygon.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param corner - The radius of the rounding of the corners.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.
   * @returns The instance of the current object for chaining.
   */
  roundPoly(t, e, n, r, s, o = 0, a) {
    if (r = Math.max(r | 0, 3), s <= 0)
      return this.regularPoly(t, e, n, r, o);
    const l = n * Math.sin(Math.PI / r) - 1e-3;
    s = Math.min(s, l);
    const h = -1 * Math.PI / 2 + o, c = Math.PI * 2 / r, p = (r - 2) * Math.PI / r / 2;
    for (let f = 0; f < r; f++) {
      const d = f * c + h, m = t + n * Math.cos(d), g = e + n * Math.sin(d), y = d + Math.PI + p, b = d - Math.PI - p, S = m + s * Math.cos(y), C = g + s * Math.sin(y), I = m + s * Math.cos(b), T = g + s * Math.sin(b);
      f === 0 ? this.moveTo(S, C) : this.lineTo(S, C), this.quadraticCurveTo(m, g, I, T, a);
    }
    return this.closePath();
  }
  /**
   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
   * A minimum of 3 points is required.
   * @param radius - The default radius for the corners.
   * This radius is applied to all corners unless overridden in `points`.
   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
   *  method instead of an arc method. Defaults to false.
   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
   * Higher values make the curve smoother.
   * @returns The instance of the current object for chaining.
   */
  roundShape(t, e, n = !1, r) {
    return t.length < 3 ? this : (n ? hb(this, t, e, r) : lb(this, t, e), this.closePath());
  }
  /**
   * Draw Rectangle with fillet corners. This is much like rounded rectangle
   * however it support negative numbers as well for the corner radius.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param fillet - accept negative or positive values
   */
  filletRect(t, e, n, r, s) {
    if (s === 0)
      return this.rect(t, e, n, r);
    const o = Math.min(n, r) / 2, a = Math.min(o, Math.max(-o, s)), l = t + n, h = e + r, c = a < 0 ? -a : 0, p = Math.abs(a);
    return this.moveTo(t, e + p).arcTo(t + c, e + c, t + p, e, p).lineTo(l - p, e).arcTo(l - c, e + c, l, e + p, p).lineTo(l, h - p).arcTo(l - c, h - c, t + n - p, h, p).lineTo(t + p, h).arcTo(t + c, h - c, t, h - p, p).closePath();
  }
  /**
   * Draw Rectangle with chamfer corners. These are angled corners.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param chamfer - non-zero real number, size of corner cutout
   * @param transform
   */
  chamferRect(t, e, n, r, s, o) {
    if (s <= 0)
      return this.rect(t, e, n, r);
    const a = Math.min(s, Math.min(n, r) / 2), l = t + n, h = e + r, c = [
      t + a,
      e,
      l - a,
      e,
      l,
      e + a,
      l,
      h - a,
      l - a,
      h,
      t + a,
      h,
      t,
      h - a,
      t,
      e + a
    ];
    for (let p = c.length - 1; p >= 2; p -= 2)
      c[p] === c[p - 2] && c[p - 1] === c[p - 3] && c.splice(p - 1, 2);
    return this.poly(c, !0, o);
  }
  /**
   * Draws an ellipse at the specified location and with the given x and y radii.
   * An optional transformation can be applied, allowing for rotation, scaling, and translation.
   * @param x - The x-coordinate of the center of the ellipse.
   * @param y - The y-coordinate of the center of the ellipse.
   * @param radiusX - The horizontal radius of the ellipse.
   * @param radiusY - The vertical radius of the ellipse.
   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.
   * @returns The instance of the current object for chaining.
   */
  ellipse(t, e, n, r, s) {
    return this.drawShape(new gc(t, e, n, r), s), this;
  }
  /**
   * Draws a rectangle with rounded corners.
   * The corner radius can be specified to determine how rounded the corners should be.
   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */
  roundRect(t, e, n, r, s, o) {
    return this.drawShape(new Oa(t, e, n, r, s), o), this;
  }
  /**
   * Draws a given shape on the canvas.
   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.
   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.
   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.
   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,
   * scaling, and translations.
   * @returns The instance of the current object for chaining.
   */
  drawShape(t, e) {
    return this.endPoly(), this.shapePrimitives.push({ shape: t, transform: e }), this;
  }
  /**
   * Starts a new polygon path from the specified starting point.
   * This method initializes a new polygon or ends the current one if it exists.
   * @param x - The x-coordinate of the starting point of the new polygon.
   * @param y - The y-coordinate of the starting point of the new polygon.
   * @returns The instance of the current object for chaining.
   */
  startPoly(t, e) {
    let n = this._currentPoly;
    return n && this.endPoly(), n = new lr(), n.points.push(t, e), this._currentPoly = n, this;
  }
  /**
   * Ends the current polygon path. If `closePath` is set to true,
   * the path is closed by connecting the last point to the first one.
   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.
   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point
   *  back to the starting point. False by default.
   * @returns The instance of the current object for chaining.
   */
  endPoly(t = !1) {
    const e = this._currentPoly;
    return e && e.points.length > 2 && (e.closePath = t, this.shapePrimitives.push({ shape: e })), this._currentPoly = null, this;
  }
  _ensurePoly(t = !0) {
    if (!this._currentPoly && (this._currentPoly = new lr(), t)) {
      const e = this.shapePrimitives[this.shapePrimitives.length - 1];
      if (e) {
        let n = e.shape.x, r = e.shape.y;
        if (e.transform && !e.transform.isIdentity()) {
          const s = e.transform, o = n;
          n = s.a * n + s.c * r + s.tx, r = s.b * o + s.d * r + s.ty;
        }
        this._currentPoly.points.push(n, r);
      } else
        this._currentPoly.points.push(0, 0);
    }
  }
  /** Builds the path. */
  buildPath() {
    const t = this._graphicsPath2D;
    this.shapePrimitives.length = 0, this._currentPoly = null;
    for (let e = 0; e < t.instructions.length; e++) {
      const n = t.instructions[e];
      this[n.action](...n.data);
    }
    this.finish();
  }
  /** Gets the bounds of the path. */
  get bounds() {
    const t = this._bounds;
    t.clear();
    const e = this.shapePrimitives;
    for (let n = 0; n < e.length; n++) {
      const r = e[n], s = r.shape.getBounds(cb);
      r.transform ? t.addRect(s, r.transform) : t.addRect(s);
    }
    return t;
  }
}
class _r {
  /**
   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.
   * @param instructions - An SVG path string or an array of `PathInstruction` objects.
   */
  constructor(t) {
    this.instructions = [], this.uid = qt("graphicsPath"), this._dirty = !0, typeof t == "string" ? N_(t, this) : this.instructions = (t == null ? void 0 : t.slice()) ?? [];
  }
  /**
   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.
   * @returns The `ShapePath` instance associated with this `GraphicsPath`.
   */
  get shapePath() {
    return this._shapePath || (this._shapePath = new ub(this)), this._dirty && (this._dirty = !1, this._shapePath.buildPath()), this._shapePath;
  }
  /**
   * Adds another `GraphicsPath` to this path, optionally applying a transformation.
   * @param path - The `GraphicsPath` to add.
   * @param transform - An optional transformation to apply to the added path.
   * @returns The instance of the current object for chaining.
   */
  addPath(t, e) {
    return t = t.clone(), this.instructions.push({ action: "addPath", data: [t, e] }), this._dirty = !0, this;
  }
  arc(...t) {
    return this.instructions.push({ action: "arc", data: t }), this._dirty = !0, this;
  }
  arcTo(...t) {
    return this.instructions.push({ action: "arcTo", data: t }), this._dirty = !0, this;
  }
  arcToSvg(...t) {
    return this.instructions.push({ action: "arcToSvg", data: t }), this._dirty = !0, this;
  }
  bezierCurveTo(...t) {
    return this.instructions.push({ action: "bezierCurveTo", data: t }), this._dirty = !0, this;
  }
  /**
   * Adds a cubic Bezier curve to the path.
   * It requires two points: the second control point and the end point. The first control point is assumed to be
   * The starting point is the last point in the current path.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  bezierCurveToShort(t, e, n, r, s) {
    const o = this.instructions[this.instructions.length - 1], a = this.getLastPoint(me.shared);
    let l = 0, h = 0;
    if (!o || o.action !== "bezierCurveTo")
      l = a.x, h = a.y;
    else {
      l = o.data[2], h = o.data[3];
      const c = a.x, p = a.y;
      l = c + (c - l), h = p + (p - h);
    }
    return this.instructions.push({ action: "bezierCurveTo", data: [l, h, t, e, n, r, s] }), this._dirty = !0, this;
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    return this.instructions.push({ action: "closePath", data: [] }), this._dirty = !0, this;
  }
  ellipse(...t) {
    return this.instructions.push({ action: "ellipse", data: t }), this._dirty = !0, this;
  }
  lineTo(...t) {
    return this.instructions.push({ action: "lineTo", data: t }), this._dirty = !0, this;
  }
  moveTo(...t) {
    return this.instructions.push({ action: "moveTo", data: t }), this;
  }
  quadraticCurveTo(...t) {
    return this.instructions.push({ action: "quadraticCurveTo", data: t }), this._dirty = !0, this;
  }
  /**
   * Adds a quadratic curve to the path. It uses the previous point as the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  quadraticCurveToShort(t, e, n) {
    const r = this.instructions[this.instructions.length - 1], s = this.getLastPoint(me.shared);
    let o = 0, a = 0;
    if (!r || r.action !== "quadraticCurveTo")
      o = s.x, a = s.y;
    else {
      o = r.data[0], a = r.data[1];
      const l = s.x, h = s.y;
      o = l + (l - o), a = h + (h - a);
    }
    return this.instructions.push({ action: "quadraticCurveTo", data: [o, a, t, e, n] }), this._dirty = !0, this;
  }
  /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */
  rect(t, e, n, r, s) {
    return this.instructions.push({ action: "rect", data: [t, e, n, r, s] }), this._dirty = !0, this;
  }
  /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @param transform - An optional `Matrix` object to apply a transformation to the circle.
   * @returns The instance of the current object for chaining.
   */
  circle(t, e, n, r) {
    return this.instructions.push({ action: "circle", data: [t, e, n, r] }), this._dirty = !0, this;
  }
  roundRect(...t) {
    return this.instructions.push({ action: "roundRect", data: t }), this._dirty = !0, this;
  }
  poly(...t) {
    return this.instructions.push({ action: "poly", data: t }), this._dirty = !0, this;
  }
  regularPoly(...t) {
    return this.instructions.push({ action: "regularPoly", data: t }), this._dirty = !0, this;
  }
  roundPoly(...t) {
    return this.instructions.push({ action: "roundPoly", data: t }), this._dirty = !0, this;
  }
  roundShape(...t) {
    return this.instructions.push({ action: "roundShape", data: t }), this._dirty = !0, this;
  }
  filletRect(...t) {
    return this.instructions.push({ action: "filletRect", data: t }), this._dirty = !0, this;
  }
  chamferRect(...t) {
    return this.instructions.push({ action: "chamferRect", data: t }), this._dirty = !0, this;
  }
  /**
   * Draws a star shape centered at a specified location. This method allows for the creation
   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
   * An optional transformation can be applied to scale, rotate, or translate the star as needed.
   * @param x - The x-coordinate of the center of the star.
   * @param y - The y-coordinate of the center of the star.
   * @param points - The number of points of the star.
   * @param radius - The outer radius of the star (distance from the center to the outer points).
   * @param innerRadius - Optional. The inner radius of the star
   * (distance from the center to the inner points between the outer points).
   * If not provided, defaults to half of the `radius`.
   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
   * Defaults to 0, meaning one point is directly upward.
   * @param transform - An optional `Matrix` object to apply a transformation to the star.
   * This can include rotations, scaling, and translations.
   * @returns The instance of the current object for chaining further drawing commands.
   */
  // eslint-disable-next-line max-len
  star(t, e, n, r, s, o, a) {
    s = s || r / 2;
    const l = -1 * Math.PI / 2 + o, h = n * 2, c = Math.PI * 2 / h, p = [];
    for (let f = 0; f < h; f++) {
      const d = f % 2 ? s : r, m = f * c + l;
      p.push(
        t + d * Math.cos(m),
        e + d * Math.sin(m)
      );
    }
    return this.poly(p, !0, a), this;
  }
  /**
   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.
   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and
   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`
   * do not affect the original `GraphicsPath` and vice versa.
   * @param deep - A boolean flag indicating whether the clone should be deep.
   * @returns A new `GraphicsPath` instance that is a clone of the current instance.
   */
  clone(t = !1) {
    const e = new _r();
    if (!t)
      e.instructions = this.instructions.slice();
    else
      for (let n = 0; n < this.instructions.length; n++) {
        const r = this.instructions[n];
        e.instructions.push({ action: r.action, data: r.data.slice() });
      }
    return e;
  }
  clear() {
    return this.instructions.length = 0, this._dirty = !0, this;
  }
  /**
   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.
   * This method enables the modification of the path's geometry according to the provided
   * transformation matrix, which can include translations, rotations, scaling, and skewing.
   *
   * Each drawing instruction in the path is updated to reflect the transformation,
   * ensuring the visual representation of the path is consistent with the applied matrix.
   *
   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,
   * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,
   * allowing for fine-grained control over the path's appearance.
   * @param matrix - A `Matrix` object representing the transformation to apply.
   * @returns The instance of the current object for chaining further operations.
   */
  transform(t) {
    if (t.isIdentity())
      return this;
    const e = t.a, n = t.b, r = t.c, s = t.d, o = t.tx, a = t.ty;
    let l = 0, h = 0, c = 0, p = 0, f = 0, d = 0, m = 0, g = 0;
    for (let y = 0; y < this.instructions.length; y++) {
      const b = this.instructions[y], S = b.data;
      switch (b.action) {
        case "moveTo":
        case "lineTo":
          l = S[0], h = S[1], S[0] = e * l + r * h + o, S[1] = n * l + s * h + a;
          break;
        case "bezierCurveTo":
          c = S[0], p = S[1], f = S[2], d = S[3], l = S[4], h = S[5], S[0] = e * c + r * p + o, S[1] = n * c + s * p + a, S[2] = e * f + r * d + o, S[3] = n * f + s * d + a, S[4] = e * l + r * h + o, S[5] = n * l + s * h + a;
          break;
        case "quadraticCurveTo":
          c = S[0], p = S[1], l = S[2], h = S[3], S[0] = e * c + r * p + o, S[1] = n * c + s * p + a, S[2] = e * l + r * h + o, S[3] = n * l + s * h + a;
          break;
        case "arcToSvg":
          l = S[5], h = S[6], m = S[0], g = S[1], S[0] = e * m + r * g, S[1] = n * m + s * g, S[5] = e * l + r * h + o, S[6] = n * l + s * h + a;
          break;
        case "circle":
          S[4] = ns(S[3], t);
          break;
        case "rect":
          S[4] = ns(S[4], t);
          break;
        case "ellipse":
          S[8] = ns(S[8], t);
          break;
        case "roundRect":
          S[5] = ns(S[5], t);
          break;
        case "addPath":
          S[0].transform(t);
          break;
        case "poly":
          S[2] = ns(S[2], t);
          break;
        default:
          Lt("unknown transform action", b.action);
          break;
      }
    }
    return this._dirty = !0, this;
  }
  get bounds() {
    return this.shapePath.bounds;
  }
  /**
   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.
   * This method is useful for operations that depend on the path's current endpoint,
   * such as connecting subsequent shapes or paths. It supports various drawing instructions,
   * ensuring the last point's position is accurately determined regardless of the path's complexity.
   *
   * If the last instruction is a `closePath`, the method iterates backward through the instructions
   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,
   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves
   * the last point from the nested path.
   * @param out - A `Point` object where the last point's coordinates will be stored.
   * This object is modified directly to contain the result.
   * @returns The `Point` object containing the last point's coordinates.
   */
  getLastPoint(t) {
    let e = this.instructions.length - 1, n = this.instructions[e];
    if (!n)
      return t.x = 0, t.y = 0, t;
    for (; n.action === "closePath"; ) {
      if (e--, e < 0)
        return t.x = 0, t.y = 0, t;
      n = this.instructions[e];
    }
    switch (n.action) {
      case "moveTo":
      case "lineTo":
        t.x = n.data[0], t.y = n.data[1];
        break;
      case "quadraticCurveTo":
        t.x = n.data[2], t.y = n.data[3];
        break;
      case "bezierCurveTo":
        t.x = n.data[4], t.y = n.data[5];
        break;
      case "arc":
      case "arcToSvg":
        t.x = n.data[5], t.y = n.data[6];
        break;
      case "addPath":
        n.data[0].getLastPoint(t);
        break;
    }
    return t;
  }
}
function ns(i, t) {
  return i ? i.prepend(t) : t.clone();
}
function db(i, t) {
  if (typeof i == "string") {
    const n = document.createElement("div");
    n.innerHTML = i.trim(), i = n.querySelector("svg");
  }
  const e = {
    context: t,
    path: new _r()
  };
  return Rm(i, e, null, null), t;
}
function Rm(i, t, e, n) {
  const r = i.children, { fillStyle: s, strokeStyle: o } = pb(i);
  s && e ? e = { ...e, ...s } : s && (e = s), o && n ? n = { ...n, ...o } : o && (n = o), t.context.fillStyle = e, t.context.strokeStyle = n;
  let a, l, h, c, p, f, d, m, g, y, b, S, C, I, T, R, w;
  switch (i.nodeName.toLowerCase()) {
    case "path":
      I = i.getAttribute("d"), T = new _r(I), t.context.path(T), e && t.context.fill(), n && t.context.stroke();
      break;
    case "circle":
      d = Kt(i, "cx", 0), m = Kt(i, "cy", 0), g = Kt(i, "r", 0), t.context.ellipse(d, m, g, g), e && t.context.fill(), n && t.context.stroke();
      break;
    case "rect":
      a = Kt(i, "x", 0), l = Kt(i, "y", 0), R = Kt(i, "width", 0), w = Kt(i, "height", 0), y = Kt(i, "rx", 0), b = Kt(i, "ry", 0), y || b ? t.context.roundRect(a, l, R, w, y || b) : t.context.rect(a, l, R, w), e && t.context.fill(), n && t.context.stroke();
      break;
    case "ellipse":
      d = Kt(i, "cx", 0), m = Kt(i, "cy", 0), y = Kt(i, "rx", 0), b = Kt(i, "ry", 0), t.context.beginPath(), t.context.ellipse(d, m, y, b), e && t.context.fill(), n && t.context.stroke();
      break;
    case "line":
      h = Kt(i, "x1", 0), c = Kt(i, "y1", 0), p = Kt(i, "x2", 0), f = Kt(i, "y2", 0), t.context.beginPath(), t.context.moveTo(h, c), t.context.lineTo(p, f), n && t.context.stroke();
      break;
    case "polygon":
      C = i.getAttribute("points"), S = C.match(/\d+/g).map((v) => parseInt(v, 10)), t.context.poly(S, !0), e && t.context.fill(), n && t.context.stroke();
      break;
    case "polyline":
      C = i.getAttribute("points"), S = C.match(/\d+/g).map((v) => parseInt(v, 10)), t.context.poly(S, !1), n && t.context.stroke();
      break;
    case "g":
    case "svg":
      break;
    default: {
      console.info(`[SVG parser] <${i.nodeName}> elements unsupported`);
      break;
    }
  }
  for (let v = 0; v < r.length; v++)
    Rm(r[v], t, e, n);
}
function Kt(i, t, e) {
  const n = i.getAttribute(t);
  return n ? Number(n) : e;
}
function pb(i) {
  const t = i.getAttribute("style"), e = {}, n = {};
  let r = !1, s = !1;
  if (t) {
    const o = t.split(";");
    for (let a = 0; a < o.length; a++) {
      const l = o[a], [h, c] = l.split(":");
      switch (h) {
        case "stroke":
          c !== "none" && (e.color = Gt.shared.setValue(c).toNumber(), s = !0);
          break;
        case "stroke-width":
          e.width = Number(c);
          break;
        case "fill":
          c !== "none" && (r = !0, n.color = Gt.shared.setValue(c).toNumber());
          break;
        case "fill-opacity":
          n.alpha = Number(c);
          break;
        case "stroke-opacity":
          e.alpha = Number(c);
          break;
        case "opacity":
          n.alpha = Number(c), e.alpha = Number(c);
          break;
      }
    }
  } else {
    const o = i.getAttribute("stroke");
    o && o !== "none" && (s = !0, e.color = Gt.shared.setValue(o).toNumber(), e.width = Kt(i, "stroke-width", 1));
    const a = i.getAttribute("fill");
    a && a !== "none" && (r = !0, n.color = Gt.shared.setValue(a).toNumber());
  }
  return {
    strokeStyle: s ? e : null,
    fillStyle: r ? n : null
  };
}
function fb(i) {
  return Gt.isColorLike(i);
}
function Yd(i) {
  return i instanceof ka;
}
function Xd(i) {
  return i instanceof Rs;
}
function mb(i, t, e) {
  const n = Gt.shared.setValue(t ?? 0);
  return i.color = n.toNumber(), i.alpha = n.alpha === 1 ? e.alpha : n.alpha, i.texture = nt.WHITE, { ...e, ...i };
}
function Kd(i, t, e) {
  return i.fill = t, i.color = 16777215, i.texture = t.texture, i.matrix = t.transform, { ...e, ...i };
}
function Qd(i, t, e) {
  return t.buildLinearGradient(), i.fill = t, i.color = 16777215, i.texture = t.texture, i.matrix = t.transform, { ...e, ...i };
}
function gb(i, t) {
  var e;
  const n = { ...t, ...i };
  if (n.texture) {
    if (n.texture !== nt.WHITE) {
      const o = ((e = n.matrix) == null ? void 0 : e.invert()) || new ct();
      o.translate(n.texture.frame.x, n.texture.frame.y), o.scale(1 / n.texture.source.width, 1 / n.texture.source.height), n.matrix = o;
    }
    const s = n.texture.source.style;
    s.addressMode === "clamp-to-edge" && (s.addressMode = "repeat", s.update());
  }
  const r = Gt.shared.setValue(n.color);
  return n.alpha *= r.alpha, n.color = r.toNumber(), n.matrix = n.matrix ? n.matrix.clone() : null, n;
}
function wn(i, t) {
  if (i == null)
    return null;
  const e = {}, n = i;
  return fb(i) ? mb(e, i, t) : Yd(i) ? Kd(e, i, t) : Xd(i) ? Qd(e, i, t) : n.fill && Yd(n.fill) ? Kd(n, n.fill, t) : n.fill && Xd(n.fill) ? Qd(n, n.fill, t) : gb(n, t);
}
function Qo(i, t) {
  const { width: e, alignment: n, miterLimit: r, cap: s, join: o, ...a } = t, l = wn(i, a);
  return l ? {
    width: e,
    alignment: n,
    miterLimit: r,
    cap: s,
    join: o,
    ...l
  } : null;
}
const yb = new me(), Jd = new ct(), vc = class di extends xe {
  constructor() {
    super(...arguments), this.uid = qt("graphicsContext"), this.dirty = !0, this.batchMode = "auto", this.instructions = [], this._activePath = new _r(), this._transform = new ct(), this._fillStyle = { ...di.defaultFillStyle }, this._strokeStyle = { ...di.defaultStrokeStyle }, this._stateStack = [], this._tick = 0, this._bounds = new Ji(), this._boundsDirty = !0;
  }
  /**
   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,
   * including the current drawing state, transformations, styles, and instructions.
   * @returns A new GraphicsContext instance with the same properties and state as this one.
   */
  clone() {
    const t = new di();
    return t.batchMode = this.batchMode, t.instructions = this.instructions.slice(), t._activePath = this._activePath.clone(), t._transform = this._transform.clone(), t._fillStyle = { ...this._fillStyle }, t._strokeStyle = { ...this._strokeStyle }, t._stateStack = this._stateStack.slice(), t._bounds = this._bounds.clone(), t._boundsDirty = !0, t;
  }
  /**
   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.
   */
  get fillStyle() {
    return this._fillStyle;
  }
  set fillStyle(t) {
    this._fillStyle = wn(t, di.defaultFillStyle);
  }
  /**
   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
   */
  get strokeStyle() {
    return this._strokeStyle;
  }
  set strokeStyle(t) {
    this._strokeStyle = Qo(t, di.defaultStrokeStyle);
  }
  /**
   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
   * pattern, or a more complex style defined by a FillStyle object.
   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,
   *                or a FillStyle or ConvertedFillStyle object.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  setFillStyle(t) {
    return this._fillStyle = wn(t, di.defaultFillStyle), this;
  }
  /**
   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,
   *                or a StrokeStyle or ConvertedStrokeStyle object.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  setStrokeStyle(t) {
    return this._strokeStyle = wn(t, di.defaultStrokeStyle), this;
  }
  texture(t, e, n, r, s, o) {
    return this.instructions.push({
      action: "texture",
      data: {
        image: t,
        dx: n || 0,
        dy: r || 0,
        dw: s || t.frame.width,
        dh: o || t.frame.height,
        transform: this._transform.clone(),
        alpha: this._fillStyle.alpha,
        style: e ? Gt.shared.setValue(e).toNumber() : 16777215
      }
    }), this.onUpdate(), this;
  }
  /**
   * Resets the current path. Any previous path and its commands are discarded and a new path is
   * started. This is typically called before beginning a new shape or series of drawing commands.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  beginPath() {
    return this._activePath = new _r(), this;
  }
  fill(t, e) {
    let n;
    const r = this.instructions[this.instructions.length - 1];
    return this._tick === 0 && r && r.action === "stroke" ? n = r.data.path : n = this._activePath.clone(), n ? (t != null && (e !== void 0 && typeof t == "number" && (ut(dt, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"), t = { color: t, alpha: e }), this._fillStyle = wn(t, di.defaultFillStyle)), this.instructions.push({
      action: "fill",
      // TODO copy fill style!
      data: { style: this.fillStyle, path: n }
    }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
  }
  _initNextPathLocation() {
    const { x: t, y: e } = this._activePath.getLastPoint(me.shared);
    this._activePath.clear(), this._activePath.moveTo(t, e);
  }
  /**
   * Strokes the current path with the current stroke style. This method can take an optional
   * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.
   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  stroke(t) {
    let e;
    const n = this.instructions[this.instructions.length - 1];
    return this._tick === 0 && n && n.action === "fill" ? e = n.data.path : e = this._activePath.clone(), e ? (t != null && (this._strokeStyle = Qo(t, di.defaultStrokeStyle)), this.instructions.push({
      action: "stroke",
      // TODO copy fill style!
      data: { style: this.strokeStyle, path: e }
    }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
  }
  /**
   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
   * fail to cut correctly!
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  cut() {
    for (let t = 0; t < 2; t++) {
      const e = this.instructions[this.instructions.length - 1 - t], n = this._activePath.clone();
      if (e && (e.action === "stroke" || e.action === "fill"))
        if (e.data.hole)
          e.data.hole.addPath(n);
        else {
          e.data.hole = n;
          break;
        }
    }
    return this._initNextPathLocation(), this;
  }
  /**
   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,
   * starting and ending angles, and direction.
   * @param x - The x-coordinate of the arc's center.
   * @param y - The y-coordinate of the arc's center.
   * @param radius - The arc's radius.
   * @param startAngle - The starting angle, in radians.
   * @param endAngle - The ending angle, in radians.
   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  arc(t, e, n, r, s, o) {
    this._tick++;
    const a = this._transform;
    return this._activePath.arc(
      a.a * t + a.c * e + a.tx,
      a.b * t + a.d * e + a.ty,
      n,
      r,
      s,
      o
    ), this;
  }
  /**
   * Adds an arc to the current path with the given control points and radius, connected to the previous point
   * by a straight line if necessary.
   * @param x1 - The x-coordinate of the first control point.
   * @param y1 - The y-coordinate of the first control point.
   * @param x2 - The x-coordinate of the second control point.
   * @param y2 - The y-coordinate of the second control point.
   * @param radius - The arc's radius.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  arcTo(t, e, n, r, s) {
    this._tick++;
    const o = this._transform;
    return this._activePath.arcTo(
      o.a * t + o.c * e + o.tx,
      o.b * t + o.d * e + o.ty,
      o.a * n + o.c * r + o.tx,
      o.b * n + o.d * r + o.ty,
      s
    ), this;
  }
  /**
   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
   * @param rx - The x-radius of the ellipse.
   * @param ry - The y-radius of the ellipse.
   * @param xAxisRotation - The rotation of the ellipse's x-axis relative
   * to the x-axis of the coordinate system, in degrees.
   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
   * @param x - The x-coordinate of the arc's end point.
   * @param y - The y-coordinate of the arc's end point.
   * @returns The instance of the current object for chaining.
   */
  arcToSvg(t, e, n, r, s, o, a) {
    this._tick++;
    const l = this._transform;
    return this._activePath.arcToSvg(
      t,
      e,
      n,
      // should we rotate this with transform??
      r,
      s,
      l.a * o + l.c * a + l.tx,
      l.b * o + l.d * a + l.ty
    ), this;
  }
  /**
   * Adds a cubic Bezier curve to the path.
   * It requires three points: the first two are control points and the third one is the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the first control point.
   * @param cp1y - The y-coordinate of the first control point.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  bezierCurveTo(t, e, n, r, s, o, a) {
    this._tick++;
    const l = this._transform;
    return this._activePath.bezierCurveTo(
      l.a * t + l.c * e + l.tx,
      l.b * t + l.d * e + l.ty,
      l.a * n + l.c * r + l.tx,
      l.b * n + l.d * r + l.ty,
      l.a * s + l.c * o + l.tx,
      l.b * s + l.d * o + l.ty,
      a
    ), this;
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    var t;
    return this._tick++, (t = this._activePath) == null || t.closePath(), this;
  }
  /**
   * Draws an ellipse at the specified location and with the given x and y radii.
   * An optional transformation can be applied, allowing for rotation, scaling, and translation.
   * @param x - The x-coordinate of the center of the ellipse.
   * @param y - The y-coordinate of the center of the ellipse.
   * @param radiusX - The horizontal radius of the ellipse.
   * @param radiusY - The vertical radius of the ellipse.
   * @returns The instance of the current object for chaining.
   */
  ellipse(t, e, n, r) {
    return this._tick++, this._activePath.ellipse(t, e, n, r, this._transform.clone()), this;
  }
  /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @returns The instance of the current object for chaining.
   */
  circle(t, e, n) {
    return this._tick++, this._activePath.circle(t, e, n, this._transform.clone()), this;
  }
  /**
   * Adds another `GraphicsPath` to this path, optionally applying a transformation.
   * @param path - The `GraphicsPath` to add.
   * @returns The instance of the current object for chaining.
   */
  path(t) {
    return this._tick++, this._activePath.addPath(t, this._transform.clone()), this;
  }
  /**
   * Connects the current point to a new point with a straight line. This method updates the current path.
   * @param x - The x-coordinate of the new point to connect to.
   * @param y - The y-coordinate of the new point to connect to.
   * @returns The instance of the current object for chaining.
   */
  lineTo(t, e) {
    this._tick++;
    const n = this._transform;
    return this._activePath.lineTo(
      n.a * t + n.c * e + n.tx,
      n.b * t + n.d * e + n.ty
    ), this;
  }
  /**
   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
   * @param x - The x-coordinate for the starting point.
   * @param y - The y-coordinate for the starting point.
   * @returns The instance of the current object for chaining.
   */
  moveTo(t, e) {
    this._tick++;
    const n = this._transform, r = this._activePath.instructions, s = n.a * t + n.c * e + n.tx, o = n.b * t + n.d * e + n.ty;
    return r.length === 1 && r[0].action === "moveTo" ? (r[0].data[0] = s, r[0].data[1] = o, this) : (this._activePath.moveTo(
      s,
      o
    ), this);
  }
  /**
   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
   * The starting point is the last point in the current path.
   * @param cpx - The x-coordinate of the control point.
   * @param cpy - The y-coordinate of the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  quadraticCurveTo(t, e, n, r, s) {
    this._tick++;
    const o = this._transform;
    return this._activePath.quadraticCurveTo(
      o.a * t + o.c * e + o.tx,
      o.b * t + o.d * e + o.ty,
      o.a * n + o.c * r + o.tx,
      o.b * n + o.d * r + o.ty,
      s
    ), this;
  }
  /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @returns The instance of the current object for chaining.
   */
  rect(t, e, n, r) {
    return this._tick++, this._activePath.rect(t, e, n, r, this._transform.clone()), this;
  }
  /**
   * Draws a rectangle with rounded corners.
   * The corner radius can be specified to determine how rounded the corners should be.
   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
   * @returns The instance of the current object for chaining.
   */
  roundRect(t, e, n, r, s) {
    return this._tick++, this._activePath.roundRect(t, e, n, r, s, this._transform.clone()), this;
  }
  /**
   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,
   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,
   * rotated, or translated as needed.
   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
   * representing the x and y coordinates, of the polygon's vertices, in sequence.
   * @param close - A boolean indicating whether to close the polygon path. True by default.
   */
  poly(t, e) {
    return this._tick++, this._activePath.poly(t, e, this._transform.clone()), this;
  }
  /**
   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */
  regularPoly(t, e, n, r, s = 0, o) {
    return this._tick++, this._activePath.regularPoly(t, e, n, r, s, o), this;
  }
  /**
   * Draws a polygon with rounded corners.
   * Similar to `regularPoly` but with the ability to round the corners of the polygon.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param corner - The radius of the rounding of the corners.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @returns The instance of the current object for chaining.
   */
  roundPoly(t, e, n, r, s, o) {
    return this._tick++, this._activePath.roundPoly(t, e, n, r, s, o), this;
  }
  /**
   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
   * A minimum of 3 points is required.
   * @param radius - The default radius for the corners.
   * This radius is applied to all corners unless overridden in `points`.
   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
   *  method instead of an arc method. Defaults to false.
   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
   * Higher values make the curve smoother.
   * @returns The instance of the current object for chaining.
   */
  roundShape(t, e, n, r) {
    return this._tick++, this._activePath.roundShape(t, e, n, r), this;
  }
  /**
   * Draw Rectangle with fillet corners. This is much like rounded rectangle
   * however it support negative numbers as well for the corner radius.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param fillet - accept negative or positive values
   */
  filletRect(t, e, n, r, s) {
    return this._tick++, this._activePath.filletRect(t, e, n, r, s), this;
  }
  /**
   * Draw Rectangle with chamfer corners. These are angled corners.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param chamfer - non-zero real number, size of corner cutout
   * @param transform
   */
  chamferRect(t, e, n, r, s, o) {
    return this._tick++, this._activePath.chamferRect(t, e, n, r, s, o), this;
  }
  /**
   * Draws a star shape centered at a specified location. This method allows for the creation
   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
   * An optional transformation can be applied to scale, rotate, or translate the star as needed.
   * @param x - The x-coordinate of the center of the star.
   * @param y - The y-coordinate of the center of the star.
   * @param points - The number of points of the star.
   * @param radius - The outer radius of the star (distance from the center to the outer points).
   * @param innerRadius - Optional. The inner radius of the star
   * (distance from the center to the inner points between the outer points).
   * If not provided, defaults to half of the `radius`.
   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
   * Defaults to 0, meaning one point is directly upward.
   * @returns The instance of the current object for chaining further drawing commands.
   */
  star(t, e, n, r, s = 0, o = 0) {
    return this._tick++, this._activePath.star(t, e, n, r, s, o, this._transform.clone()), this;
  }
  /**
   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths
   * defined in SVG format to be drawn within the graphics context.
   * @param svg - The SVG string to be parsed and rendered.
   */
  svg(t) {
    return this._tick++, db(t, this), this;
  }
  /**
   * Restores the most recently saved graphics state by popping the top of the graphics state stack.
   * This includes transformations, fill styles, and stroke styles.
   */
  restore() {
    const t = this._stateStack.pop();
    return t && (this._transform = t.transform, this._fillStyle = t.fillStyle, this._strokeStyle = t.strokeStyle), this;
  }
  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
  save() {
    return this._stateStack.push({
      transform: this._transform.clone(),
      fillStyle: { ...this._fillStyle },
      strokeStyle: { ...this._strokeStyle }
    }), this;
  }
  /**
   * Returns the current transformation matrix of the graphics context.
   * @returns The current transformation matrix.
   */
  getTransform() {
    return this._transform;
  }
  /**
   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  resetTransform() {
    return this._transform.identity(), this;
  }
  /**
   * Applies a rotation transformation to the graphics context around the current origin.
   * @param angle - The angle of rotation in radians.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  rotate(t) {
    return this._transform.rotate(t), this;
  }
  /**
   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.
   * @param x - The scale factor in the horizontal direction.
   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  scale(t, e = t) {
    return this._transform.scale(t, e), this;
  }
  setTransform(t, e, n, r, s, o) {
    return t instanceof ct ? (this._transform.set(t.a, t.b, t.c, t.d, t.tx, t.ty), this) : (this._transform.set(t, e, n, r, s, o), this);
  }
  transform(t, e, n, r, s, o) {
    return t instanceof ct ? (this._transform.append(t), this) : (Jd.set(t, e, n, r, s, o), this._transform.append(Jd), this);
  }
  /**
   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.
   * @param x - The amount to translate in the horizontal direction.
   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  translate(t, e = t) {
    return this._transform.translate(t, e), this;
  }
  /**
   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
   * and optionally resetting transformations to the identity matrix.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  clear() {
    return this._activePath.clear(), this.instructions.length = 0, this.resetTransform(), this.onUpdate(), this;
  }
  onUpdate() {
    this.dirty || (this.emit("update", this, 16), this.dirty = !0, this._boundsDirty = !0);
  }
  /** The bounds of the graphic shape. */
  get bounds() {
    if (!this._boundsDirty)
      return this._bounds;
    const t = this._bounds;
    t.clear();
    for (let e = 0; e < this.instructions.length; e++) {
      const n = this.instructions[e], r = n.action;
      if (r === "fill") {
        const s = n.data;
        t.addBounds(s.path.bounds);
      } else if (r === "texture") {
        const s = n.data;
        t.addFrame(s.dx, s.dy, s.dx + s.dw, s.dy + s.dh, s.transform);
      }
      if (r === "stroke") {
        const s = n.data, o = s.style.width / 2, a = s.path.bounds;
        t.addFrame(
          a.minX - o,
          a.minY - o,
          a.maxX + o,
          a.maxY + o
        );
      }
    }
    return t;
  }
  /**
   * Check to see if a point is contained within this geometry.
   * @param point - Point to check if it's contained.
   * @returns {boolean} `true` if the point is contained within geometry.
   */
  containsPoint(t) {
    var e;
    if (!this.bounds.containsPoint(t.x, t.y))
      return !1;
    const n = this.instructions;
    let r = !1;
    for (let s = 0; s < n.length; s++) {
      const o = n[s], a = o.data, l = a.path;
      if (!o.action || !l)
        continue;
      const h = a.style, c = l.shapePath.shapePrimitives;
      for (let p = 0; p < c.length; p++) {
        const f = c[p].shape;
        if (!h || !f)
          continue;
        const d = c[p].transform, m = d ? d.applyInverse(t, yb) : t;
        o.action === "fill" ? r = f.contains(m.x, m.y) : r = f.strokeContains(m.x, m.y, h.width);
        const g = a.hole;
        if (g) {
          const y = (e = g.shapePath) == null ? void 0 : e.shapePrimitives;
          if (y)
            for (let b = 0; b < y.length; b++)
              y[b].shape.contains(m.x, m.y) && (r = !1);
        }
        if (r)
          return !0;
      }
    }
    return r;
  }
  /**
   * Destroys the GraphicsData object.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?
   * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?
   */
  destroy(t = !1) {
    if (this._stateStack.length = 0, this._transform = null, this.emit("destroy", this), this.removeAllListeners(), typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
      const e = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
      this._fillStyle.texture && this._fillStyle.texture.destroy(e), this._strokeStyle.texture && this._strokeStyle.texture.destroy(e);
    }
    this._fillStyle = null, this._strokeStyle = null, this.instructions = null, this._activePath = null, this._bounds = null, this._stateStack = null, this.customShader = null, this._transform = null;
  }
};
vc.defaultFillStyle = {
  /** The color to use for the fill. */
  color: 16777215,
  /** The alpha value to use for the fill. */
  alpha: 1,
  /** The texture to use for the fill. */
  texture: nt.WHITE,
  /** The matrix to apply. */
  matrix: null,
  /** The fill pattern to use. */
  fill: null
};
vc.defaultStrokeStyle = {
  /** The width of the stroke. */
  width: 1,
  /** The color to use for the stroke. */
  color: 16777215,
  /** The alpha value to use for the stroke. */
  alpha: 1,
  /** The alignment of the stroke. */
  alignment: 0.5,
  /** The miter limit to use. */
  miterLimit: 10,
  /** The line cap style to use. */
  cap: "butt",
  /** The line join style to use. */
  join: "miter",
  /** The texture to use for the fill. */
  texture: nt.WHITE,
  /** The matrix to apply. */
  matrix: null,
  /** The fill pattern to use. */
  fill: null
};
let Qe = vc;
const Zd = [
  "align",
  "breakWords",
  "cssOverrides",
  "fontVariant",
  "fontWeight",
  "leading",
  "letterSpacing",
  "lineHeight",
  "padding",
  "textBaseline",
  "trim",
  "whiteSpace",
  "wordWrap",
  "wordWrapWidth",
  "fontFamily",
  "fontStyle",
  "fontSize"
];
function vb(i) {
  const t = [];
  let e = 0;
  for (let n = 0; n < Zd.length; n++) {
    const r = `_${Zd[n]}`;
    t[e++] = i[r];
  }
  return e = km(i._fill, t, e), e = _b(i._stroke, t, e), e = xb(i.dropShadow, t, e), t.join("-");
}
function km(i, t, e) {
  var n;
  return i && (t[e++] = i.color, t[e++] = i.alpha, t[e++] = (n = i.fill) == null ? void 0 : n.styleKey), e;
}
function _b(i, t, e) {
  return i && (e = km(i, t, e), t[e++] = i.width, t[e++] = i.alignment, t[e++] = i.cap, t[e++] = i.join, t[e++] = i.miterLimit), e;
}
function xb(i, t, e) {
  return i && (t[e++] = i.alpha, t[e++] = i.angle, t[e++] = i.blur, t[e++] = i.distance, t[e++] = Gt.shared.setValue(i.color).toNumber()), e;
}
const _c = class tr extends xe {
  constructor(t = {}) {
    super(), bb(t);
    const e = { ...tr.defaultTextStyle, ...t };
    for (const n in e) {
      const r = n;
      this[r] = e[n];
    }
    this.update();
  }
  /**
   * Alignment for multiline text, does not affect single line text.
   * @member {'left'|'center'|'right'|'justify'}
   */
  get align() {
    return this._align;
  }
  set align(t) {
    this._align = t, this.update();
  }
  /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
  get breakWords() {
    return this._breakWords;
  }
  set breakWords(t) {
    this._breakWords = t, this.update();
  }
  /** Set a drop shadow for the text. */
  get dropShadow() {
    return this._dropShadow;
  }
  set dropShadow(t) {
    t !== null && typeof t == "object" ? this._dropShadow = this._createProxy({ ...tr.defaultDropShadow, ...t }) : this._dropShadow = t ? this._createProxy({ ...tr.defaultDropShadow }) : null, this.update();
  }
  /** The font family, can be a single font name, or a list of names where the first is the preferred font. */
  get fontFamily() {
    return this._fontFamily;
  }
  set fontFamily(t) {
    this._fontFamily = t, this.update();
  }
  /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(t) {
    typeof t == "string" ? this._fontSize = parseInt(t, 10) : this._fontSize = t, this.update();
  }
  /**
   * The font style.
   * @member {'normal'|'italic'|'oblique'}
   */
  get fontStyle() {
    return this._fontStyle;
  }
  set fontStyle(t) {
    this._fontStyle = t.toLowerCase(), this.update();
  }
  /**
   * The font variant.
   * @member {'normal'|'small-caps'}
   */
  get fontVariant() {
    return this._fontVariant;
  }
  set fontVariant(t) {
    this._fontVariant = t, this.update();
  }
  /**
   * The font weight.
   * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
   */
  get fontWeight() {
    return this._fontWeight;
  }
  set fontWeight(t) {
    this._fontWeight = t, this.update();
  }
  /** The space between lines. */
  get leading() {
    return this._leading;
  }
  set leading(t) {
    this._leading = t, this.update();
  }
  /** The amount of spacing between letters, default is 0. */
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(t) {
    this._letterSpacing = t, this.update();
  }
  /** The line height, a number that represents the vertical space that a letter uses. */
  get lineHeight() {
    return this._lineHeight;
  }
  set lineHeight(t) {
    this._lineHeight = t, this.update();
  }
  /**
   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
   * by adding padding to all sides of the text.
   */
  get padding() {
    return this._padding;
  }
  set padding(t) {
    this._padding = t, this.update();
  }
  /** Trim transparent borders. This is an expensive operation so only use this if you have to! */
  get trim() {
    return this._trim;
  }
  set trim(t) {
    this._trim = t, this.update();
  }
  /**
   * The baseline of the text that is rendered.
   * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
   */
  get textBaseline() {
    return this._textBaseline;
  }
  set textBaseline(t) {
    this._textBaseline = t, this.update();
  }
  /**
   * How newlines and spaces should be handled.
   * Default is 'pre' (preserve, preserve).
   *
   *  value       | New lines     |   Spaces
   *  ---         | ---           |   ---
   * 'normal'     | Collapse      |   Collapse
   * 'pre'        | Preserve      |   Preserve
   * 'pre-line'   | Preserve      |   Collapse
   * @member {'normal'|'pre'|'pre-line'}
   */
  get whiteSpace() {
    return this._whiteSpace;
  }
  set whiteSpace(t) {
    this._whiteSpace = t, this.update();
  }
  /** Indicates if word wrap should be used. */
  get wordWrap() {
    return this._wordWrap;
  }
  set wordWrap(t) {
    this._wordWrap = t, this.update();
  }
  /** The width at which text will wrap, it needs wordWrap to be set to true. */
  get wordWrapWidth() {
    return this._wordWrapWidth;
  }
  set wordWrapWidth(t) {
    this._wordWrapWidth = t, this.update();
  }
  /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */
  get fill() {
    return this._originalFill;
  }
  set fill(t) {
    t !== this._originalFill && (this._originalFill = t, this._isFillStyle(t) && (this._originalFill = this._createProxy({ ...Qe.defaultFillStyle, ...t }, () => {
      this._fill = wn(
        { ...this._originalFill },
        Qe.defaultFillStyle
      );
    })), this._fill = wn(
      t === 0 ? "black" : t,
      Qe.defaultFillStyle
    ), this.update());
  }
  /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */
  get stroke() {
    return this._originalStroke;
  }
  set stroke(t) {
    t !== this._originalStroke && (this._originalStroke = t, this._isFillStyle(t) && (this._originalStroke = this._createProxy({ ...Qe.defaultStrokeStyle, ...t }, () => {
      this._stroke = Qo(
        { ...this._originalStroke },
        Qe.defaultStrokeStyle
      );
    })), this._stroke = Qo(t, Qe.defaultStrokeStyle), this.update());
  }
  _generateKey() {
    return this._styleKey = vb(this), this._styleKey;
  }
  update() {
    this._styleKey = null, this.emit("update", this);
  }
  /** Resets all properties to the default values */
  reset() {
    const t = tr.defaultTextStyle;
    for (const e in t)
      this[e] = t[e];
  }
  get styleKey() {
    return this._styleKey || this._generateKey();
  }
  /**
   * Creates a new TextStyle object with the same values as this one.
   * @returns New cloned TextStyle object
   */
  clone() {
    return new tr({
      align: this.align,
      breakWords: this.breakWords,
      dropShadow: this._dropShadow ? { ...this._dropShadow } : null,
      fill: this._fill,
      fontFamily: this.fontFamily,
      fontSize: this.fontSize,
      fontStyle: this.fontStyle,
      fontVariant: this.fontVariant,
      fontWeight: this.fontWeight,
      leading: this.leading,
      letterSpacing: this.letterSpacing,
      lineHeight: this.lineHeight,
      padding: this.padding,
      stroke: this._stroke,
      textBaseline: this.textBaseline,
      whiteSpace: this.whiteSpace,
      wordWrap: this.wordWrap,
      wordWrapWidth: this.wordWrapWidth
    });
  }
  /**
   * Destroys this text style.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style
   */
  destroy(t = !1) {
    var e, n, r, s;
    if (this.removeAllListeners(), typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
      const o = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
      (e = this._fill) != null && e.texture && this._fill.texture.destroy(o), (n = this._originalFill) != null && n.texture && this._originalFill.texture.destroy(o), (r = this._stroke) != null && r.texture && this._stroke.texture.destroy(o), (s = this._originalStroke) != null && s.texture && this._originalStroke.texture.destroy(o);
    }
    this._fill = null, this._stroke = null, this.dropShadow = null, this._originalStroke = null, this._originalFill = null;
  }
  _createProxy(t, e) {
    return new Proxy(t, {
      set: (n, r, s) => (n[r] = s, e == null || e(r, s), this.update(), !0)
    });
  }
  _isFillStyle(t) {
    return (t ?? null) !== null && !(Gt.isColorLike(t) || t instanceof Rs || t instanceof ka);
  }
};
_c.defaultDropShadow = {
  /** Set alpha for the drop shadow */
  alpha: 1,
  /** Set a angle of the drop shadow */
  angle: Math.PI / 6,
  /** Set a shadow blur radius */
  blur: 0,
  /** A fill style to be used on the  e.g., 'red', '#00FF00' */
  color: "black",
  /** Set a distance of the drop shadow */
  distance: 5
};
_c.defaultTextStyle = {
  /**
   * See {@link TextStyle.align}
   * @type {'left'|'center'|'right'|'justify'}
   */
  align: "left",
  /** See {@link TextStyle.breakWords} */
  breakWords: !1,
  /** See {@link TextStyle.dropShadow} */
  dropShadow: null,
  /**
   * See {@link TextStyle.fill}
   * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
   */
  fill: "black",
  /**
   * See {@link TextStyle.fontFamily}
   * @type {string|string[]}
   */
  fontFamily: "Arial",
  /**
   * See {@link TextStyle.fontSize}
   * @type {number|string}
   */
  fontSize: 26,
  /**
   * See {@link TextStyle.fontStyle}
   * @type {'normal'|'italic'|'oblique'}
   */
  fontStyle: "normal",
  /**
   * See {@link TextStyle.fontVariant}
   * @type {'normal'|'small-caps'}
   */
  fontVariant: "normal",
  /**
   * See {@link TextStyle.fontWeight}
   * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
   */
  fontWeight: "normal",
  /** See {@link TextStyle.leading} */
  leading: 0,
  /** See {@link TextStyle.letterSpacing} */
  letterSpacing: 0,
  /** See {@link TextStyle.lineHeight} */
  lineHeight: 0,
  /** See {@link TextStyle.padding} */
  padding: 0,
  /**
   * See {@link TextStyle.stroke}
   * @type {string|number}
   */
  stroke: null,
  /**
   * See {@link TextStyle.textBaseline}
   * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
   */
  textBaseline: "alphabetic",
  /** See {@link TextStyle.trim} */
  trim: !1,
  /**
   * See {@link TextStyle.whiteSpace}
   * @type {'normal'|'pre'|'pre-line'}
   */
  whiteSpace: "pre",
  /** See {@link TextStyle.wordWrap} */
  wordWrap: !1,
  /** See {@link TextStyle.wordWrapWidth} */
  wordWrapWidth: 100
};
let Dn = _c;
function bb(i) {
  const t = i;
  if (typeof t.dropShadow == "boolean" && t.dropShadow) {
    const e = Dn.defaultDropShadow;
    i.dropShadow = {
      alpha: t.dropShadowAlpha ?? e.alpha,
      angle: t.dropShadowAngle ?? e.angle,
      blur: t.dropShadowBlur ?? e.blur,
      color: t.dropShadowColor ?? e.color,
      distance: t.dropShadowDistance ?? e.distance
    };
  }
  if (t.strokeThickness !== void 0) {
    ut(dt, "strokeThickness is now a part of stroke");
    const e = t.stroke;
    let n = {};
    if (Gt.isColorLike(e))
      n.color = e;
    else if (e instanceof Rs || e instanceof ka)
      n.fill = e;
    else if (Object.hasOwnProperty.call(e, "color") || Object.hasOwnProperty.call(e, "fill"))
      n = e;
    else
      throw new Error("Invalid stroke value.");
    i.stroke = {
      ...n,
      width: t.strokeThickness
    };
  }
  if (Array.isArray(t.fillGradientStops)) {
    ut(dt, "gradient fill is now a fill pattern: `new FillGradient(...)`");
    let e;
    i.fontSize == null ? i.fontSize = Dn.defaultTextStyle.fontSize : typeof i.fontSize == "string" ? e = parseInt(i.fontSize, 10) : e = i.fontSize;
    const n = new Rs(0, 0, 0, e * 1.7), r = t.fillGradientStops.map((s) => Gt.shared.setValue(s).toNumber());
    r.forEach((s, o) => {
      const a = o / (r.length - 1);
      n.addColorStop(a, s);
    }), i.fill = {
      fill: n
    };
  }
}
class wb {
  constructor(t) {
    this._canvasPool = /* @__PURE__ */ Object.create(null), this.canvasOptions = t || {}, this.enableFullScreen = !1;
  }
  /**
   * Creates texture with params that were specified in pool constructor.
   * @param pixelWidth - Width of texture in pixels.
   * @param pixelHeight - Height of texture in pixels.
   */
  _createCanvasAndContext(t, e) {
    const n = Mt.get().createCanvas();
    n.width = t, n.height = e;
    const r = n.getContext("2d");
    return { canvas: n, context: r };
  }
  /**
   * Gets a Power-of-Two render texture or fullScreen texture
   * @param minWidth - The minimum width of the render texture.
   * @param minHeight - The minimum height of the render texture.
   * @param resolution - The resolution of the render texture.
   * @returns The new render texture.
   */
  getOptimalCanvasAndContext(t, e, n = 1) {
    t = Math.ceil(t * n - 1e-6), e = Math.ceil(e * n - 1e-6), t = ld(t), e = ld(e);
    const r = (t << 17) + (e << 1);
    this._canvasPool[r] || (this._canvasPool[r] = []);
    let s = this._canvasPool[r].pop();
    return s || (s = this._createCanvasAndContext(t, e)), s;
  }
  /**
   * Place a render texture back into the pool.
   * @param canvasAndContext
   */
  returnCanvasAndContext(t) {
    const e = t.canvas, { width: n, height: r } = e, s = (n << 17) + (r << 1);
    t.context.clearRect(0, 0, n, r), this._canvasPool[s].push(t);
  }
  clear() {
    this._canvasPool = {};
  }
}
const $d = new wb(), Ab = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
];
function Th(i) {
  const t = typeof i.fontSize == "number" ? `${i.fontSize}px` : i.fontSize;
  let e = i.fontFamily;
  Array.isArray(i.fontFamily) || (e = i.fontFamily.split(","));
  for (let n = e.length - 1; n >= 0; n--) {
    let r = e[n].trim();
    !/([\"\'])[^\'\"]+\1/.test(r) && !Ab.includes(r) && (r = `"${r}"`), e[n] = r;
  }
  return `${i.fontStyle} ${i.fontVariant} ${i.fontWeight} ${t} ${e.join(",")}`;
}
const Nl = {
  // TextMetrics requires getImageData readback for measuring fonts.
  willReadFrequently: !0
}, hi = class Y {
  /**
   * Checking that we can use modern canvas 2D API.
   *
   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.
   * @see TextMetrics.experimentalLetterSpacing
   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing
   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441
   */
  static get experimentalLetterSpacingSupported() {
    let t = Y._experimentalLetterSpacingSupported;
    if (t !== void 0) {
      const e = Mt.get().getCanvasRenderingContext2D().prototype;
      t = Y._experimentalLetterSpacingSupported = "letterSpacing" in e || "textLetterSpacing" in e;
    }
    return t;
  }
  /**
   * @param text - the text that was measured
   * @param style - the style that was measured
   * @param width - the measured width of the text
   * @param height - the measured height of the text
   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style
   * @param lineWidths - an array of the line widths for each line matched to `lines`
   * @param lineHeight - the measured line height for this style
   * @param maxLineWidth - the maximum line width for all measured lines
   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont
   */
  constructor(t, e, n, r, s, o, a, l, h) {
    this.text = t, this.style = e, this.width = n, this.height = r, this.lines = s, this.lineWidths = o, this.lineHeight = a, this.maxLineWidth = l, this.fontProperties = h;
  }
  /**
   * Measures the supplied string of text and returns a Rectangle.
   * @param text - The text to measure.
   * @param style - The text style to use for measuring
   * @param canvas - optional specification of the canvas to use for measuring.
   * @param wordWrap
   * @returns Measured width and height of the text.
   */
  static measureText(t = " ", e, n = Y._canvas, r = e.wordWrap) {
    var s;
    const o = `${t}:${e.styleKey}`;
    if (Y._measurementCache[o])
      return Y._measurementCache[o];
    const a = Th(e), l = Y.measureFont(a);
    l.fontSize === 0 && (l.fontSize = e.fontSize, l.ascent = e.fontSize);
    const h = Y.__context;
    h.font = a;
    const c = (r ? Y._wordWrap(t, e, n) : t).split(/(?:\r\n|\r|\n)/), p = new Array(c.length);
    let f = 0;
    for (let b = 0; b < c.length; b++) {
      const S = Y._measureText(c[b], e.letterSpacing, h);
      p[b] = S, f = Math.max(f, S);
    }
    const d = ((s = e._stroke) == null ? void 0 : s.width) || 0;
    let m = f + d;
    e.dropShadow && (m += e.dropShadow.distance);
    const g = e.lineHeight || l.fontSize;
    let y = Math.max(g, l.fontSize + d) + (c.length - 1) * (g + e.leading);
    return e.dropShadow && (y += e.dropShadow.distance), new Y(
      t,
      e,
      m,
      y,
      c,
      p,
      g + e.leading,
      f,
      l
    );
  }
  static _measureText(t, e, n) {
    let r = !1;
    Y.experimentalLetterSpacingSupported && (Y.experimentalLetterSpacing ? (n.letterSpacing = `${e}px`, n.textLetterSpacing = `${e}px`, r = !0) : (n.letterSpacing = "0px", n.textLetterSpacing = "0px"));
    const s = n.measureText(t);
    let o = s.width;
    const a = -s.actualBoundingBoxLeft;
    let l = s.actualBoundingBoxRight - a;
    if (o > 0)
      if (r)
        o -= e, l -= e;
      else {
        const h = (Y.graphemeSegmenter(t).length - 1) * e;
        o += h, l += h;
      }
    return Math.max(o, l);
  }
  /**
   * Applies newlines to a string to have it optimally fit into the horizontal
   * bounds set by the Text object's wordWrapWidth property.
   * @param text - String to apply word wrapping to
   * @param style - the style to use when wrapping
   * @param canvas - optional specification of the canvas to use for measuring.
   * @returns New string with new lines applied where required
   */
  static _wordWrap(t, e, n = Y._canvas) {
    const r = n.getContext("2d", Nl);
    let s = 0, o = "", a = "";
    const l = /* @__PURE__ */ Object.create(null), { letterSpacing: h, whiteSpace: c } = e, p = Y._collapseSpaces(c), f = Y._collapseNewlines(c);
    let d = !p;
    const m = e.wordWrapWidth + h, g = Y._tokenize(t);
    for (let y = 0; y < g.length; y++) {
      let b = g[y];
      if (Y._isNewline(b)) {
        if (!f) {
          a += Y._addLine(o), d = !p, o = "", s = 0;
          continue;
        }
        b = " ";
      }
      if (p) {
        const C = Y.isBreakingSpace(b), I = Y.isBreakingSpace(o[o.length - 1]);
        if (C && I)
          continue;
      }
      const S = Y._getFromCache(b, h, l, r);
      if (S > m)
        if (o !== "" && (a += Y._addLine(o), o = "", s = 0), Y.canBreakWords(b, e.breakWords)) {
          const C = Y.wordWrapSplit(b);
          for (let I = 0; I < C.length; I++) {
            let T = C[I], R = T, w = 1;
            for (; C[I + w]; ) {
              const x = C[I + w];
              if (!Y.canBreakChars(R, x, b, I, e.breakWords))
                T += x;
              else
                break;
              R = x, w++;
            }
            I += w - 1;
            const v = Y._getFromCache(T, h, l, r);
            v + s > m && (a += Y._addLine(o), d = !1, o = "", s = 0), o += T, s += v;
          }
        } else {
          o.length > 0 && (a += Y._addLine(o), o = "", s = 0);
          const C = y === g.length - 1;
          a += Y._addLine(b, !C), d = !1, o = "", s = 0;
        }
      else
        S + s > m && (d = !1, a += Y._addLine(o), o = "", s = 0), (o.length > 0 || !Y.isBreakingSpace(b) || d) && (o += b, s += S);
    }
    return a += Y._addLine(o, !1), a;
  }
  /**
   * Convenience function for logging each line added during the wordWrap method.
   * @param line    - The line of text to add
   * @param newLine - Add new line character to end
   * @returns A formatted line
   */
  static _addLine(t, e = !0) {
    return t = Y._trimRight(t), t = e ? `${t}
` : t, t;
  }
  /**
   * Gets & sets the widths of calculated characters in a cache object
   * @param key            - The key
   * @param letterSpacing  - The letter spacing
   * @param cache          - The cache
   * @param context        - The canvas context
   * @returns The from cache.
   */
  static _getFromCache(t, e, n, r) {
    let s = n[t];
    return typeof s != "number" && (s = Y._measureText(t, e, r) + e, n[t] = s), s;
  }
  /**
   * Determines whether we should collapse breaking spaces.
   * @param whiteSpace - The TextStyle property whiteSpace
   * @returns Should collapse
   */
  static _collapseSpaces(t) {
    return t === "normal" || t === "pre-line";
  }
  /**
   * Determines whether we should collapse newLine chars.
   * @param whiteSpace - The white space
   * @returns should collapse
   */
  static _collapseNewlines(t) {
    return t === "normal";
  }
  /**
   * Trims breaking whitespaces from string.
   * @param text - The text
   * @returns Trimmed string
   */
  static _trimRight(t) {
    if (typeof t != "string")
      return "";
    for (let e = t.length - 1; e >= 0; e--) {
      const n = t[e];
      if (!Y.isBreakingSpace(n))
        break;
      t = t.slice(0, -1);
    }
    return t;
  }
  /**
   * Determines if char is a newline.
   * @param char - The character
   * @returns True if newline, False otherwise.
   */
  static _isNewline(t) {
    return typeof t != "string" ? !1 : Y._newlines.includes(t.charCodeAt(0));
  }
  /**
   * Determines if char is a breaking whitespace.
   *
   * It allows one to determine whether char should be a breaking whitespace
   * For example certain characters in CJK langs or numbers.
   * It must return a boolean.
   * @param char - The character
   * @param [_nextChar] - The next character
   * @returns True if whitespace, False otherwise.
   */
  static isBreakingSpace(t, e) {
    return typeof t != "string" ? !1 : Y._breakingSpaces.includes(t.charCodeAt(0));
  }
  /**
   * Splits a string into words, breaking-spaces and newLine characters
   * @param text - The text
   * @returns A tokenized array
   */
  static _tokenize(t) {
    const e = [];
    let n = "";
    if (typeof t != "string")
      return e;
    for (let r = 0; r < t.length; r++) {
      const s = t[r], o = t[r + 1];
      if (Y.isBreakingSpace(s, o) || Y._isNewline(s)) {
        n !== "" && (e.push(n), n = ""), e.push(s);
        continue;
      }
      n += s;
    }
    return n !== "" && e.push(n), e;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It allows one to customise which words should break
   * Examples are if the token is CJK or numbers.
   * It must return a boolean.
   * @param _token - The token
   * @param breakWords - The style attr break words
   * @returns Whether to break word or not
   */
  static canBreakWords(t, e) {
    return e;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It allows one to determine whether a pair of characters
   * should be broken by newlines
   * For example certain characters in CJK langs or numbers.
   * It must return a boolean.
   * @param _char - The character
   * @param _nextChar - The next character
   * @param _token - The token/word the characters are from
   * @param _index - The index in the token of the char
   * @param _breakWords - The style attr break words
   * @returns whether to break word or not
   */
  static canBreakChars(t, e, n, r, s) {
    return !0;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It is called when a token (usually a word) has to be split into separate pieces
   * in order to determine the point to break a word.
   * It must return an array of characters.
   * @param token - The token to split
   * @returns The characters of the token
   * @see CanvasTextMetrics.graphemeSegmenter
   */
  static wordWrapSplit(t) {
    return Y.graphemeSegmenter(t);
  }
  /**
   * Calculates the ascent, descent and fontSize of a given font-style
   * @param font - String representing the style of the font
   * @returns Font properties object
   */
  static measureFont(t) {
    if (Y._fonts[t])
      return Y._fonts[t];
    const e = Y._context;
    e.font = t;
    const n = e.measureText(Y.METRICS_STRING + Y.BASELINE_SYMBOL), r = {
      ascent: n.actualBoundingBoxAscent,
      descent: n.actualBoundingBoxDescent,
      fontSize: n.actualBoundingBoxAscent + n.actualBoundingBoxDescent
    };
    return Y._fonts[t] = r, r;
  }
  /**
   * Clear font metrics in metrics cache.
   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
   */
  static clearMetrics(t = "") {
    t ? delete Y._fonts[t] : Y._fonts = {};
  }
  /**
   * Cached canvas element for measuring text
   * TODO: this should be private, but isn't because of backward compat, will fix later.
   * @ignore
   */
  static get _canvas() {
    if (!Y.__canvas) {
      let t;
      try {
        const e = new OffscreenCanvas(0, 0), n = e.getContext("2d", Nl);
        if (n != null && n.measureText)
          return Y.__canvas = e, e;
        t = Mt.get().createCanvas();
      } catch {
        t = Mt.get().createCanvas();
      }
      t.width = t.height = 10, Y.__canvas = t;
    }
    return Y.__canvas;
  }
  /**
   * TODO: this should be private, but isn't because of backward compat, will fix later.
   * @ignore
   */
  static get _context() {
    return Y.__context || (Y.__context = Y._canvas.getContext("2d", Nl)), Y.__context;
  }
};
hi.METRICS_STRING = "|ÉqÅ";
hi.BASELINE_SYMBOL = "M";
hi.BASELINE_MULTIPLIER = 1.4;
hi.HEIGHT_MULTIPLIER = 2;
hi.graphemeSegmenter = (() => {
  if (typeof (Intl == null ? void 0 : Intl.Segmenter) == "function") {
    const i = new Intl.Segmenter();
    return (t) => [...i.segment(t)].map((e) => e.segment);
  }
  return (i) => [...i];
})();
hi.experimentalLetterSpacing = !1;
hi._fonts = {};
hi._newlines = [
  10,
  // line feed
  13
  // carriage return
];
hi._breakingSpaces = [
  9,
  // character tabulation
  32,
  // space
  8192,
  // en quad
  8193,
  // em quad
  8194,
  // en space
  8195,
  // em space
  8196,
  // three-per-em space
  8197,
  // four-per-em space
  8198,
  // six-per-em space
  8200,
  // punctuation space
  8201,
  // thin space
  8202,
  // hair space
  8287,
  // medium mathematical space
  12288
  // ideographic space
];
hi._measurementCache = {};
let Eh = hi;
function tp(i, t) {
  if (i.texture === nt.WHITE && !i.fill)
    return Gt.shared.setValue(i.color).setAlpha(i.alpha ?? 1).toHexa();
  if (i.fill) {
    if (i.fill instanceof ka) {
      const e = i.fill, n = t.createPattern(e.texture.source.resource, "repeat"), r = e.transform.copyTo(ct.shared);
      return r.scale(
        e.texture.frame.width,
        e.texture.frame.height
      ), n.setTransform(r), n;
    } else if (i.fill instanceof Rs) {
      const e = i.fill;
      if (e.type === "linear") {
        const n = t.createLinearGradient(
          e.x0,
          e.y0,
          e.x1,
          e.y1
        );
        return e.gradientStops.forEach((r) => {
          n.addColorStop(r.offset, Gt.shared.setValue(r.color).toHex());
        }), n;
      }
    }
  } else {
    const e = t.createPattern(i.texture.source.resource, "repeat"), n = i.matrix.copyTo(ct.shared);
    return n.scale(i.texture.frame.width, i.texture.frame.height), e.setTransform(n), e;
  }
  return Lt("FillStyle not recognised", i), "red";
}
function Mm(i) {
  if (i === "")
    return [];
  typeof i == "string" && (i = [i]);
  const t = [];
  for (let e = 0, n = i.length; e < n; e++) {
    const r = i[e];
    if (Array.isArray(r)) {
      if (r.length !== 2)
        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${r.length}.`);
      if (r[0].length === 0 || r[1].length === 0)
        throw new Error("[BitmapFont]: Invalid character delimiter.");
      const s = r[0].charCodeAt(0), o = r[1].charCodeAt(0);
      if (o < s)
        throw new Error("[BitmapFont]: Invalid character range.");
      for (let a = s, l = o; a <= l; a++)
        t.push(String.fromCharCode(a));
    } else
      t.push(...Array.from(r));
  }
  if (t.length === 0)
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  return t;
}
const Om = class Dm extends pm {
  /**
   * @param options - The options for the dynamic bitmap font.
   */
  constructor(t) {
    super(), this.resolution = 1, this.pages = [], this._padding = 0, this._measureCache = /* @__PURE__ */ Object.create(null), this._currentChars = [], this._currentX = 0, this._currentY = 0, this._currentPageIndex = -1, this._skipKerning = !1;
    const e = { ...Dm.defaultOptions, ...t };
    this._textureSize = e.textureSize, this._mipmap = e.mipmap;
    const n = e.style.clone();
    e.overrideFill && (n._fill.color = 16777215, n._fill.alpha = 1, n._fill.texture = nt.WHITE, n._fill.fill = null), this.applyFillAsTint = e.overrideFill;
    const r = n.fontSize;
    n.fontSize = this.baseMeasurementFontSize;
    const s = Th(n);
    e.overrideSize ? n._stroke && (n._stroke.width *= this.baseRenderedFontSize / r) : n.fontSize = this.baseRenderedFontSize = r, this._style = n, this._skipKerning = e.skipKerning ?? !1, this.resolution = e.resolution ?? 1, this._padding = e.padding ?? 4, this.fontMetrics = Eh.measureFont(s), this.lineHeight = n.lineHeight || this.fontMetrics.fontSize || n.fontSize;
  }
  ensureCharacters(t) {
    var e, n;
    const r = Mm(t).filter((y) => !this._currentChars.includes(y)).filter((y, b, S) => S.indexOf(y) === b);
    if (!r.length)
      return;
    this._currentChars = [...this._currentChars, ...r];
    let s;
    this._currentPageIndex === -1 ? s = this._nextPage() : s = this.pages[this._currentPageIndex];
    let { canvas: o, context: a } = s.canvasAndContext, l = s.texture.source;
    const h = this._style;
    let c = this._currentX, p = this._currentY;
    const f = this.baseRenderedFontSize / this.baseMeasurementFontSize, d = this._padding * f;
    let m = 0, g = !1;
    for (let y = 0; y < r.length; y++) {
      const b = r[y], S = Eh.measureText(b, h, o, !1), C = Math.ceil((h.fontStyle === "italic" ? 2 : 1) * S.width);
      S.lineHeight = S.height;
      const I = S.width * f, T = S.height * f, R = C + d * 2, w = T + d * 2;
      if (g = !1, b !== `
` && b !== "\r" && b !== "	" && b !== " " && (g = !0, m = Math.ceil(Math.max(w, m))), c + R > this._textureSize && (p += m, m = w, c = 0, p + m > this._textureSize)) {
        l.update();
        const x = this._nextPage();
        o = x.canvasAndContext.canvas, a = x.canvasAndContext.context, l = x.texture.source, p = 0;
      }
      const v = I / f - (((e = h.dropShadow) == null ? void 0 : e.distance) ?? 0) - (((n = h._stroke) == null ? void 0 : n.width) ?? 0);
      if (this.chars[b] = {
        id: b.codePointAt(0),
        xOffset: -this._padding,
        yOffset: -this._padding,
        xAdvance: v,
        kerning: {}
      }, g) {
        this._drawGlyph(
          a,
          S,
          c + d,
          p + d,
          f,
          h
        );
        const x = l.width * f, A = l.height * f, P = new jt(
          c / x * l.width,
          p / A * l.height,
          R / x * l.width,
          w / A * l.height
        );
        this.chars[b].texture = new nt({
          source: l,
          frame: P
        }), c += Math.ceil(R);
      }
    }
    l.update(), this._currentX = c, this._currentY = p, this._skipKerning && this._applyKerning(r, a);
  }
  /**
   * @deprecated since 8.0.0
   * The map of base page textures (i.e., sheets of glyphs).
   */
  get pageTextures() {
    return ut(dt, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages;
  }
  _applyKerning(t, e) {
    const n = this._measureCache;
    for (let r = 0; r < t.length; r++) {
      const s = t[r];
      for (let o = 0; o < this._currentChars.length; o++) {
        const a = this._currentChars[o];
        let l = n[s];
        l || (l = n[s] = e.measureText(s).width);
        let h = n[a];
        h || (h = n[a] = e.measureText(a).width);
        let c = e.measureText(s + a).width, p = c - (l + h);
        p && (this.chars[s].kerning[a] = p), c = e.measureText(s + a).width, p = c - (l + h), p && (this.chars[a].kerning[s] = p);
      }
    }
  }
  _nextPage() {
    this._currentPageIndex++;
    const t = this.resolution, e = $d.getOptimalCanvasAndContext(
      this._textureSize,
      this._textureSize,
      t
    );
    this._setupContext(e.context, this._style, t);
    const n = t * (this.baseRenderedFontSize / this.baseMeasurementFontSize), r = new nt({
      source: new Rr({
        resource: e.canvas,
        resolution: n,
        alphaMode: "premultiply-alpha-on-upload",
        autoGenerateMipmaps: this._mipmap
      })
    }), s = {
      canvasAndContext: e,
      texture: r
    };
    return this.pages[this._currentPageIndex] = s, s;
  }
  // canvas style!
  _setupContext(t, e, n) {
    e.fontSize = this.baseRenderedFontSize, t.scale(n, n), t.font = Th(e), e.fontSize = this.baseMeasurementFontSize, t.textBaseline = e.textBaseline;
    const r = e._stroke, s = (r == null ? void 0 : r.width) ?? 0;
    if (r && (t.lineWidth = s, t.lineJoin = r.join, t.miterLimit = r.miterLimit, t.strokeStyle = tp(r, t)), e._fill && (t.fillStyle = tp(e._fill, t)), e.dropShadow) {
      const o = e.dropShadow, a = Gt.shared.setValue(o.color).toArray(), l = o.blur * n, h = o.distance * n;
      t.shadowColor = `rgba(${a[0] * 255},${a[1] * 255},${a[2] * 255},${o.alpha})`, t.shadowBlur = l, t.shadowOffsetX = Math.cos(o.angle) * h, t.shadowOffsetY = Math.sin(o.angle) * h;
    } else
      t.shadowColor = "black", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0;
  }
  _drawGlyph(t, e, n, r, s, o) {
    const a = e.text, l = e.fontProperties, h = o._stroke, c = ((h == null ? void 0 : h.width) ?? 0) * s, p = n + c / 2, f = r - c / 2, d = l.descent * s, m = e.lineHeight * s;
    o.stroke && c && t.strokeText(a, p, f + m - d), o._fill && t.fillText(a, p, f + m - d);
  }
  destroy() {
    super.destroy();
    for (let t = 0; t < this.pages.length; t++) {
      const { canvasAndContext: e, texture: n } = this.pages[t];
      $d.returnCanvasAndContext(e), n.destroy(!0);
    }
    this.pages = null;
  }
};
Om.defaultOptions = {
  textureSize: 512,
  style: new Dn(),
  mipmap: !0
};
let ep = Om;
function Sb(i, t, e, n) {
  const r = {
    width: 0,
    height: 0,
    offsetY: 0,
    scale: t.fontSize / e.baseMeasurementFontSize,
    lines: [{
      width: 0,
      charPositions: [],
      spaceWidth: 0,
      spacesIndex: [],
      chars: []
    }]
  };
  r.offsetY = e.baseLineOffset;
  let s = r.lines[0], o = null, a = !0;
  const l = {
    spaceWord: !1,
    width: 0,
    start: 0,
    index: 0,
    // use index to not modify the array as we use it a lot!
    positions: [],
    chars: []
  }, h = (m) => {
    const g = s.width;
    for (let y = 0; y < l.index; y++) {
      const b = m.positions[y];
      s.chars.push(m.chars[y]), s.charPositions.push(b + g);
    }
    s.width += m.width, a = !1, l.width = 0, l.index = 0, l.chars.length = 0;
  }, c = () => {
    let m = s.chars.length - 1;
    if (n) {
      let g = s.chars[m];
      for (; g === " "; )
        s.width -= e.chars[g].xAdvance, g = s.chars[--m];
    }
    r.width = Math.max(r.width, s.width), s = {
      width: 0,
      charPositions: [],
      chars: [],
      spaceWidth: 0,
      spacesIndex: []
    }, a = !0, r.lines.push(s), r.height += e.lineHeight;
  }, p = e.baseMeasurementFontSize / t.fontSize, f = t.letterSpacing * p, d = t.wordWrapWidth * p;
  for (let m = 0; m < i.length + 1; m++) {
    let g;
    const y = m === i.length;
    y || (g = i[m]);
    const b = e.chars[g] || e.chars[" "];
    if (/(?:\s)/.test(g) || g === "\r" || g === `
` || y) {
      if (!a && t.wordWrap && s.width + l.width - f > d ? (c(), h(l), y || s.charPositions.push(0)) : (l.start = s.width, h(l), y || s.charPositions.push(0)), g === "\r" || g === `
`)
        s.width !== 0 && c();
      else if (!y) {
        const S = b.xAdvance + (b.kerning[o] || 0) + f;
        s.width += S, s.spaceWidth = S, s.spacesIndex.push(s.charPositions.length), s.chars.push(g);
      }
    } else {
      const S = b.kerning[o] || 0, C = b.xAdvance + S + f;
      l.positions[l.index++] = l.width + S, l.chars.push(g), l.width += C;
    }
    o = g;
  }
  return c(), t.align === "center" ? Tb(r) : t.align === "right" ? Eb(r) : t.align === "justify" && Cb(r), r;
}
function Tb(i) {
  for (let t = 0; t < i.lines.length; t++) {
    const e = i.lines[t], n = i.width / 2 - e.width / 2;
    for (let r = 0; r < e.charPositions.length; r++)
      e.charPositions[r] += n;
  }
}
function Eb(i) {
  for (let t = 0; t < i.lines.length; t++) {
    const e = i.lines[t], n = i.width - e.width;
    for (let r = 0; r < e.charPositions.length; r++)
      e.charPositions[r] += n;
  }
}
function Cb(i) {
  const t = i.width;
  for (let e = 0; e < i.lines.length; e++) {
    const n = i.lines[e];
    let r = 0, s = n.spacesIndex[r++], o = 0;
    const a = n.spacesIndex.length, l = (t - n.width) / a;
    for (let h = 0; h < n.charPositions.length; h++)
      h === s && (s = n.spacesIndex[r++], o += l), n.charPositions[h] += o;
  }
}
let Po = 0;
class Pb {
  constructor() {
    this.ALPHA = [["a", "z"], ["A", "Z"], " "], this.NUMERIC = [["0", "9"]], this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], this.ASCII = [[" ", "~"]], this.defaultOptions = {
      chars: this.ALPHANUMERIC,
      resolution: 1,
      padding: 4,
      skipKerning: !1
    };
  }
  /**
   * Get a font for the specified text and style.
   * @param text - The text to get the font for
   * @param style - The style to use
   */
  getFont(t, e) {
    var n;
    let r = `${e.fontFamily}-bitmap`, s = !0;
    if (e._fill.fill && !e._stroke)
      r += e._fill.fill.styleKey, s = !1;
    else if (e._stroke || e.dropShadow) {
      let a = e.styleKey;
      a = a.substring(0, a.lastIndexOf("-")), r = `${a}-bitmap`, s = !1;
    }
    if (!It.has(r)) {
      const a = new ep({
        style: e,
        overrideFill: s,
        overrideSize: !0,
        ...this.defaultOptions
      });
      Po++, Po > 50 && Lt("BitmapText", `You have dynamically created ${Po} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``), a.once("destroy", () => {
        Po--, It.remove(r);
      }), It.set(
        r,
        a
      );
    }
    const o = It.get(r);
    return (n = o.ensureCharacters) == null || n.call(o, t), o;
  }
  /**
   * Get the layout of a text for the specified style.
   * @param text - The text to get the layout for
   * @param style - The style to use
   * @param trimEnd - Whether to ignore whitespaces at the end of each line
   */
  getLayout(t, e, n = !0) {
    const r = this.getFont(t, e);
    return Sb([...t], e, r, n);
  }
  /**
   * Measure the text using the specified style.
   * @param text - The text to measure
   * @param style - The style to use
   * @param trimEnd - Whether to ignore whitespaces at the end of each line
   */
  measureText(t, e, n = !0) {
    return this.getLayout(t, e, n);
  }
  // eslint-disable-next-line max-len
  install(...t) {
    var e, n, r, s;
    let o = t[0];
    typeof o == "string" && (o = {
      name: o,
      style: t[1],
      chars: (e = t[2]) == null ? void 0 : e.chars,
      resolution: (n = t[2]) == null ? void 0 : n.resolution,
      padding: (r = t[2]) == null ? void 0 : r.padding,
      skipKerning: (s = t[2]) == null ? void 0 : s.skipKerning
    }, ut(dt, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));
    const a = o == null ? void 0 : o.name;
    if (!a)
      throw new Error("[BitmapFontManager] Property `name` is required.");
    o = { ...this.defaultOptions, ...o };
    const l = o.style, h = l instanceof Dn ? l : new Dn(l), c = h._fill.fill !== null && h._fill.fill !== void 0, p = new ep({
      style: h,
      overrideFill: c,
      skipKerning: o.skipKerning,
      padding: o.padding,
      resolution: o.resolution,
      overrideSize: !1
    }), f = Mm(o.chars);
    return p.ensureCharacters(f.join("")), It.set(`${a}-bitmap`, p), p.once("destroy", () => It.remove(`${a}-bitmap`)), p;
  }
  /**
   * Uninstalls a bitmap font from the cache.
   * @param {string} name - The name of the bitmap font to uninstall.
   */
  uninstall(t) {
    const e = `${t}-bitmap`, n = It.get(e);
    n && n.destroy();
  }
}
const Ch = new Pb();
class Bm extends pm {
  constructor(t, e) {
    super();
    const { textures: n, data: r } = t;
    Object.keys(r.pages).forEach((s) => {
      const o = r.pages[parseInt(s, 10)], a = n[o.id];
      this.pages.push({ texture: a });
    }), Object.keys(r.chars).forEach((s) => {
      const o = r.chars[s], {
        frame: a,
        source: l
      } = n[o.page], h = new jt(
        o.x + a.x,
        o.y + a.y,
        o.width,
        o.height
      ), c = new nt({
        source: l,
        frame: h
      });
      this.chars[s] = {
        id: s.codePointAt(0),
        xOffset: o.xOffset,
        yOffset: o.yOffset,
        xAdvance: o.xAdvance,
        kerning: o.kerning ?? {},
        texture: c
      };
    }), this.baseRenderedFontSize = r.fontSize, this.baseMeasurementFontSize = r.fontSize, this.fontMetrics = {
      ascent: 0,
      descent: 0,
      fontSize: r.fontSize
    }, this.baseLineOffset = r.baseLineOffset, this.lineHeight = r.lineHeight, this.fontFamily = r.fontFamily, this.distanceField = r.distanceField ?? {
      type: "none",
      range: 0
    }, this.url = e;
  }
  /** Destroys the BitmapFont object. */
  destroy() {
    super.destroy();
    for (let t = 0; t < this.pages.length; t++) {
      const { texture: e } = this.pages[t];
      e.destroy(!0);
    }
    this.pages = null;
  }
  /**
   * Generates a bitmap-font for the given style and character set
   * @param options - Setup options for font generation.
   * @returns Font generated by style options.
   * @example
   * import { BitmapFont, BitmapText } from 'pixi.js';
   *
   * BitmapFont.install('TitleFont', {
   *     fontFamily: 'Arial',
   *     fontSize: 12,
   *     strokeThickness: 2,
   *     fill: 'purple',
   * });
   *
   * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });
   */
  static install(t) {
    Ch.install(t);
  }
  /**
   * Uninstalls a bitmap font from the cache.
   * @param {string} name - The name of the bitmap font to uninstall.
   */
  static uninstall(t) {
    Ch.uninstall(t);
  }
}
const Ul = {
  test(i) {
    return typeof i == "string" && i.startsWith("info face=");
  },
  parse(i) {
    const t = i.match(/^[a-z]+\s+.+$/gm), e = {
      info: [],
      common: [],
      page: [],
      char: [],
      chars: [],
      kerning: [],
      kernings: [],
      distanceField: []
    };
    for (const p in t) {
      const f = t[p].match(/^[a-z]+/gm)[0], d = t[p].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), m = {};
      for (const g in d) {
        const y = d[g].split("="), b = y[0], S = y[1].replace(/"/gm, ""), C = parseFloat(S), I = isNaN(C) ? S : C;
        m[b] = I;
      }
      e[f].push(m);
    }
    const n = {
      chars: {},
      pages: [],
      lineHeight: 0,
      fontSize: 0,
      fontFamily: "",
      distanceField: null,
      baseLineOffset: 0
    }, [r] = e.info, [s] = e.common, [o] = e.distanceField ?? [];
    o && (n.distanceField = {
      range: parseInt(o.distanceRange, 10),
      type: o.fieldType
    }), n.fontSize = parseInt(r.size, 10), n.fontFamily = r.face, n.lineHeight = parseInt(s.lineHeight, 10);
    const a = e.page;
    for (let p = 0; p < a.length; p++)
      n.pages.push({
        id: parseInt(a[p].id, 10) || 0,
        file: a[p].file
      });
    const l = {};
    n.baseLineOffset = n.lineHeight - parseInt(s.base, 10);
    const h = e.char;
    for (let p = 0; p < h.length; p++) {
      const f = h[p], d = parseInt(f.id, 10);
      let m = f.letter ?? f.char ?? String.fromCharCode(d);
      m === "space" && (m = " "), l[d] = m, n.chars[m] = {
        id: d,
        // texture deets..
        page: parseInt(f.page, 10) || 0,
        x: parseInt(f.x, 10),
        y: parseInt(f.y, 10),
        width: parseInt(f.width, 10),
        height: parseInt(f.height, 10),
        xOffset: parseInt(f.xoffset, 10),
        yOffset: parseInt(f.yoffset, 10),
        xAdvance: parseInt(f.xadvance, 10),
        kerning: {}
      };
    }
    const c = e.kerning || [];
    for (let p = 0; p < c.length; p++) {
      const f = parseInt(c[p].first, 10), d = parseInt(c[p].second, 10), m = parseInt(c[p].amount, 10);
      n.chars[l[d]].kerning[l[f]] = m;
    }
    return n;
  }
}, ip = {
  test(i) {
    const t = i;
    return typeof t != "string" && "getElementsByTagName" in t && t.getElementsByTagName("page").length && t.getElementsByTagName("info")[0].getAttribute("face") !== null;
  },
  parse(i) {
    const t = {
      chars: {},
      pages: [],
      lineHeight: 0,
      fontSize: 0,
      fontFamily: "",
      distanceField: null,
      baseLineOffset: 0
    }, e = i.getElementsByTagName("info")[0], n = i.getElementsByTagName("common")[0], r = i.getElementsByTagName("distanceField")[0];
    r && (t.distanceField = {
      type: r.getAttribute("fieldType"),
      range: parseInt(r.getAttribute("distanceRange"), 10)
    });
    const s = i.getElementsByTagName("page"), o = i.getElementsByTagName("char"), a = i.getElementsByTagName("kerning");
    t.fontSize = parseInt(e.getAttribute("size"), 10), t.fontFamily = e.getAttribute("face"), t.lineHeight = parseInt(n.getAttribute("lineHeight"), 10);
    for (let h = 0; h < s.length; h++)
      t.pages.push({
        id: parseInt(s[h].getAttribute("id"), 10) || 0,
        file: s[h].getAttribute("file")
      });
    const l = {};
    t.baseLineOffset = t.lineHeight - parseInt(n.getAttribute("base"), 10);
    for (let h = 0; h < o.length; h++) {
      const c = o[h], p = parseInt(c.getAttribute("id"), 10);
      let f = c.getAttribute("letter") ?? c.getAttribute("char") ?? String.fromCharCode(p);
      f === "space" && (f = " "), l[p] = f, t.chars[f] = {
        id: p,
        // texture deets..
        page: parseInt(c.getAttribute("page"), 10) || 0,
        x: parseInt(c.getAttribute("x"), 10),
        y: parseInt(c.getAttribute("y"), 10),
        width: parseInt(c.getAttribute("width"), 10),
        height: parseInt(c.getAttribute("height"), 10),
        // render deets..
        xOffset: parseInt(c.getAttribute("xoffset"), 10),
        yOffset: parseInt(c.getAttribute("yoffset"), 10),
        // + baseLineOffset,
        xAdvance: parseInt(c.getAttribute("xadvance"), 10),
        kerning: {}
      };
    }
    for (let h = 0; h < a.length; h++) {
      const c = parseInt(a[h].getAttribute("first"), 10), p = parseInt(a[h].getAttribute("second"), 10), f = parseInt(a[h].getAttribute("amount"), 10);
      t.chars[l[p]].kerning[l[c]] = f;
    }
    return t;
  }
}, np = {
  test(i) {
    return typeof i == "string" && i.includes("<font>") ? ip.test(Mt.get().parseXML(i)) : !1;
  },
  parse(i) {
    return ip.parse(Mt.get().parseXML(i));
  }
}, Ib = [".xml", ".fnt"], Rb = {
  extension: {
    type: X.CacheParser,
    name: "cacheBitmapFont"
  },
  test: (i) => i instanceof Bm,
  getCacheableAssets(i, t) {
    const e = {};
    return i.forEach((n) => {
      e[n] = t, e[`${n}-bitmap`] = t;
    }), e[`${t.fontFamily}-bitmap`] = t, e;
  }
}, kb = {
  extension: {
    type: X.LoadParser,
    priority: Li.Normal
  },
  name: "loadBitmapFont",
  test(i) {
    return Ib.includes(ae.extname(i).toLowerCase());
  },
  async testParse(i) {
    return Ul.test(i) || np.test(i);
  },
  async parse(i, t, e) {
    const n = Ul.test(i) ? Ul.parse(i) : np.parse(i), { src: r } = t, { pages: s } = n, o = [], a = n.distanceField ? {
      scaleMode: "linear",
      alphaMode: "premultiply-alpha-on-upload",
      autoGenerateMipmaps: !1,
      resolution: 1
    } : {};
    for (let c = 0; c < s.length; ++c) {
      const p = s[c].file;
      let f = ae.join(ae.dirname(r), p);
      f = dh(f, r), o.push({
        src: f,
        data: a
      });
    }
    const l = await e.load(o), h = o.map((c) => l[c.src]);
    return new Bm({
      data: n,
      textures: h
    }, r);
  },
  async load(i, t) {
    return await (await Mt.get().fetch(i)).text();
  },
  async unload(i, t, e) {
    await Promise.all(i.pages.map((n) => e.unload(n.texture.source._sourceOrigin))), i.destroy();
  }
};
class Mb {
  /**
   * @param loader
   * @param verbose - should the loader log to the console
   */
  constructor(t, e = !1) {
    this._loader = t, this._assetList = [], this._isLoading = !1, this._maxConcurrent = 1, this.verbose = e;
  }
  /**
   * Adds an array of assets to load.
   * @param assetUrls - assets to load
   */
  add(t) {
    t.forEach((e) => {
      this._assetList.push(e);
    }), this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList), this._isActive && !this._isLoading && this._next();
  }
  /**
   * Loads the next set of assets. Will try to load as many assets as it can at the same time.
   *
   * The max assets it will try to load at one time will be 4.
   */
  async _next() {
    if (this._assetList.length && this._isActive) {
      this._isLoading = !0;
      const t = [], e = Math.min(this._assetList.length, this._maxConcurrent);
      for (let n = 0; n < e; n++)
        t.push(this._assetList.pop());
      await this._loader.load(t), this._isLoading = !1, this._next();
    }
  }
  /**
   * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.
   * @returns whether the class is active
   */
  get active() {
    return this._isActive;
  }
  set active(t) {
    this._isActive !== t && (this._isActive = t, t && !this._isLoading && this._next());
  }
}
const Ob = {
  extension: {
    type: X.CacheParser,
    name: "cacheTextureArray"
  },
  test: (i) => Array.isArray(i) && i.every((t) => t instanceof nt),
  getCacheableAssets: (i, t) => {
    const e = {};
    return i.forEach((n) => {
      t.forEach((r, s) => {
        e[n + (s === 0 ? "" : s + 1)] = r;
      });
    }), e;
  }
};
async function Vm(i) {
  if ("Image" in globalThis)
    return new Promise((t) => {
      const e = new Image();
      e.onload = () => {
        t(!0);
      }, e.onerror = () => {
        t(!1);
      }, e.src = i;
    });
  if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
    try {
      const t = await (await fetch(i)).blob();
      await createImageBitmap(t);
    } catch {
      return !1;
    }
    return !0;
  }
  return !1;
}
const Db = {
  extension: {
    type: X.DetectionParser,
    priority: 1
  },
  test: async () => Vm(
    // eslint-disable-next-line max-len
    "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="
  ),
  add: async (i) => [...i, "avif"],
  remove: async (i) => i.filter((t) => t !== "avif")
}, rp = ["png", "jpg", "jpeg"], Bb = {
  extension: {
    type: X.DetectionParser,
    priority: -1
  },
  test: () => Promise.resolve(!0),
  add: async (i) => [...i, ...rp],
  remove: async (i) => i.filter((t) => !rp.includes(t))
}, Vb = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
function xc(i) {
  return Vb ? !1 : document.createElement("video").canPlayType(i) !== "";
}
const Fb = {
  extension: {
    type: X.DetectionParser,
    priority: 0
  },
  test: async () => xc("video/mp4"),
  add: async (i) => [...i, "mp4", "m4v"],
  remove: async (i) => i.filter((t) => t !== "mp4" && t !== "m4v")
}, Lb = {
  extension: {
    type: X.DetectionParser,
    priority: 0
  },
  test: async () => xc("video/ogg"),
  add: async (i) => [...i, "ogv"],
  remove: async (i) => i.filter((t) => t !== "ogv")
}, Nb = {
  extension: {
    type: X.DetectionParser,
    priority: 0
  },
  test: async () => xc("video/webm"),
  add: async (i) => [...i, "webm"],
  remove: async (i) => i.filter((t) => t !== "webm")
}, Ub = {
  extension: {
    type: X.DetectionParser,
    priority: 0
  },
  test: async () => Vm(
    "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="
  ),
  add: async (i) => [...i, "webp"],
  remove: async (i) => i.filter((t) => t !== "webp")
};
class zb {
  constructor() {
    this._parsers = [], this._parsersValidated = !1, this.parsers = new Proxy(this._parsers, {
      set: (t, e, n) => (this._parsersValidated = !1, t[e] = n, !0)
    }), this.promiseCache = {};
  }
  /** function used for testing */
  reset() {
    this._parsersValidated = !1, this.promiseCache = {};
  }
  /**
   * Used internally to generate a promise for the asset to be loaded.
   * @param url - The URL to be loaded
   * @param data - any custom additional information relevant to the asset being loaded
   * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object
   */
  _getLoadPromiseAndParser(t, e) {
    const n = {
      promise: null,
      parser: null
    };
    return n.promise = (async () => {
      var r, s;
      let o = null, a = null;
      if (e.loadParser && (a = this._parserHash[e.loadParser], a || Lt(`[Assets] specified load parser "${e.loadParser}" not found while loading ${t}`)), !a) {
        for (let l = 0; l < this.parsers.length; l++) {
          const h = this.parsers[l];
          if (h.load && (r = h.test) != null && r.call(h, t, e, this)) {
            a = h;
            break;
          }
        }
        if (!a)
          return Lt(`[Assets] ${t} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`), null;
      }
      o = await a.load(t, e, this), n.parser = a;
      for (let l = 0; l < this.parsers.length; l++) {
        const h = this.parsers[l];
        h.parse && h.parse && await ((s = h.testParse) == null ? void 0 : s.call(h, o, e, this)) && (o = await h.parse(o, e, this) || o, n.parser = h);
      }
      return o;
    })(), n;
  }
  async load(t, e) {
    this._parsersValidated || this._validateParsers();
    let n = 0;
    const r = {}, s = Ko(t), o = si(t, (h) => ({
      alias: [h],
      src: h,
      data: {}
    })), a = o.length, l = o.map(async (h) => {
      const c = ae.toAbsolute(h.src);
      if (!r[h.src])
        try {
          this.promiseCache[c] || (this.promiseCache[c] = this._getLoadPromiseAndParser(c, h)), r[h.src] = await this.promiseCache[c].promise, e && e(++n / a);
        } catch (p) {
          throw delete this.promiseCache[c], delete r[h.src], new Error(`[Loader.load] Failed to load ${c}.
${p}`);
        }
    });
    return await Promise.all(l), s ? r[o[0].src] : r;
  }
  /**
   * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.
   * The parser that created the asset, will be the one that unloads it.
   * @example
   * // Single asset:
   * const asset = await Loader.load('cool.png');
   *
   * await Loader.unload('cool.png');
   *
   * console.log(asset.destroyed); // true
   * @param assetsToUnloadIn - urls that you want to unload, or a single one!
   */
  async unload(t) {
    const e = si(t, (n) => ({
      alias: [n],
      src: n
    })).map(async (n) => {
      var r, s;
      const o = ae.toAbsolute(n.src), a = this.promiseCache[o];
      if (a) {
        const l = await a.promise;
        delete this.promiseCache[o], await ((s = (r = a.parser) == null ? void 0 : r.unload) == null ? void 0 : s.call(r, l, n, this));
      }
    });
    await Promise.all(e);
  }
  /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */
  _validateParsers() {
    this._parsersValidated = !0, this._parserHash = this._parsers.filter((t) => t.name).reduce((t, e) => (e.name ? t[e.name] && Lt(`[Assets] loadParser name conflict "${e.name}"`) : Lt("[Assets] loadParser should have a name"), { ...t, [e.name]: e }), {});
  }
}
function Mr(i, t) {
  if (Array.isArray(t)) {
    for (const e of t)
      if (i.startsWith(`data:${e}`))
        return !0;
    return !1;
  }
  return i.startsWith(`data:${t}`);
}
function Or(i, t) {
  const e = i.split("?")[0], n = ae.extname(e).toLowerCase();
  return Array.isArray(t) ? t.includes(n) : n === t;
}
const jb = ".json", Gb = "application/json", Hb = {
  extension: {
    type: X.LoadParser,
    priority: Li.Low
  },
  name: "loadJson",
  test(i) {
    return Mr(i, Gb) || Or(i, jb);
  },
  async load(i) {
    return await (await Mt.get().fetch(i)).json();
  }
}, Wb = ".txt", qb = "text/plain", Yb = {
  name: "loadTxt",
  extension: {
    type: X.LoadParser,
    priority: Li.Low,
    name: "loadTxt"
  },
  test(i) {
    return Mr(i, qb) || Or(i, Wb);
  },
  async load(i) {
    return await (await Mt.get().fetch(i)).text();
  }
}, Xb = [
  "normal",
  "bold",
  "100",
  "200",
  "300",
  "400",
  "500",
  "600",
  "700",
  "800",
  "900"
], Kb = [".ttf", ".otf", ".woff", ".woff2"], Qb = [
  "font/ttf",
  "font/otf",
  "font/woff",
  "font/woff2"
], Jb = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
function Zb(i) {
  const t = ae.extname(i), e = ae.basename(i, t).replace(/(-|_)/g, " ").toLowerCase().split(" ").map((s) => s.charAt(0).toUpperCase() + s.slice(1));
  let n = e.length > 0;
  for (const s of e)
    if (!s.match(Jb)) {
      n = !1;
      break;
    }
  let r = e.join(" ");
  return n || (r = `"${r.replace(/[\\"]/g, "\\$&")}"`), r;
}
const $b = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
function t1(i) {
  return $b.test(i) ? i : encodeURI(i);
}
const e1 = {
  extension: {
    type: X.LoadParser,
    priority: Li.Low
  },
  name: "loadWebFont",
  test(i) {
    return Mr(i, Qb) || Or(i, Kb);
  },
  async load(i, t) {
    var e, n, r;
    const s = Mt.get().getFontFaceSet();
    if (s) {
      const o = [], a = ((e = t.data) == null ? void 0 : e.family) ?? Zb(i), l = ((r = (n = t.data) == null ? void 0 : n.weights) == null ? void 0 : r.filter((c) => Xb.includes(c))) ?? ["normal"], h = t.data ?? {};
      for (let c = 0; c < l.length; c++) {
        const p = l[c], f = new FontFace(a, `url(${t1(i)})`, {
          ...h,
          weight: p
        });
        await f.load(), s.add(f), o.push(f);
      }
      return It.set(`${a}-and-url`, {
        url: i,
        fontFaces: o
      }), o.length === 1 ? o[0] : o;
    }
    return Lt("[loadWebFont] FontFace API is not supported. Skipping loading font"), null;
  },
  unload(i) {
    (Array.isArray(i) ? i : [i]).forEach((t) => {
      It.remove(t.family), Mt.get().getFontFaceSet().delete(t);
    });
  }
};
function bc(i, t = 1) {
  var e;
  const n = (e = kr.RETINA_PREFIX) == null ? void 0 : e.exec(i);
  return n ? parseFloat(n[1]) : t;
}
function wc(i, t, e) {
  i.label = e, i._sourceOrigin = e;
  const n = new nt({
    source: i,
    label: e
  }), r = () => {
    delete t.promiseCache[e], It.has(e) && It.remove(e);
  };
  return n.source.once("destroy", () => {
    t.promiseCache[e] && (Lt("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource."), r());
  }), n.once("destroy", () => {
    i.destroyed || (Lt("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."), r());
  }), n;
}
const i1 = ".svg", n1 = "image/svg+xml", r1 = {
  extension: {
    type: X.LoadParser,
    priority: Li.Low,
    name: "loadSVG"
  },
  name: "loadSVG",
  config: {
    crossOrigin: "anonymous",
    parseAsGraphicsContext: !1
  },
  test(i) {
    return Mr(i, n1) || Or(i, i1);
  },
  async load(i, t, e) {
    return t.data.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext ? o1(i) : s1(i, t, e, this.config.crossOrigin);
  },
  unload(i) {
    i.destroy(!0);
  }
};
async function s1(i, t, e, n) {
  var r, s, o;
  const a = await (await Mt.get().fetch(i)).blob(), l = URL.createObjectURL(a), h = new Image();
  h.src = l, h.crossOrigin = n, await h.decode(), URL.revokeObjectURL(l);
  const c = document.createElement("canvas"), p = c.getContext("2d"), f = ((r = t.data) == null ? void 0 : r.resolution) || bc(i), d = ((s = t.data) == null ? void 0 : s.width) ?? h.width, m = ((o = t.data) == null ? void 0 : o.height) ?? h.height;
  c.width = d * f, c.height = m * f, p.drawImage(h, 0, 0, d * f, m * f);
  const { parseAsGraphicsContext: g, ...y } = t.data, b = new Rr({
    resource: c,
    alphaMode: "premultiply-alpha-on-upload",
    resolution: f,
    ...y
  });
  return wc(b, e, i);
}
async function o1(i) {
  const t = await (await Mt.get().fetch(i)).text(), e = new Qe();
  return e.svg(t), e;
}
const a1 = `(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;
let hr = null, Ph = class {
  constructor() {
    hr || (hr = URL.createObjectURL(new Blob([a1], { type: "application/javascript" }))), this.worker = new Worker(hr);
  }
};
Ph.revokeObjectURL = function() {
  hr && (URL.revokeObjectURL(hr), hr = null);
};
const l1 = `(function () {
    'use strict';

    async function loadImageBitmap(url, alphaMode) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
      }
      const imageBlob = await response.blob();
      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);
    }
    self.onmessage = async (event) => {
      try {
        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);
        self.postMessage({
          data: imageBitmap,
          uuid: event.data.uuid,
          id: event.data.id
        }, [imageBitmap]);
      } catch (e) {
        self.postMessage({
          error: e,
          uuid: event.data.uuid,
          id: event.data.id
        });
      }
    };

})();
`;
let cr = null;
class Fm {
  constructor() {
    cr || (cr = URL.createObjectURL(new Blob([l1], { type: "application/javascript" }))), this.worker = new Worker(cr);
  }
}
Fm.revokeObjectURL = function() {
  cr && (URL.revokeObjectURL(cr), cr = null);
};
let sp = 0, zl;
class h1 {
  constructor() {
    this._initialized = !1, this._createdWorkers = 0, this._workerPool = [], this._queue = [], this._resolveHash = {};
  }
  isImageBitmapSupported() {
    return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise((t) => {
      const { worker: e } = new Ph();
      e.addEventListener("message", (n) => {
        e.terminate(), Ph.revokeObjectURL(), t(n.data);
      });
    }), this._isImageBitmapSupported);
  }
  loadImageBitmap(t, e) {
    var n;
    return this._run("loadImageBitmap", [t, (n = e == null ? void 0 : e.data) == null ? void 0 : n.alphaMode]);
  }
  async _initWorkers() {
    this._initialized || (this._initialized = !0);
  }
  _getWorker() {
    zl === void 0 && (zl = navigator.hardwareConcurrency || 4);
    let t = this._workerPool.pop();
    return !t && this._createdWorkers < zl && (this._createdWorkers++, t = new Fm().worker, t.addEventListener("message", (e) => {
      this._complete(e.data), this._returnWorker(e.target), this._next();
    })), t;
  }
  _returnWorker(t) {
    this._workerPool.push(t);
  }
  _complete(t) {
    t.error !== void 0 ? this._resolveHash[t.uuid].reject(t.error) : this._resolveHash[t.uuid].resolve(t.data), this._resolveHash[t.uuid] = null;
  }
  async _run(t, e) {
    await this._initWorkers();
    const n = new Promise((r, s) => {
      this._queue.push({ id: t, arguments: e, resolve: r, reject: s });
    });
    return this._next(), n;
  }
  _next() {
    if (!this._queue.length)
      return;
    const t = this._getWorker();
    if (!t)
      return;
    const e = this._queue.pop(), n = e.id;
    this._resolveHash[sp] = { resolve: e.resolve, reject: e.reject }, t.postMessage({
      data: e.arguments,
      uuid: sp++,
      id: n
    });
  }
}
const op = new h1(), c1 = [".jpeg", ".jpg", ".png", ".webp", ".avif"], u1 = [
  "image/jpeg",
  "image/png",
  "image/webp",
  "image/avif"
];
async function d1(i, t) {
  var e;
  const n = await Mt.get().fetch(i);
  if (!n.ok)
    throw new Error(`[loadImageBitmap] Failed to fetch ${i}: ${n.status} ${n.statusText}`);
  const r = await n.blob();
  return ((e = t == null ? void 0 : t.data) == null ? void 0 : e.alphaMode) === "premultiplied-alpha" ? createImageBitmap(r, { premultiplyAlpha: "none" }) : createImageBitmap(r);
}
const Lm = {
  name: "loadTextures",
  extension: {
    type: X.LoadParser,
    priority: Li.High,
    name: "loadTextures"
  },
  config: {
    preferWorkers: !0,
    preferCreateImageBitmap: !0,
    crossOrigin: "anonymous"
  },
  test(i) {
    return Mr(i, u1) || Or(i, c1);
  },
  async load(i, t, e) {
    var n;
    let r = null;
    globalThis.createImageBitmap && this.config.preferCreateImageBitmap ? this.config.preferWorkers && await op.isImageBitmapSupported() ? r = await op.loadImageBitmap(i, t) : r = await d1(i, t) : r = await new Promise((o) => {
      r = new Image(), r.crossOrigin = this.config.crossOrigin, r.src = i, r.complete ? o(r) : r.onload = () => {
        o(r);
      };
    });
    const s = new Rr({
      resource: r,
      alphaMode: "premultiply-alpha-on-upload",
      resolution: ((n = t.data) == null ? void 0 : n.resolution) || bc(i),
      ...t.data
    });
    return wc(s, e, i);
  },
  unload(i) {
    i.destroy(!0);
  }
}, Nm = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"], p1 = Nm.map((i) => `video/${i.substring(1)}`);
function f1(i, t, e) {
  e === void 0 && !t.startsWith("data:") ? i.crossOrigin = g1(t) : e !== !1 && (i.crossOrigin = typeof e == "string" ? e : "anonymous");
}
function m1(i) {
  return new Promise((t, e) => {
    i.addEventListener("canplaythrough", n), i.addEventListener("error", r), i.load();
    function n() {
      s(), t();
    }
    function r(o) {
      s(), e(o);
    }
    function s() {
      i.removeEventListener("canplaythrough", n), i.removeEventListener("error", r);
    }
  });
}
function g1(i, t = globalThis.location) {
  if (i.startsWith("data:"))
    return "";
  t = t || globalThis.location;
  const e = new URL(i, document.baseURI);
  return e.hostname !== t.hostname || e.port !== t.port || e.protocol !== t.protocol ? "anonymous" : "";
}
const y1 = {
  name: "loadVideo",
  extension: {
    type: X.LoadParser,
    name: "loadVideo"
  },
  test(i) {
    const t = Mr(i, p1), e = Or(i, Nm);
    return t || e;
  },
  async load(i, t, e) {
    var n, r;
    const s = {
      ...Vo.defaultOptions,
      resolution: ((n = t.data) == null ? void 0 : n.resolution) || bc(i),
      alphaMode: ((r = t.data) == null ? void 0 : r.alphaMode) || await Gf(),
      ...t.data
    }, o = document.createElement("video"), a = {
      preload: s.autoLoad !== !1 ? "auto" : void 0,
      "webkit-playsinline": s.playsinline !== !1 ? "" : void 0,
      playsinline: s.playsinline !== !1 ? "" : void 0,
      muted: s.muted === !0 ? "" : void 0,
      loop: s.loop === !0 ? "" : void 0,
      autoplay: s.autoPlay !== !1 ? "" : void 0
    };
    Object.keys(a).forEach((c) => {
      const p = a[c];
      p !== void 0 && o.setAttribute(c, p);
    }), s.muted === !0 && (o.muted = !0), f1(o, i, s.crossorigin);
    const l = document.createElement("source");
    let h;
    if (i.startsWith("data:"))
      h = i.slice(5, i.indexOf(";"));
    else if (!i.startsWith("blob:")) {
      const c = i.split("?")[0].slice(i.lastIndexOf(".") + 1).toLowerCase();
      h = Vo.MIME_TYPES[c] || `video/${c}`;
    }
    return l.src = i, h && (l.type = h), new Promise((c) => {
      const p = async () => {
        const f = new Vo({ ...s, resource: o });
        o.removeEventListener("canplay", p), t.data.preload && await m1(o), c(wc(f, e, i));
      };
      o.addEventListener("canplay", p), o.appendChild(l);
    });
  },
  unload(i) {
    i.destroy(!0);
  }
}, Um = {
  extension: {
    type: X.ResolveParser,
    name: "resolveTexture"
  },
  test: Lm.test,
  parse: (i) => {
    var t;
    return {
      resolution: parseFloat(((t = kr.RETINA_PREFIX.exec(i)) == null ? void 0 : t[1]) ?? "1"),
      format: i.split(".").pop(),
      src: i
    };
  }
}, v1 = {
  extension: {
    type: X.ResolveParser,
    priority: -2,
    name: "resolveJson"
  },
  test: (i) => kr.RETINA_PREFIX.test(i) && i.endsWith(".json"),
  parse: Um.parse
};
class _1 {
  constructor() {
    this._detections = [], this._initialized = !1, this.resolver = new kr(), this.loader = new zb(), this.cache = It, this._backgroundLoader = new Mb(this.loader), this._backgroundLoader.active = !0, this.reset();
  }
  /**
   * Best practice is to call this function before any loading commences
   * Initiating is the best time to add any customization to the way things are loaded.
   *
   * you do not need to call this for the Assets class to work, only if you want to set any initial properties
   * @param options - options to initialize the Assets manager with
   */
  async init(t = {}) {
    var e, n;
    if (this._initialized) {
      Lt("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");
      return;
    }
    if (this._initialized = !0, t.defaultSearchParams && this.resolver.setDefaultSearchParams(t.defaultSearchParams), t.basePath && (this.resolver.basePath = t.basePath), t.bundleIdentifier && this.resolver.setBundleIdentifier(t.bundleIdentifier), t.manifest) {
      let a = t.manifest;
      typeof a == "string" && (a = await this.load(a)), this.resolver.addManifest(a);
    }
    const r = ((e = t.texturePreference) == null ? void 0 : e.resolution) ?? 1, s = typeof r == "number" ? [r] : r, o = await this._detectFormats({
      preferredFormats: (n = t.texturePreference) == null ? void 0 : n.format,
      skipDetections: t.skipDetections,
      detections: this._detections
    });
    this.resolver.prefer({
      params: {
        format: o,
        resolution: s
      }
    }), t.preferences && this.setPreferences(t.preferences);
  }
  /**
   * Allows you to specify how to resolve any assets load requests.
   * There are a few ways to add things here as shown below:
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Simple
   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.png'});
   * const bunny = await Assets.load('bunnyBooBoo');
   *
   * // Multiple keys:
   * Assets.add({alias: ['burger', 'chicken'], src: 'bunny.png'});
   *
   * const bunny = await Assets.load('burger');
   * const bunny2 = await Assets.load('chicken');
   *
   * // passing options to to the object
   * Assets.add({
   *     alias: 'bunnyBooBooSmooth',
   *     src: 'bunny{png,webp}',
   *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options
   * });
   *
   * // Multiple assets
   *
   * // The following all do the same thing:
   *
   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny{png,webp}'});
   *
   * Assets.add({
   *     alias: 'bunnyBooBoo',
   *     src: [
   *         'bunny.png',
   *         'bunny.webp',
   *    ],
   * });
   *
   * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available
   * @param assets - the unresolved assets to add to the resolver
   */
  add(t) {
    this.resolver.add(t);
  }
  async load(t, e) {
    this._initialized || await this.init();
    const n = Ko(t), r = si(t).map((a) => {
      if (typeof a != "string") {
        const l = this.resolver.getAlias(a);
        return l.some((h) => !this.resolver.hasKey(h)) && this.add(a), Array.isArray(l) ? l[0] : l;
      }
      return this.resolver.hasKey(a) || this.add({ alias: a, src: a }), a;
    }), s = this.resolver.resolve(r), o = await this._mapLoadToResolve(s, e);
    return n ? o[r[0]] : o;
  }
  /**
   * This adds a bundle of assets in one go so that you can load them as a group.
   * For example you could add a bundle for each screen in you pixi app
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.addBundle('animals', [
   *  { alias: 'bunny', src: 'bunny.png' },
   *  { alias: 'chicken', src: 'chicken.png' },
   *  { alias: 'thumper', src: 'thumper.png' },
   * ]);
   * // or
   * Assets.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * const assets = await Assets.loadBundle('animals');
   * @param bundleId - the id of the bundle to add
   * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key
   */
  addBundle(t, e) {
    this.resolver.addBundle(t, e);
  }
  /**
   * Bundles are a way to load multiple assets at once.
   * If a manifest has been provided to the init function then you can load a bundle, or bundles.
   * you can also add bundles via `addBundle`
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Manifest Example
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'sunset.png',
   *                 },
   *                 {
   *                     alias: 'bar',
   *                     src: 'load-bar.{png,webp}',
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'character',
   *                     src: 'robot.png',
   *                 },
   *                 {
   *                     alias: 'enemy',
   *                     src: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * await Assets.init({ manifest });
   *
   * // Load a bundle...
   * loadScreenAssets = await Assets.loadBundle('load-screen');
   * // Load another bundle...
   * gameScreenAssets = await Assets.loadBundle('game-screen');
   * @param bundleIds - the bundle id or ids to load
   * @param onProgress - Optional function that is called when progress on asset loading is made.
   * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)
   * of the assets loaded. Do not use this function to detect when assets are complete and available,
   * instead use the Promise returned by this function.
   * @returns all the bundles assets or a hash of assets for each bundle specified
   */
  async loadBundle(t, e) {
    this._initialized || await this.init();
    let n = !1;
    typeof t == "string" && (n = !0, t = [t]);
    const r = this.resolver.resolveBundle(t), s = {}, o = Object.keys(r);
    let a = 0, l = 0;
    const h = () => {
      e == null || e(++a / l);
    }, c = o.map((p) => {
      const f = r[p];
      return l += Object.keys(f).length, this._mapLoadToResolve(f, h).then((d) => {
        s[p] = d;
      });
    });
    return await Promise.all(c), n ? s[t[0]] : s;
  }
  /**
   * Initiate a background load of some assets. It will passively begin to load these assets in the background.
   * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately
   *
   * An example of this might be that you would background load game assets after your initial load.
   * then when you got to actually load your game screen assets when a player goes to the game - the loading
   * would already have stared or may even be complete, saving you having to show an interim load bar.
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.backgroundLoad('bunny.png');
   *
   * // later on in your app...
   * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!
   * @param urls - the url / urls you want to background load
   */
  async backgroundLoad(t) {
    this._initialized || await this.init(), typeof t == "string" && (t = [t]);
    const e = this.resolver.resolve(t);
    this._backgroundLoader.add(Object.values(e));
  }
  /**
   * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.
   * this can only be used if the loader has been initiated with a manifest
   * @example
   * import { Assets } from 'pixi.js';
   *
   * await Assets.init({
   *     manifest: {
   *         bundles: [
   *             {
   *                 name: 'load-screen',
   *                 assets: [...],
   *             },
   *             ...
   *         ],
   *     },
   * });
   *
   * Assets.backgroundLoadBundle('load-screen');
   *
   * // Later on in your app...
   * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!
   * @param bundleIds - the bundleId / bundleIds you want to background load
   */
  async backgroundLoadBundle(t) {
    this._initialized || await this.init(), typeof t == "string" && (t = [t]);
    const e = this.resolver.resolveBundle(t);
    Object.values(e).forEach((n) => {
      this._backgroundLoader.add(Object.values(n));
    });
  }
  /**
   * Only intended for development purposes.
   * This will wipe the resolver and caches.
   * You will need to reinitialize the Asset
   */
  reset() {
    this.resolver.reset(), this.loader.reset(), this.cache.reset(), this._initialized = !1;
  }
  get(t) {
    if (typeof t == "string")
      return It.get(t);
    const e = {};
    for (let n = 0; n < t.length; n++)
      e[n] = It.get(t[n]);
    return e;
  }
  /**
   * helper function to map resolved assets back to loaded assets
   * @param resolveResults - the resolve results from the resolver
   * @param onProgress - the progress callback
   */
  async _mapLoadToResolve(t, e) {
    const n = [...new Set(Object.values(t))];
    this._backgroundLoader.active = !1;
    const r = await this.loader.load(n, e);
    this._backgroundLoader.active = !0;
    const s = {};
    return n.forEach((o) => {
      const a = r[o.src], l = [o.src];
      o.alias && l.push(...o.alias), l.forEach((h) => {
        s[h] = a;
      }), It.set(l, a);
    }), s;
  }
  /**
   * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function
   * this will make sure to destroy any assets and release them from memory.
   * Once unloaded, you will need to load the asset again.
   *
   * Use this to help manage assets if you find that you have a large app and you want to free up memory.
   *
   * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,
   * Pixi won't break but you will end up with missing assets. Not a good look for the user!
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Load a URL:
   * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture
   *
   * await Assets.unload('http://some.url.com/image.png')
   *
   * // myImageTexture will be destroyed now.
   *
   * // Unload multiple assets:
   * const textures = await Assets.unload(['thumper', 'chicko']);
   * @param urls - the urls to unload
   */
  async unload(t) {
    this._initialized || await this.init();
    const e = si(t).map((r) => typeof r != "string" ? r.src : r), n = this.resolver.resolve(e);
    await this._unloadFromResolved(n);
  }
  /**
   * Bundles are a way to manage multiple assets at once.
   * this will unload all files in a bundle.
   *
   * once a bundle has been unloaded, you need to load it again to have access to the assets.
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.addBundle({
   *     'thumper': 'http://some.url.com/thumper.png',
   * })
   *
   * const assets = await Assets.loadBundle('thumper');
   *
   * // Now to unload...
   *
   * await Assets.unloadBundle('thumper');
   *
   * // All assets in the assets object will now have been destroyed and purged from the cache
   * @param bundleIds - the bundle id or ids to unload
   */
  async unloadBundle(t) {
    this._initialized || await this.init(), t = si(t);
    const e = this.resolver.resolveBundle(t), n = Object.keys(e).map((r) => this._unloadFromResolved(e[r]));
    await Promise.all(n);
  }
  async _unloadFromResolved(t) {
    const e = Object.values(t);
    e.forEach((n) => {
      It.remove(n.src);
    }), await this.loader.unload(e);
  }
  /**
   * Detects the supported formats for the browser, and returns an array of supported formats, respecting
   * the users preferred formats order.
   * @param options - the options to use when detecting formats
   * @param options.preferredFormats - the preferred formats to use
   * @param options.skipDetections - if we should skip the detections altogether
   * @param options.detections - the detections to use
   * @returns - the detected formats
   */
  async _detectFormats(t) {
    let e = [];
    t.preferredFormats && (e = Array.isArray(t.preferredFormats) ? t.preferredFormats : [t.preferredFormats]);
    for (const n of t.detections)
      t.skipDetections || await n.test() ? e = await n.add(e) : t.skipDetections || (e = await n.remove(e));
    return e = e.filter((n, r) => e.indexOf(n) === r), e;
  }
  /** All the detection parsers currently added to the Assets class. */
  get detections() {
    return this._detections;
  }
  /**
   * General setter for preferences. This is a helper function to set preferences on all parsers.
   * @param preferences - the preferences to set
   */
  setPreferences(t) {
    this.loader.parsers.forEach((e) => {
      e.config && Object.keys(e.config).filter((n) => n in t).forEach((n) => {
        e.config[n] = t[n];
      });
    });
  }
}
const mi = new _1();
ge.handleByList(X.LoadParser, mi.loader.parsers).handleByList(X.ResolveParser, mi.resolver.parsers).handleByList(X.CacheParser, mi.cache.parsers).handleByList(X.DetectionParser, mi.detections);
ge.add(
  Ob,
  Bb,
  Db,
  Ub,
  Fb,
  Lb,
  Nb,
  Hb,
  Yb,
  e1,
  r1,
  Lm,
  y1,
  kb,
  Rb,
  Um,
  v1
);
const ap = {
  loader: X.LoadParser,
  resolver: X.ResolveParser,
  cache: X.CacheParser,
  detection: X.DetectionParser
};
ge.handle(X.Asset, (i) => {
  const t = i.ref;
  Object.entries(ap).filter(([e]) => !!t[e]).forEach(([e, n]) => ge.add(Object.assign(
    t[e],
    // Allow the function to optionally define it's own
    // ExtensionMetadata, the use cases here is priority for LoaderParsers
    { extension: t[e].extension ?? n }
  )));
}, (i) => {
  const t = i.ref;
  Object.keys(ap).filter((e) => !!t[e]).forEach((e) => ge.remove(t[e]));
});
class An extends Ea {
  /**
   * @param options - Options for the Graphics.
   */
  constructor(t) {
    t instanceof Qe && (t = { context: t });
    const { context: e, roundPixels: n, ...r } = t || {};
    super({
      label: "Graphics",
      ...r
    }), this.renderPipeId = "graphics", e ? this._context = e : this._context = this._ownedContext = new Qe(), this._context.on("update", this.onViewUpdate, this), this.allowChildren = !1, this.roundPixels = n ?? !1;
  }
  set context(t) {
    t !== this._context && (this._context.off("update", this.onViewUpdate, this), this._context = t, this._context.on("update", this.onViewUpdate, this), this.onViewUpdate());
  }
  get context() {
    return this._context;
  }
  /**
   * The local bounds of the graphic.
   * @type {rendering.Bounds}
   */
  get bounds() {
    return this._context.bounds;
  }
  /**
   * Adds the bounds of this object to the bounds object.
   * @param bounds - The output bounds object.
   */
  addBounds(t) {
    t.addBounds(this._context.bounds);
  }
  /**
   * Checks if the object contains the given point.
   * @param point - The point to check
   */
  containsPoint(t) {
    return this._context.containsPoint(t);
  }
  /**
   * Destroys this graphics renderable and optionally its context.
   * @param options - Options parameter. A boolean will act as if all options
   *
   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called
   * then the context will still be destroyed.
   *
   * If you want to explicitly not destroy this context that this graphics created,
   * then you should pass destroy({ context: false })
   *
   * If the context was passed in as an argument to the constructor then it will not be destroyed
   * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context
   * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context
   * @param {boolean} [options.context=false] - Should destroy the context
   */
  destroy(t) {
    this._ownedContext && !t ? this._ownedContext.destroy(t) : (t === !0 || (t == null ? void 0 : t.context) === !0) && this._context.destroy(t), this._ownedContext = null, this._context = null, super.destroy(t);
  }
  _callContextMethod(t, e) {
    return this.context[t](...e), this;
  }
  // --------------------------------------- GraphicsContext methods ---------------------------------------
  /**
   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
   * pattern, or a more complex style defined by a FillStyle object.
   * @param {FillInput} args - The fill style to apply. This can be a simple color, a gradient or
   * pattern object, or a FillStyle or ConvertedFillStyle object.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  setFillStyle(...t) {
    return this._callContextMethod("setFillStyle", t);
  }
  /**
   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
   * @param {StrokeInput} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,
   * or a StrokeStyle or ConvertedStrokeStyle object.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  setStrokeStyle(...t) {
    return this._callContextMethod("setStrokeStyle", t);
  }
  fill(...t) {
    return this._callContextMethod("fill", t);
  }
  /**
   * Strokes the current path with the current stroke style. This method can take an optional
   * FillStyle parameter to define the stroke's appearance, including its color, width, and other properties.
   * @param {FillStyle} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more
   * complex style object. If omitted, uses the current stroke style.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  stroke(...t) {
    return this._callContextMethod("stroke", t);
  }
  texture(...t) {
    return this._callContextMethod("texture", t);
  }
  /**
   * Resets the current path. Any previous path and its commands are discarded and a new path is
   * started. This is typically called before beginning a new shape or series of drawing commands.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  beginPath() {
    return this._callContextMethod("beginPath", []);
  }
  /**
   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
   * fail to cut correctly!
   */
  cut() {
    return this._callContextMethod("cut", []);
  }
  arc(...t) {
    return this._callContextMethod("arc", t);
  }
  arcTo(...t) {
    return this._callContextMethod("arcTo", t);
  }
  arcToSvg(...t) {
    return this._callContextMethod("arcToSvg", t);
  }
  bezierCurveTo(...t) {
    return this._callContextMethod("bezierCurveTo", t);
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    return this._callContextMethod("closePath", []);
  }
  ellipse(...t) {
    return this._callContextMethod("ellipse", t);
  }
  circle(...t) {
    return this._callContextMethod("circle", t);
  }
  path(...t) {
    return this._callContextMethod("path", t);
  }
  lineTo(...t) {
    return this._callContextMethod("lineTo", t);
  }
  moveTo(...t) {
    return this._callContextMethod("moveTo", t);
  }
  quadraticCurveTo(...t) {
    return this._callContextMethod("quadraticCurveTo", t);
  }
  rect(...t) {
    return this._callContextMethod("rect", t);
  }
  roundRect(...t) {
    return this._callContextMethod("roundRect", t);
  }
  poly(...t) {
    return this._callContextMethod("poly", t);
  }
  regularPoly(...t) {
    return this._callContextMethod("regularPoly", t);
  }
  roundPoly(...t) {
    return this._callContextMethod("roundPoly", t);
  }
  roundShape(...t) {
    return this._callContextMethod("roundShape", t);
  }
  filletRect(...t) {
    return this._callContextMethod("filletRect", t);
  }
  chamferRect(...t) {
    return this._callContextMethod("chamferRect", t);
  }
  star(...t) {
    return this._callContextMethod("star", t);
  }
  svg(...t) {
    return this._callContextMethod("svg", t);
  }
  restore(...t) {
    return this._callContextMethod("restore", t);
  }
  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
  save() {
    return this._callContextMethod("save", []);
  }
  /**
   * Returns the current transformation matrix of the graphics context.
   * @returns The current transformation matrix.
   */
  getTransform() {
    return this.context.getTransform();
  }
  /**
   * Resets the current transformation matrix to the identity matrix, effectively removing
   * any transformations (rotation, scaling, translation) previously applied.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  resetTransform() {
    return this._callContextMethod("resetTransform", []);
  }
  rotateTransform(...t) {
    return this._callContextMethod("rotate", t);
  }
  scaleTransform(...t) {
    return this._callContextMethod("scale", t);
  }
  setTransform(...t) {
    return this._callContextMethod("setTransform", t);
  }
  transform(...t) {
    return this._callContextMethod("transform", t);
  }
  translateTransform(...t) {
    return this._callContextMethod("translate", t);
  }
  /**
   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
   * and optionally resetting transformations to the identity matrix.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  clear() {
    return this._callContextMethod("clear", []);
  }
  /**
   * The fill style to use.
   * @type {ConvertedFillStyle}
   */
  get fillStyle() {
    return this._context.fillStyle;
  }
  set fillStyle(t) {
    this._context.fillStyle = t;
  }
  /**
   * The stroke style to use.
   * @type {ConvertedStrokeStyle}
   */
  get strokeStyle() {
    return this._context.strokeStyle;
  }
  set strokeStyle(t) {
    this._context.strokeStyle = t;
  }
  /**
   * Creates a new Graphics object.
   * Note that only the context of the object is cloned, not its transform (position,scale,etc)
   * @param deep - Whether to create a deep clone of the graphics object. If false, the context
   * will be shared between the two objects (default false). If true, the context will be
   * cloned (recommended if you need to modify the context in any way).
   * @returns - A clone of the graphics object
   */
  clone(t = !1) {
    return t ? new An(this._context.clone()) : (this._ownedContext = null, new An(this._context));
  }
  // -------- v7 deprecations ---------
  /**
   * @param width
   * @param color
   * @param alpha
   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead
   */
  lineStyle(t, e, n) {
    ut(dt, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
    const r = {};
    return t && (r.width = t), e && (r.color = e), n && (r.alpha = n), this.context.strokeStyle = r, this;
  }
  /**
   * @param color
   * @param alpha
   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
   */
  beginFill(t, e) {
    ut(dt, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
    const n = {};
    return t && (n.color = t), e && (n.alpha = e), this.context.fillStyle = n, this;
  }
  /**
   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
   */
  endFill() {
    ut(dt, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."), this.context.fill();
    const t = this.context.strokeStyle;
    return (t.width !== Qe.defaultStrokeStyle.width || t.color !== Qe.defaultStrokeStyle.color || t.alpha !== Qe.defaultStrokeStyle.alpha) && this.context.stroke(), this;
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead
   */
  drawCircle(...t) {
    return ut(dt, "Graphics#drawCircle has been renamed to Graphics#circle"), this._callContextMethod("circle", t);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead
   */
  drawEllipse(...t) {
    return ut(dt, "Graphics#drawEllipse has been renamed to Graphics#ellipse"), this._callContextMethod("ellipse", t);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead
   */
  drawPolygon(...t) {
    return ut(dt, "Graphics#drawPolygon has been renamed to Graphics#poly"), this._callContextMethod("poly", t);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead
   */
  drawRect(...t) {
    return ut(dt, "Graphics#drawRect has been renamed to Graphics#rect"), this._callContextMethod("rect", t);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead
   */
  drawRoundedRect(...t) {
    return ut(dt, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"), this._callContextMethod("roundRect", t);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#star} instead
   */
  drawStar(...t) {
    return ut(dt, "Graphics#drawStar has been renamed to Graphics#star"), this._callContextMethod("star", t);
  }
}
class x1 {
  /**
   * @param options - Options for the transform.
   * @param options.matrix - The matrix to use.
   * @param options.observer - The observer to use.
   */
  constructor({ matrix: t, observer: e } = {}) {
    this.dirty = !0, this._matrix = t ?? new ct(), this.observer = e, this.position = new Wt(this, 0, 0), this.scale = new Wt(this, 1, 1), this.pivot = new Wt(this, 0, 0), this.skew = new Wt(this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1;
  }
  /**
   * This matrix is computed by combining this Transforms position, scale, rotation, skew, and pivot
   * properties into a single matrix.
   * @readonly
   */
  get matrix() {
    const t = this._matrix;
    return this.dirty && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this.dirty = !1), t;
  }
  /**
   * Called when a value changes.
   * @param point
   * @internal
   * @private
   */
  _onUpdate(t) {
    var e;
    this.dirty = !0, t === this.skew && this.updateSkew(), (e = this.observer) == null || e._onUpdate(this);
  }
  /** Called when the skew or the rotation changes. */
  updateSkew() {
    this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this.dirty = !0;
  }
  toString() {
    return `[pixi.js/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
  }
  /**
   * Decomposes a matrix and sets the transforms properties based on it.
   * @param matrix - The matrix to decompose
   */
  setFromMatrix(t) {
    t.decompose(this), this.dirty = !0;
  }
  /** The rotation of the object in radians. */
  get rotation() {
    return this._rotation;
  }
  set rotation(t) {
    this._rotation !== t && (this._rotation = t, this._onUpdate(this.skew));
  }
}
const zm = class No extends Ea {
  constructor(...t) {
    let e = t[0] || {};
    e instanceof nt && (e = { texture: e }), t.length > 1 && (ut(dt, "use new TilingSprite({ texture, width:100, height:100 }) instead"), e.width = t[1], e.height = t[2]), e = { ...No.defaultOptions, ...e };
    const {
      texture: n,
      anchor: r,
      tilePosition: s,
      tileScale: o,
      tileRotation: a,
      width: l,
      height: h,
      applyAnchorToTexture: c,
      roundPixels: p,
      ...f
    } = e ?? {};
    super({
      label: "TilingSprite",
      ...f
    }), this.renderPipeId = "tilingSprite", this.batched = !0, this.allowChildren = !1, this._anchor = new Wt(
      {
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }
    ), this._applyAnchorToTexture = c, this.texture = n, this._width = l ?? n.width, this._height = h ?? n.height, this._tileTransform = new x1({
      observer: {
        _onUpdate: () => this.onViewUpdate()
      }
    }), r && (this.anchor = r), this.tilePosition = s, this.tileScale = o, this.tileRotation = a, this.roundPixels = p ?? !1;
  }
  /**
   * Creates a new tiling sprite.
   * @param source - The source to create the texture from.
   * @param options - The options for creating the tiling sprite.
   * @returns A new tiling sprite.
   */
  static from(t, e = {}) {
    return typeof t == "string" ? new No({
      texture: It.get(t),
      ...e
    }) : new No({
      texture: t,
      ...e
    });
  }
  /**
   * Changes frame clamping in corresponding textureMatrix
   * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
   * @default 0.5
   * @member {number}
   */
  get clampMargin() {
    return this._texture.textureMatrix.clampMargin;
  }
  set clampMargin(t) {
    this._texture.textureMatrix.clampMargin = t;
  }
  /**
   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
   * and passed to the constructor.
   *
   * The default is `(0,0)`, this means the sprite's origin is the top left.
   *
   * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
   *
   * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
   *
   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
   * @example
   * import { TilingSprite } from 'pixi.js';
   *
   * const sprite = new TilingSprite({texture: Texture.WHITE});
   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(t) {
    typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t);
  }
  /** The offset of the image that is being tiled. */
  get tilePosition() {
    return this._tileTransform.position;
  }
  set tilePosition(t) {
    this._tileTransform.position.copyFrom(t);
  }
  /** The scaling of the image that is being tiled. */
  get tileScale() {
    return this._tileTransform.scale;
  }
  set tileScale(t) {
    typeof t == "number" ? this._tileTransform.scale.set(t) : this._tileTransform.scale.copyFrom(t);
  }
  set tileRotation(t) {
    this._tileTransform.rotation = t;
  }
  /** The rotation of the image that is being tiled. */
  get tileRotation() {
    return this._tileTransform.rotation;
  }
  /** The transform of the image that is being tiled. */
  get tileTransform() {
    return this._tileTransform;
  }
  /**
   * The local bounds of the sprite.
   * @type {rendering.Bounds}
   */
  get bounds() {
    return this._boundsDirty && (this._updateBounds(), this._boundsDirty = !1), this._bounds;
  }
  set texture(t) {
    t || (t = nt.EMPTY);
    const e = this._texture;
    e !== t && (e && e.dynamic && e.off("update", this.onViewUpdate, this), t.dynamic && t.on("update", this.onViewUpdate, this), this._texture = t, this.onViewUpdate());
  }
  /** The texture that the sprite is using. */
  get texture() {
    return this._texture;
  }
  /** The width of the tiling area. */
  set width(t) {
    this._width = t, this.onViewUpdate();
  }
  get width() {
    return this._width;
  }
  set height(t) {
    this._height = t, this.onViewUpdate();
  }
  /** The height of the tiling area. */
  get height() {
    return this._height;
  }
  /**
   * Sets the size of the TilingSprite to the specified width and height.
   * This is faster than setting the width and height separately.
   * @param value - This can be either a number or a [Size]{@link Size} object.
   * @param height - The height to set. Defaults to the value of `width` if not provided.
   */
  setSize(t, e) {
    typeof t == "object" && (e = t.height ?? t.width, t = t.width), this._width = t, this._height = e ?? t, this.onViewUpdate();
  }
  /**
   * Retrieves the size of the TilingSprite as a [Size]{@link Size} object.
   * This is faster than get the width and height separately.
   * @param out - Optional object to store the size in.
   * @returns - The size of the TilingSprite.
   */
  getSize(t) {
    return t || (t = {}), t.width = this._width, t.height = this._height, t;
  }
  _updateBounds() {
    const t = this._bounds, e = this._anchor, n = this._width, r = this._height;
    t.maxX = -e._x * n, t.minX = t.maxX + n, t.maxY = -e._y * r, t.minY = t.maxY + r;
  }
  /**
   * Adds the bounds of this object to the bounds object.
   * @param bounds - The output bounds object.
   */
  addBounds(t) {
    const e = this.bounds;
    t.addFrame(
      e.minX,
      e.minY,
      e.maxX,
      e.maxY
    );
  }
  /**
   * Checks if the object contains the given point.
   * @param point - The point to check
   */
  containsPoint(t) {
    const e = this._width, n = this._height, r = -e * this._anchor._x;
    let s = 0;
    return t.x >= r && t.x <= r + e && (s = -n * this._anchor._y, t.y >= s && t.y <= s + n);
  }
  onViewUpdate() {
    this._boundsDirty = !0, super.onViewUpdate();
  }
  /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
   */
  destroy(t = !1) {
    if (super.destroy(t), this._anchor = null, this._tileTransform = null, this._bounds = null, typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
      const e = typeof t == "boolean" ? t : t == null ? void 0 : t.textureSource;
      this._texture.destroy(e);
    }
    this._texture = null;
  }
};
zm.defaultOptions = {
  /** The texture to use for the sprite. */
  texture: nt.EMPTY,
  /** The anchor point of the sprite */
  anchor: { x: 0, y: 0 },
  /** The offset of the image that is being tiled. */
  tilePosition: { x: 0, y: 0 },
  /** Scaling of the image that is being tiled. */
  tileScale: { x: 1, y: 1 },
  /** The rotation of the image that is being tiled. */
  tileRotation: 0,
  /** TODO */
  applyAnchorToTexture: !1
};
let b1 = zm;
class jm extends Ea {
  constructor(t, e) {
    const { text: n, resolution: r, style: s, anchor: o, width: a, height: l, roundPixels: h, ...c } = t;
    super({
      ...c
    }), this.batched = !0, this._resolution = null, this._autoResolution = !0, this._didTextUpdate = !0, this._styleClass = e, this.text = n ?? "", this.style = s, this.resolution = r ?? null, this.allowChildren = !1, this._anchor = new Wt(
      {
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }
    ), o && (this.anchor = o), this.roundPixels = h ?? !1, a !== void 0 && (this.width = a), l !== void 0 && (this.height = l);
  }
  /**
   * The anchor sets the origin point of the text.
   * The default is `(0,0)`, this means the text's origin is the top left.
   *
   * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
   *
   * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
   *
   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
   * @example
   * import { Text } from 'pixi.js';
   *
   * const text = new Text('hello world');
   * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(t) {
    typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t);
  }
  /** Set the copy for the text object. To split a line you can use '\n'. */
  set text(t) {
    t = t.toString(), this._text !== t && (this._text = t, this.onViewUpdate());
  }
  get text() {
    return this._text;
  }
  /**
   * The resolution / device pixel ratio of the canvas.
   * @default 1
   */
  set resolution(t) {
    this._autoResolution = t === null, this._resolution = t, this.onViewUpdate();
  }
  get resolution() {
    return this._resolution;
  }
  get style() {
    return this._style;
  }
  /**
   * Set the style of the text.
   *
   * Set up an event listener to listen for changes on the style object and mark the text as dirty.
   *
   * If setting the `style` can also be partial {@link AnyTextStyleOptions}.
   * @type {
   * text.TextStyle |
   * Partial<text.TextStyle> |
   * text.TextStyleOptions |
   * text.HTMLTextStyle |
   * Partial<text.HTMLTextStyle> |
   * text.HTMLTextStyleOptions
   * }
   */
  set style(t) {
    var e;
    t = t || {}, (e = this._style) == null || e.off("update", this.onViewUpdate, this), t instanceof this._styleClass ? this._style = t : this._style = new this._styleClass(t), this._style.on("update", this.onViewUpdate, this), this.onViewUpdate();
  }
  /**
   * The local bounds of the Text.
   * @type {rendering.Bounds}
   */
  get bounds() {
    return this._boundsDirty && (this._updateBounds(), this._boundsDirty = !1), this._bounds;
  }
  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
  get width() {
    return Math.abs(this.scale.x) * this.bounds.width;
  }
  set width(t) {
    this._setWidth(t, this.bounds.width);
  }
  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
  get height() {
    return Math.abs(this.scale.y) * this.bounds.height;
  }
  set height(t) {
    this._setHeight(t, this.bounds.height);
  }
  /**
   * Retrieves the size of the Text as a [Size]{@link Size} object.
   * This is faster than get the width and height separately.
   * @param out - Optional object to store the size in.
   * @returns - The size of the Text.
   */
  getSize(t) {
    return t || (t = {}), t.width = Math.abs(this.scale.x) * this.bounds.width, t.height = Math.abs(this.scale.y) * this.bounds.height, t;
  }
  /**
   * Sets the size of the Text to the specified width and height.
   * This is faster than setting the width and height separately.
   * @param value - This can be either a number or a [Size]{@link Size} object.
   * @param height - The height to set. Defaults to the value of `width` if not provided.
   */
  setSize(t, e) {
    typeof t == "object" ? (e = t.height ?? t.width, t = t.width) : e ?? (e = t), t !== void 0 && this._setWidth(t, this.bounds.width), e !== void 0 && this._setHeight(e, this.bounds.height);
  }
  /**
   * Adds the bounds of this text to the bounds object.
   * @param bounds - The output bounds object.
   */
  addBounds(t) {
    const e = this.bounds;
    t.addFrame(
      e.minX,
      e.minY,
      e.maxX,
      e.maxY
    );
  }
  /**
   * Checks if the text contains the given point.
   * @param point - The point to check
   */
  containsPoint(t) {
    const e = this.bounds.width, n = this.bounds.height, r = -e * this.anchor.x;
    let s = 0;
    return t.x >= r && t.x <= r + e && (s = -n * this.anchor.y, t.y >= s && t.y <= s + n);
  }
  onViewUpdate() {
    this._boundsDirty = !0, this.didViewUpdate || (this._didTextUpdate = !0), super.onViewUpdate();
  }
  _getKey() {
    return `${this.text}:${this._style.styleKey}:${this._resolution}`;
  }
  /**
   * Destroys this text renderable and optionally its style texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style
   * @param {boolean} [options.style=false] - Should it destroy the style of the text
   */
  destroy(t = !1) {
    super.destroy(t), this.owner = null, this._bounds = null, this._anchor = null, (typeof t == "boolean" ? t : t != null && t.style) && this._style.destroy(t), this._style = null, this._text = null;
  }
}
function Gm(i, t) {
  let e = i[0] ?? {};
  return (typeof e == "string" || i[1]) && (ut(dt, `use new ${t}({ text: "hi!", style }) instead`), e = {
    text: e,
    style: i[1]
  }), e;
}
class w1 extends jm {
  constructor(...t) {
    const e = Gm(t, "Text");
    super(e, Dn), this.renderPipeId = "text";
  }
  _updateBounds() {
    const t = this._bounds, e = this._anchor, n = Eh.measureText(
      this._text,
      this._style
    ), { width: r, height: s } = n;
    t.minX = -e._x * r, t.maxX = t.minX + r, t.minY = -e._y * s, t.maxY = t.minY + s;
  }
}
class A1 extends jm {
  constructor(...t) {
    var e;
    const n = Gm(t, "BitmapText");
    n.style ?? (n.style = n.style || {}), (e = n.style).fill ?? (e.fill = 16777215), super(n, Dn), this.renderPipeId = "bitmapText";
  }
  _updateBounds() {
    const t = this._bounds, e = this._anchor, n = Ch.measureText(this.text, this._style), r = n.scale, s = n.offsetY * r;
    let o = n.width * r, a = n.height * r;
    const l = this._style._stroke;
    l && (o += l.width, a += l.width), t.minX = -e._x * o, t.maxX = t.minX + o, t.minY = -e._y * (a + s), t.maxY = t.minY + a;
  }
  /**
   * The resolution / device pixel ratio of the canvas.
   * @default 1
   */
  set resolution(t) {
    t !== null && Lt(
      // eslint-disable-next-line max-len
      "[BitmapText] dynamically updating the resolution is not supported. Resolution should be managed by the BitmapFont."
    );
  }
  get resolution() {
    return this._resolution;
  }
}
class Ac extends nt {
  static create(t) {
    return new Ac({
      source: new bi(t)
    });
  }
  /**
   * Resizes the render texture.
   * @param width - The new width of the render texture.
   * @param height - The new height of the render texture.
   * @param resolution - The new resolution of the render texture.
   * @returns This texture.
   */
  resize(t, e, n) {
    return this.source.resize(t, e, n), this;
  }
}
ge.add(Y0, X0);
var Hm = {}, Ba = {};
Object.defineProperty(Ba, "__esModule", { value: !0 });
Ba.MiniSignal = void 0;
const Ih = Symbol("SIGNAL");
function S1(i) {
  return typeof i == "object" && Ih in i;
}
class T1 {
  constructor() {
    this._symbol = Symbol("MiniSignal"), this._refMap = /* @__PURE__ */ new WeakMap(), this._head = void 0, this._tail = void 0, this._dispatching = !1;
  }
  hasListeners() {
    return this._head != null;
  }
  /**
   * Dispatches a signal to all registered listeners.
   */
  dispatch(...t) {
    if (this._dispatching)
      throw new Error("MiniSignal#dispatch(): Signal already dispatching.");
    let e = this._head;
    if (e == null)
      return !1;
    for (this._dispatching = !0; e != null; )
      e.fn(...t), e = e.next;
    return this._dispatching = !1, !0;
  }
  /**
   * Register a new listener.
   */
  add(t) {
    if (typeof t != "function")
      throw new Error("MiniSignal#add(): First arg must be a Function.");
    return this._createRef(this._addNode({ fn: t }));
  }
  /**
   * Remove binding object.
   */
  detach(t) {
    if (!S1(t))
      throw new Error("MiniSignal#detach(): First arg must be a MiniSignal listener reference.");
    if (t[Ih] !== this._symbol)
      throw new Error("MiniSignal#detach(): MiniSignal listener does not belong to this MiniSignal.");
    const e = this._refMap.get(t);
    return e ? (this._refMap.delete(t), this._disconnectNode(e), this._destroyNode(e), this) : this;
  }
  /**
   * Detach all listeners.
   */
  detachAll() {
    let t = this._head;
    if (t == null)
      return this;
    for (this._head = this._tail = void 0, this._refMap = /* @__PURE__ */ new WeakMap(); t != null; )
      this._destroyNode(t), t = t.next;
    return this;
  }
  _destroyNode(t) {
    t.fn = void 0, t.prev = void 0;
  }
  _disconnectNode(t) {
    t === this._head ? (this._head = t.next, t.next == null && (this._tail = void 0)) : t === this._tail && (this._tail = t.prev, this._tail != null && (this._tail.next = void 0)), t.prev != null && (t.prev.next = t.next), t.next != null && (t.next.prev = t.prev);
  }
  _addNode(t) {
    return this._head == null ? (this._head = t, this._tail = t) : (this._tail.next = t, t.prev = this._tail, this._tail = t), t;
  }
  _createRef(t) {
    const e = { [Ih]: this._symbol };
    return this._refMap.set(e, t), e;
  }
  _getRef(t) {
    return this._refMap.get(t);
  }
}
Ba.MiniSignal = T1;
(function(i) {
  var t = xn && xn.__createBinding || (Object.create ? function(n, r, s, o) {
    o === void 0 && (o = s);
    var a = Object.getOwnPropertyDescriptor(r, s);
    (!a || ("get" in a ? !r.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
      return r[s];
    } }), Object.defineProperty(n, o, a);
  } : function(n, r, s, o) {
    o === void 0 && (o = s), n[o] = r[s];
  }), e = xn && xn.__exportStar || function(n, r) {
    for (var s in n) s !== "default" && !Object.prototype.hasOwnProperty.call(r, s) && t(r, n, s);
  };
  Object.defineProperty(i, "__esModule", { value: !0 }), e(Ba, i);
})(Hm);
const Jo = /* @__PURE__ */ new Map(), hs = (i, t) => {
  let e = Jo.get(i);
  return e || (e = new Hm.MiniSignal(), Jo.set(i, e)), { name: i, binding: e.add(t) };
}, Zo = (i, t) => {
  const e = Jo.get(i);
  e && e.detach(t);
}, Ie = (i, ...t) => {
  const e = Jo.get(i);
  e && e.dispatch(...t);
};
function Ci(i) {
  if (i === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return i;
}
function Wm(i, t) {
  i.prototype = Object.create(t.prototype), i.prototype.constructor = i, i.__proto__ = t;
}
/*!
 * GSAP 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var qe = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
}, xr = {
  duration: 0.5,
  overwrite: !1,
  delay: 0
}, Sc, ye, At, Ze = 1e8, vt = 1 / Ze, Rh = Math.PI * 2, E1 = Rh / 4, C1 = 0, qm = Math.sqrt, P1 = Math.cos, I1 = Math.sin, ee = function(i) {
  return typeof i == "string";
}, Dt = function(i) {
  return typeof i == "function";
}, Bi = function(i) {
  return typeof i == "number";
}, Tc = function(i) {
  return typeof i > "u";
}, vi = function(i) {
  return typeof i == "object";
}, Re = function(i) {
  return i !== !1;
}, Ec = function() {
  return typeof window < "u";
}, Io = function(i) {
  return Dt(i) || ee(i);
}, Ym = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {
}, ve = Array.isArray, kh = /(?:-?\.?\d|\.)+/gi, Xm = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, sr = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, jl = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, Km = /[+-]=-?[.\d]+/, Qm = /[^,'"\[\]\s]+/gi, R1 = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, Pt, pi, Mh, Cc, Ye = {}, $o = {}, Jm, Zm = function(i) {
  return ($o = Bn(i, Ye)) && De;
}, Pc = function(i, t) {
  return console.warn("Invalid property", i, "set to", t, "Missing plugin? gsap.registerPlugin()");
}, Os = function(i, t) {
  return !t && console.warn(i);
}, $m = function(i, t) {
  return i && (Ye[i] = t) && $o && ($o[i] = t) || Ye;
}, Ds = function() {
  return 0;
}, k1 = {
  suppressEvents: !0,
  isStart: !0,
  kill: !1
}, Uo = {
  suppressEvents: !0,
  kill: !1
}, M1 = {
  suppressEvents: !0
}, Ic = {}, Yi = [], Oh = {}, tg, Ge = {}, Gl = {}, lp = 30, zo = [], Rc = "", kc = function(i) {
  var t = i[0], e, n;
  if (vi(t) || Dt(t) || (i = [i]), !(e = (t._gsap || {}).harness)) {
    for (n = zo.length; n-- && !zo[n].targetTest(t); )
      ;
    e = zo[n];
  }
  for (n = i.length; n--; )
    i[n] && (i[n]._gsap || (i[n]._gsap = new Sg(i[n], e))) || i.splice(n, 1);
  return i;
}, Cn = function(i) {
  return i._gsap || kc($e(i))[0]._gsap;
}, eg = function(i, t, e) {
  return (e = i[t]) && Dt(e) ? i[t]() : Tc(e) && i.getAttribute && i.getAttribute(t) || e;
}, ke = function(i, t) {
  return (i = i.split(",")).forEach(t) || i;
}, Ft = function(i) {
  return Math.round(i * 1e5) / 1e5 || 0;
}, Zt = function(i) {
  return Math.round(i * 1e7) / 1e7 || 0;
}, ur = function(i, t) {
  var e = t.charAt(0), n = parseFloat(t.substr(2));
  return i = parseFloat(i), e === "+" ? i + n : e === "-" ? i - n : e === "*" ? i * n : i / n;
}, O1 = function(i, t) {
  for (var e = t.length, n = 0; i.indexOf(t[n]) < 0 && ++n < e; )
    ;
  return n < e;
}, ta = function() {
  var i = Yi.length, t = Yi.slice(0), e, n;
  for (Oh = {}, Yi.length = 0, e = 0; e < i; e++)
    n = t[e], n && n._lazy && (n.render(n._lazy[0], n._lazy[1], !0)._lazy = 0);
}, ig = function(i, t, e, n) {
  Yi.length && !ye && ta(), i.render(t, e, ye && t < 0 && (i._initted || i._startAt)), Yi.length && !ye && ta();
}, ng = function(i) {
  var t = parseFloat(i);
  return (t || t === 0) && (i + "").match(Qm).length < 2 ? t : ee(i) ? i.trim() : i;
}, rg = function(i) {
  return i;
}, ti = function(i, t) {
  for (var e in t)
    e in i || (i[e] = t[e]);
  return i;
}, D1 = function(i) {
  return function(t, e) {
    for (var n in e)
      n in t || n === "duration" && i || n === "ease" || (t[n] = e[n]);
  };
}, Bn = function(i, t) {
  for (var e in t)
    i[e] = t[e];
  return i;
}, hp = function i(t, e) {
  for (var n in e)
    n !== "__proto__" && n !== "constructor" && n !== "prototype" && (t[n] = vi(e[n]) ? i(t[n] || (t[n] = {}), e[n]) : e[n]);
  return t;
}, ea = function(i, t) {
  var e = {}, n;
  for (n in i)
    n in t || (e[n] = i[n]);
  return e;
}, vs = function(i) {
  var t = i.parent || Pt, e = i.keyframes ? D1(ve(i.keyframes)) : ti;
  if (Re(i.inherit))
    for (; t; )
      e(i, t.vars.defaults), t = t.parent || t._dp;
  return i;
}, B1 = function(i, t) {
  for (var e = i.length, n = e === t.length; n && e-- && i[e] === t[e]; )
    ;
  return e < 0;
}, sg = function(i, t, e, n, r) {
  var s = i[n], o;
  if (r)
    for (o = t[r]; s && s[r] > o; )
      s = s._prev;
  return s ? (t._next = s._next, s._next = t) : (t._next = i[e], i[e] = t), t._next ? t._next._prev = t : i[n] = t, t._prev = s, t.parent = t._dp = i, t;
}, Va = function(i, t, e, n) {
  e === void 0 && (e = "_first"), n === void 0 && (n = "_last");
  var r = t._prev, s = t._next;
  r ? r._next = s : i[e] === t && (i[e] = s), s ? s._prev = r : i[n] === t && (i[n] = r), t._next = t._prev = t.parent = null;
}, Zi = function(i, t) {
  i.parent && (!t || i.parent.autoRemoveChildren) && i.parent.remove && i.parent.remove(i), i._act = 0;
}, Pn = function(i, t) {
  if (i && (!t || t._end > i._dur || t._start < 0))
    for (var e = i; e; )
      e._dirty = 1, e = e.parent;
  return i;
}, V1 = function(i) {
  for (var t = i.parent; t && t.parent; )
    t._dirty = 1, t.totalDuration(), t = t.parent;
  return i;
}, Dh = function(i, t, e, n) {
  return i._startAt && (ye ? i._startAt.revert(Uo) : i.vars.immediateRender && !i.vars.autoRevert || i._startAt.render(t, !0, n));
}, F1 = function i(t) {
  return !t || t._ts && i(t.parent);
}, cp = function(i) {
  return i._repeat ? br(i._tTime, i = i.duration() + i._rDelay) * i : 0;
}, br = function(i, t) {
  var e = Math.floor(i /= t);
  return i && e === i ? e - 1 : e;
}, ia = function(i, t) {
  return (i - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur);
}, Fa = function(i) {
  return i._end = Zt(i._start + (i._tDur / Math.abs(i._ts || i._rts || vt) || 0));
}, La = function(i, t) {
  var e = i._dp;
  return e && e.smoothChildTiming && i._ts && (i._start = Zt(e._time - (i._ts > 0 ? t / i._ts : ((i._dirty ? i.totalDuration() : i._tDur) - t) / -i._ts)), Fa(i), e._dirty || Pn(e, i)), i;
}, og = function(i, t) {
  var e;
  if ((t._time || !t._dur && t._initted || t._start < i._time && (t._dur || !t.add)) && (e = ia(i.rawTime(), t), (!t._dur || Js(0, t.totalDuration(), e) - t._tTime > vt) && t.render(e, !0)), Pn(i, t)._dp && i._initted && i._time >= i._dur && i._ts) {
    if (i._dur < i.duration())
      for (e = i; e._dp; )
        e.rawTime() >= 0 && e.totalTime(e._tTime), e = e._dp;
    i._zTime = -vt;
  }
}, fi = function(i, t, e, n) {
  return t.parent && Zi(t), t._start = Zt((Bi(e) ? e : e || i !== Pt ? Ke(i, e, t) : i._time) + t._delay), t._end = Zt(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), sg(i, t, "_first", "_last", i._sort ? "_start" : 0), Bh(t) || (i._recent = t), n || og(i, t), i._ts < 0 && La(i, i._tTime), i;
}, ag = function(i, t) {
  return (Ye.ScrollTrigger || Pc("scrollTrigger", t)) && Ye.ScrollTrigger.create(t, i);
}, lg = function(i, t, e, n, r) {
  if (Oc(i, t, r), !i._initted)
    return 1;
  if (!e && i._pt && !ye && (i._dur && i.vars.lazy !== !1 || !i._dur && i.vars.lazy) && tg !== He.frame)
    return Yi.push(i), i._lazy = [r, n], 1;
}, L1 = function i(t) {
  var e = t.parent;
  return e && e._ts && e._initted && !e._lock && (e.rawTime() < 0 || i(e));
}, Bh = function(i) {
  var t = i.data;
  return t === "isFromStart" || t === "isStart";
}, N1 = function(i, t, e, n) {
  var r = i.ratio, s = t < 0 || !t && (!i._start && L1(i) && !(!i._initted && Bh(i)) || (i._ts < 0 || i._dp._ts < 0) && !Bh(i)) ? 0 : 1, o = i._rDelay, a = 0, l, h, c;
  if (o && i._repeat && (a = Js(0, i._tDur, t), h = br(a, o), i._yoyo && h & 1 && (s = 1 - s), h !== br(i._tTime, o) && (r = 1 - s, i.vars.repeatRefresh && i._initted && i.invalidate())), s !== r || ye || n || i._zTime === vt || !t && i._zTime) {
    if (!i._initted && lg(i, t, n, e, a))
      return;
    for (c = i._zTime, i._zTime = t || (e ? vt : 0), e || (e = t && !c), i.ratio = s, i._from && (s = 1 - s), i._time = 0, i._tTime = a, l = i._pt; l; )
      l.r(s, l.d), l = l._next;
    t < 0 && Dh(i, t, e, !0), i._onUpdate && !e && We(i, "onUpdate"), a && i._repeat && !e && i.parent && We(i, "onRepeat"), (t >= i._tDur || t < 0) && i.ratio === s && (s && Zi(i, 1), !e && !ye && (We(i, s ? "onComplete" : "onReverseComplete", !0), i._prom && i._prom()));
  } else i._zTime || (i._zTime = t);
}, U1 = function(i, t, e) {
  var n;
  if (e > t)
    for (n = i._first; n && n._start <= e; ) {
      if (n.data === "isPause" && n._start > t)
        return n;
      n = n._next;
    }
  else
    for (n = i._last; n && n._start >= e; ) {
      if (n.data === "isPause" && n._start < t)
        return n;
      n = n._prev;
    }
}, wr = function(i, t, e, n) {
  var r = i._repeat, s = Zt(t) || 0, o = i._tTime / i._tDur;
  return o && !n && (i._time *= s / i._dur), i._dur = s, i._tDur = r ? r < 0 ? 1e10 : Zt(s * (r + 1) + i._rDelay * r) : s, o > 0 && !n && La(i, i._tTime = i._tDur * o), i.parent && Fa(i), e || Pn(i.parent, i), i;
}, up = function(i) {
  return i instanceof Se ? Pn(i) : wr(i, i._dur);
}, z1 = {
  _start: 0,
  endTime: Ds,
  totalDuration: Ds
}, Ke = function i(t, e, n) {
  var r = t.labels, s = t._recent || z1, o = t.duration() >= Ze ? s.endTime(!1) : t._dur, a, l, h;
  return ee(e) && (isNaN(e) || e in r) ? (l = e.charAt(0), h = e.substr(-1) === "%", a = e.indexOf("="), l === "<" || l === ">" ? (a >= 0 && (e = e.replace(/=/, "")), (l === "<" ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(e.substr(1)) || 0) * (h ? (a < 0 ? s : n).totalDuration() / 100 : 1)) : a < 0 ? (e in r || (r[e] = o), r[e]) : (l = parseFloat(e.charAt(a - 1) + e.substr(a + 1)), h && n && (l = l / 100 * (ve(n) ? n[0] : n).totalDuration()), a > 1 ? i(t, e.substr(0, a - 1), n) + l : o + l)) : e == null ? o : +e;
}, _s = function(i, t, e) {
  var n = Bi(t[1]), r = (n ? 2 : 1) + (i < 2 ? 0 : 1), s = t[r], o, a;
  if (n && (s.duration = t[1]), s.parent = e, i) {
    for (o = s, a = e; a && !("immediateRender" in o); )
      o = a.vars.defaults || {}, a = Re(a.vars.inherit) && a.parent;
    s.immediateRender = Re(o.immediateRender), i < 2 ? s.runBackwards = 1 : s.startAt = t[r - 1];
  }
  return new Ut(t[0], s, t[r + 1]);
}, rn = function(i, t) {
  return i || i === 0 ? t(i) : t;
}, Js = function(i, t, e) {
  return e < i ? i : e > t ? t : e;
}, fe = function(i, t) {
  return !ee(i) || !(t = R1.exec(i)) ? "" : t[1];
}, j1 = function(i, t, e) {
  return rn(e, function(n) {
    return Js(i, t, n);
  });
}, Vh = [].slice, hg = function(i, t) {
  return i && vi(i) && "length" in i && (!t && !i.length || i.length - 1 in i && vi(i[0])) && !i.nodeType && i !== pi;
}, G1 = function(i, t, e) {
  return e === void 0 && (e = []), i.forEach(function(n) {
    var r;
    return ee(n) && !t || hg(n, 1) ? (r = e).push.apply(r, $e(n)) : e.push(n);
  }) || e;
}, $e = function(i, t, e) {
  return At && !t && At.selector ? At.selector(i) : ee(i) && !e && (Mh || !Ar()) ? Vh.call((t || Cc).querySelectorAll(i), 0) : ve(i) ? G1(i, e) : hg(i) ? Vh.call(i, 0) : i ? [i] : [];
}, Fh = function(i) {
  return i = $e(i)[0] || Os("Invalid scope") || {}, function(t) {
    var e = i.current || i.nativeElement || i;
    return $e(t, e.querySelectorAll ? e : e === i ? Os("Invalid scope") || Cc.createElement("div") : i);
  };
}, cg = function(i) {
  return i.sort(function() {
    return 0.5 - Math.random();
  });
}, ug = function(i) {
  if (Dt(i))
    return i;
  var t = vi(i) ? i : {
    each: i
  }, e = In(t.ease), n = t.from || 0, r = parseFloat(t.base) || 0, s = {}, o = n > 0 && n < 1, a = isNaN(n) || o, l = t.axis, h = n, c = n;
  return ee(n) ? h = c = {
    center: 0.5,
    edges: 0.5,
    end: 1
  }[n] || 0 : !o && a && (h = n[0], c = n[1]), function(p, f, d) {
    var m = (d || t).length, g = s[m], y, b, S, C, I, T, R, w, v;
    if (!g) {
      if (v = t.grid === "auto" ? 0 : (t.grid || [1, Ze])[1], !v) {
        for (R = -Ze; R < (R = d[v++].getBoundingClientRect().left) && v < m; )
          ;
        v < m && v--;
      }
      for (g = s[m] = [], y = a ? Math.min(v, m) * h - 0.5 : n % v, b = v === Ze ? 0 : a ? m * c / v - 0.5 : n / v | 0, R = 0, w = Ze, T = 0; T < m; T++)
        S = T % v - y, C = b - (T / v | 0), g[T] = I = l ? Math.abs(l === "y" ? C : S) : qm(S * S + C * C), I > R && (R = I), I < w && (w = I);
      n === "random" && cg(g), g.max = R - w, g.min = w, g.v = m = (parseFloat(t.amount) || parseFloat(t.each) * (v > m ? m - 1 : l ? l === "y" ? m / v : v : Math.max(v, m / v)) || 0) * (n === "edges" ? -1 : 1), g.b = m < 0 ? r - m : r, g.u = fe(t.amount || t.each) || 0, e = e && m < 0 ? bg(e) : e;
    }
    return m = (g[p] - g.min) / g.max || 0, Zt(g.b + (e ? e(m) : m) * g.v) + g.u;
  };
}, Lh = function(i) {
  var t = Math.pow(10, ((i + "").split(".")[1] || "").length);
  return function(e) {
    var n = Zt(Math.round(parseFloat(e) / i) * i * t);
    return (n - n % 1) / t + (Bi(e) ? 0 : fe(e));
  };
}, dg = function(i, t) {
  var e = ve(i), n, r;
  return !e && vi(i) && (n = e = i.radius || Ze, i.values ? (i = $e(i.values), (r = !Bi(i[0])) && (n *= n)) : i = Lh(i.increment)), rn(t, e ? Dt(i) ? function(s) {
    return r = i(s), Math.abs(r - s) <= n ? r : s;
  } : function(s) {
    for (var o = parseFloat(r ? s.x : s), a = parseFloat(r ? s.y : 0), l = Ze, h = 0, c = i.length, p, f; c--; )
      r ? (p = i[c].x - o, f = i[c].y - a, p = p * p + f * f) : p = Math.abs(i[c] - o), p < l && (l = p, h = c);
    return h = !n || l <= n ? i[h] : s, r || h === s || Bi(s) ? h : h + fe(s);
  } : Lh(i));
}, pg = function(i, t, e, n) {
  return rn(ve(i) ? !t : e === !0 ? !!(e = 0) : !n, function() {
    return ve(i) ? i[~~(Math.random() * i.length)] : (e = e || 1e-5) && (n = e < 1 ? Math.pow(10, (e + "").length - 2) : 1) && Math.floor(Math.round((i - e / 2 + Math.random() * (t - i + e * 0.99)) / e) * e * n) / n;
  });
}, H1 = function() {
  for (var i = arguments.length, t = new Array(i), e = 0; e < i; e++)
    t[e] = arguments[e];
  return function(n) {
    return t.reduce(function(r, s) {
      return s(r);
    }, n);
  };
}, W1 = function(i, t) {
  return function(e) {
    return i(parseFloat(e)) + (t || fe(e));
  };
}, q1 = function(i, t, e) {
  return mg(i, t, 0, 1, e);
}, fg = function(i, t, e) {
  return rn(e, function(n) {
    return i[~~t(n)];
  });
}, Y1 = function i(t, e, n) {
  var r = e - t;
  return ve(t) ? fg(t, i(0, t.length), e) : rn(n, function(s) {
    return (r + (s - t) % r) % r + t;
  });
}, X1 = function i(t, e, n) {
  var r = e - t, s = r * 2;
  return ve(t) ? fg(t, i(0, t.length - 1), e) : rn(n, function(o) {
    return o = (s + (o - t) % s) % s || 0, t + (o > r ? s - o : o);
  });
}, Bs = function(i) {
  for (var t = 0, e = "", n, r, s, o; ~(n = i.indexOf("random(", t)); )
    s = i.indexOf(")", n), o = i.charAt(n + 7) === "[", r = i.substr(n + 7, s - n - 7).match(o ? Qm : kh), e += i.substr(t, n - t) + pg(o ? r : +r[0], o ? 0 : +r[1], +r[2] || 1e-5), t = s + 1;
  return e + i.substr(t, i.length - t);
}, mg = function(i, t, e, n, r) {
  var s = t - i, o = n - e;
  return rn(r, function(a) {
    return e + ((a - i) / s * o || 0);
  });
}, K1 = function i(t, e, n, r) {
  var s = isNaN(t + e) ? 0 : function(d) {
    return (1 - d) * t + d * e;
  };
  if (!s) {
    var o = ee(t), a = {}, l, h, c, p, f;
    if (n === !0 && (r = 1) && (n = null), o)
      t = {
        p: t
      }, e = {
        p: e
      };
    else if (ve(t) && !ve(e)) {
      for (c = [], p = t.length, f = p - 2, h = 1; h < p; h++)
        c.push(i(t[h - 1], t[h]));
      p--, s = function(d) {
        d *= p;
        var m = Math.min(f, ~~d);
        return c[m](d - m);
      }, n = e;
    } else r || (t = Bn(ve(t) ? [] : {}, t));
    if (!c) {
      for (l in e)
        Mc.call(a, t, l, "get", e[l]);
      s = function(d) {
        return Vc(d, a) || (o ? t.p : t);
      };
    }
  }
  return rn(n, s);
}, dp = function(i, t, e) {
  var n = i.labels, r = Ze, s, o, a;
  for (s in n)
    o = n[s] - t, o < 0 == !!e && o && r > (o = Math.abs(o)) && (a = s, r = o);
  return a;
}, We = function(i, t, e) {
  var n = i.vars, r = n[t], s = At, o = i._ctx, a, l, h;
  if (r)
    return a = n[t + "Params"], l = n.callbackScope || i, e && Yi.length && ta(), o && (At = o), h = a ? r.apply(l, a) : r.call(l), At = s, h;
}, cs = function(i) {
  return Zi(i), i.scrollTrigger && i.scrollTrigger.kill(!!ye), i.progress() < 1 && We(i, "onInterrupt"), i;
}, or, gg = [], yg = function(i) {
  if (i)
    if (i = !i.name && i.default || i, Ec() || i.headless) {
      var t = i.name, e = Dt(i), n = t && !e && i.init ? function() {
        this._props = [];
      } : i, r = {
        init: Ds,
        render: Vc,
        add: Mc,
        kill: uw,
        modifier: cw,
        rawVars: 0
      }, s = {
        targetTest: 0,
        get: 0,
        getSetter: Bc,
        aliases: {},
        register: 0
      };
      if (Ar(), i !== n) {
        if (Ge[t])
          return;
        ti(n, ti(ea(i, r), s)), Bn(n.prototype, Bn(r, ea(i, s))), Ge[n.prop = t] = n, i.targetTest && (zo.push(n), Ic[t] = 1), t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin";
      }
      $m(t, n), i.register && i.register(De, n, Me);
    } else
      gg.push(i);
}, yt = 255, us = {
  aqua: [0, yt, yt],
  lime: [0, yt, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, yt],
  navy: [0, 0, 128],
  white: [yt, yt, yt],
  olive: [128, 128, 0],
  yellow: [yt, yt, 0],
  orange: [yt, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [yt, 0, 0],
  pink: [yt, 192, 203],
  cyan: [0, yt, yt],
  transparent: [yt, yt, yt, 0]
}, Hl = function(i, t, e) {
  return i += i < 0 ? 1 : i > 1 ? -1 : 0, (i * 6 < 1 ? t + (e - t) * i * 6 : i < 0.5 ? e : i * 3 < 2 ? t + (e - t) * (2 / 3 - i) * 6 : t) * yt + 0.5 | 0;
}, vg = function(i, t, e) {
  var n = i ? Bi(i) ? [i >> 16, i >> 8 & yt, i & yt] : 0 : us.black, r, s, o, a, l, h, c, p, f, d;
  if (!n) {
    if (i.substr(-1) === "," && (i = i.substr(0, i.length - 1)), us[i])
      n = us[i];
    else if (i.charAt(0) === "#") {
      if (i.length < 6 && (r = i.charAt(1), s = i.charAt(2), o = i.charAt(3), i = "#" + r + r + s + s + o + o + (i.length === 5 ? i.charAt(4) + i.charAt(4) : "")), i.length === 9)
        return n = parseInt(i.substr(1, 6), 16), [n >> 16, n >> 8 & yt, n & yt, parseInt(i.substr(7), 16) / 255];
      i = parseInt(i.substr(1), 16), n = [i >> 16, i >> 8 & yt, i & yt];
    } else if (i.substr(0, 3) === "hsl") {
      if (n = d = i.match(kh), !t)
        a = +n[0] % 360 / 360, l = +n[1] / 100, h = +n[2] / 100, s = h <= 0.5 ? h * (l + 1) : h + l - h * l, r = h * 2 - s, n.length > 3 && (n[3] *= 1), n[0] = Hl(a + 1 / 3, r, s), n[1] = Hl(a, r, s), n[2] = Hl(a - 1 / 3, r, s);
      else if (~i.indexOf("="))
        return n = i.match(Xm), e && n.length < 4 && (n[3] = 1), n;
    } else
      n = i.match(kh) || us.transparent;
    n = n.map(Number);
  }
  return t && !d && (r = n[0] / yt, s = n[1] / yt, o = n[2] / yt, c = Math.max(r, s, o), p = Math.min(r, s, o), h = (c + p) / 2, c === p ? a = l = 0 : (f = c - p, l = h > 0.5 ? f / (2 - c - p) : f / (c + p), a = c === r ? (s - o) / f + (s < o ? 6 : 0) : c === s ? (o - r) / f + 2 : (r - s) / f + 4, a *= 60), n[0] = ~~(a + 0.5), n[1] = ~~(l * 100 + 0.5), n[2] = ~~(h * 100 + 0.5)), e && n.length < 4 && (n[3] = 1), n;
}, _g = function(i) {
  var t = [], e = [], n = -1;
  return i.split(Xi).forEach(function(r) {
    var s = r.match(sr) || [];
    t.push.apply(t, s), e.push(n += s.length + 1);
  }), t.c = e, t;
}, pp = function(i, t, e) {
  var n = "", r = (i + n).match(Xi), s = t ? "hsla(" : "rgba(", o = 0, a, l, h, c;
  if (!r)
    return i;
  if (r = r.map(function(p) {
    return (p = vg(p, t, 1)) && s + (t ? p[0] + "," + p[1] + "%," + p[2] + "%," + p[3] : p.join(",")) + ")";
  }), e && (h = _g(i), a = e.c, a.join(n) !== h.c.join(n)))
    for (l = i.replace(Xi, "1").split(sr), c = l.length - 1; o < c; o++)
      n += l[o] + (~a.indexOf(o) ? r.shift() || s + "0,0,0,0)" : (h.length ? h : r.length ? r : e).shift());
  if (!l)
    for (l = i.split(Xi), c = l.length - 1; o < c; o++)
      n += l[o] + r[o];
  return n + l[c];
}, Xi = function() {
  var i = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", t;
  for (t in us)
    i += "|" + t + "\\b";
  return new RegExp(i + ")", "gi");
}(), Q1 = /hsl[a]?\(/, xg = function(i) {
  var t = i.join(" "), e;
  if (Xi.lastIndex = 0, Xi.test(t))
    return e = Q1.test(t), i[1] = pp(i[1], e), i[0] = pp(i[0], e, _g(i[1])), !0;
}, Vs, He = function() {
  var i = Date.now, t = 500, e = 33, n = i(), r = n, s = 1e3 / 240, o = s, a = [], l, h, c, p, f, d, m = function g(y) {
    var b = i() - r, S = y === !0, C, I, T, R;
    if ((b > t || b < 0) && (n += b - e), r += b, T = r - n, C = T - o, (C > 0 || S) && (R = ++p.frame, f = T - p.time * 1e3, p.time = T = T / 1e3, o += C + (C >= s ? 4 : s - C), I = 1), S || (l = h(g)), I)
      for (d = 0; d < a.length; d++)
        a[d](T, f, R, y);
  };
  return p = {
    time: 0,
    frame: 0,
    tick: function() {
      m(!0);
    },
    deltaRatio: function(g) {
      return f / (1e3 / (g || 60));
    },
    wake: function() {
      Jm && (!Mh && Ec() && (pi = Mh = window, Cc = pi.document || {}, Ye.gsap = De, (pi.gsapVersions || (pi.gsapVersions = [])).push(De.version), Zm($o || pi.GreenSockGlobals || !pi.gsap && pi || {}), gg.forEach(yg)), c = typeof requestAnimationFrame < "u" && requestAnimationFrame, l && p.sleep(), h = c || function(g) {
        return setTimeout(g, o - p.time * 1e3 + 1 | 0);
      }, Vs = 1, m(2));
    },
    sleep: function() {
      (c ? cancelAnimationFrame : clearTimeout)(l), Vs = 0, h = Ds;
    },
    lagSmoothing: function(g, y) {
      t = g || 1 / 0, e = Math.min(y || 33, t);
    },
    fps: function(g) {
      s = 1e3 / (g || 240), o = p.time * 1e3 + s;
    },
    add: function(g, y, b) {
      var S = y ? function(C, I, T, R) {
        g(C, I, T, R), p.remove(S);
      } : g;
      return p.remove(g), a[b ? "unshift" : "push"](S), Ar(), S;
    },
    remove: function(g, y) {
      ~(y = a.indexOf(g)) && a.splice(y, 1) && d >= y && d--;
    },
    _listeners: a
  }, p;
}(), Ar = function() {
  return !Vs && He.wake();
}, st = {}, J1 = /^[\d.\-M][\d.\-,\s]/, Z1 = /["']/g, $1 = function(i) {
  for (var t = {}, e = i.substr(1, i.length - 3).split(":"), n = e[0], r = 1, s = e.length, o, a, l; r < s; r++)
    a = e[r], o = r !== s - 1 ? a.lastIndexOf(",") : a.length, l = a.substr(0, o), t[n] = isNaN(l) ? l.replace(Z1, "").trim() : +l, n = a.substr(o + 1).trim();
  return t;
}, tw = function(i) {
  var t = i.indexOf("(") + 1, e = i.indexOf(")"), n = i.indexOf("(", t);
  return i.substring(t, ~n && n < e ? i.indexOf(")", e + 1) : e);
}, ew = function(i) {
  var t = (i + "").split("("), e = st[t[0]];
  return e && t.length > 1 && e.config ? e.config.apply(null, ~i.indexOf("{") ? [$1(t[1])] : tw(i).split(",").map(ng)) : st._CE && J1.test(i) ? st._CE("", i) : e;
}, bg = function(i) {
  return function(t) {
    return 1 - i(1 - t);
  };
}, wg = function i(t, e) {
  for (var n = t._first, r; n; )
    n instanceof Se ? i(n, e) : n.vars.yoyoEase && (!n._yoyo || !n._repeat) && n._yoyo !== e && (n.timeline ? i(n.timeline, e) : (r = n._ease, n._ease = n._yEase, n._yEase = r, n._yoyo = e)), n = n._next;
}, In = function(i, t) {
  return i && (Dt(i) ? i : st[i] || ew(i)) || t;
}, zn = function(i, t, e, n) {
  e === void 0 && (e = function(o) {
    return 1 - t(1 - o);
  }), n === void 0 && (n = function(o) {
    return o < 0.5 ? t(o * 2) / 2 : 1 - t((1 - o) * 2) / 2;
  });
  var r = {
    easeIn: t,
    easeOut: e,
    easeInOut: n
  }, s;
  return ke(i, function(o) {
    st[o] = Ye[o] = r, st[s = o.toLowerCase()] = e;
    for (var a in r)
      st[s + (a === "easeIn" ? ".in" : a === "easeOut" ? ".out" : ".inOut")] = st[o + "." + a] = r[a];
  }), r;
}, Ag = function(i) {
  return function(t) {
    return t < 0.5 ? (1 - i(1 - t * 2)) / 2 : 0.5 + i((t - 0.5) * 2) / 2;
  };
}, Wl = function i(t, e, n) {
  var r = e >= 1 ? e : 1, s = (n || (t ? 0.3 : 0.45)) / (e < 1 ? e : 1), o = s / Rh * (Math.asin(1 / r) || 0), a = function(h) {
    return h === 1 ? 1 : r * Math.pow(2, -10 * h) * I1((h - o) * s) + 1;
  }, l = t === "out" ? a : t === "in" ? function(h) {
    return 1 - a(1 - h);
  } : Ag(a);
  return s = Rh / s, l.config = function(h, c) {
    return i(t, h, c);
  }, l;
}, ql = function i(t, e) {
  e === void 0 && (e = 1.70158);
  var n = function(s) {
    return s ? --s * s * ((e + 1) * s + e) + 1 : 0;
  }, r = t === "out" ? n : t === "in" ? function(s) {
    return 1 - n(1 - s);
  } : Ag(n);
  return r.config = function(s) {
    return i(t, s);
  }, r;
};
ke("Linear,Quad,Cubic,Quart,Quint,Strong", function(i, t) {
  var e = t < 5 ? t + 1 : t;
  zn(i + ",Power" + (e - 1), t ? function(n) {
    return Math.pow(n, e);
  } : function(n) {
    return n;
  }, function(n) {
    return 1 - Math.pow(1 - n, e);
  }, function(n) {
    return n < 0.5 ? Math.pow(n * 2, e) / 2 : 1 - Math.pow((1 - n) * 2, e) / 2;
  });
});
st.Linear.easeNone = st.none = st.Linear.easeIn;
zn("Elastic", Wl("in"), Wl("out"), Wl());
(function(i, t) {
  var e = 1 / t, n = 2 * e, r = 2.5 * e, s = function(o) {
    return o < e ? i * o * o : o < n ? i * Math.pow(o - 1.5 / t, 2) + 0.75 : o < r ? i * (o -= 2.25 / t) * o + 0.9375 : i * Math.pow(o - 2.625 / t, 2) + 0.984375;
  };
  zn("Bounce", function(o) {
    return 1 - s(1 - o);
  }, s);
})(7.5625, 2.75);
zn("Expo", function(i) {
  return i ? Math.pow(2, 10 * (i - 1)) : 0;
});
zn("Circ", function(i) {
  return -(qm(1 - i * i) - 1);
});
zn("Sine", function(i) {
  return i === 1 ? 1 : -P1(i * E1) + 1;
});
zn("Back", ql("in"), ql("out"), ql());
st.SteppedEase = st.steps = Ye.SteppedEase = {
  config: function(i, t) {
    i === void 0 && (i = 1);
    var e = 1 / i, n = i + (t ? 0 : 1), r = t ? 1 : 0, s = 1 - vt;
    return function(o) {
      return ((n * Js(0, s, o) | 0) + r) * e;
    };
  }
};
xr.ease = st["quad.out"];
ke("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(i) {
  return Rc += i + "," + i + "Params,";
});
var Sg = function(i, t) {
  this.id = C1++, i._gsap = this, this.target = i, this.harness = t, this.get = t ? t.get : eg, this.set = t ? t.getSetter : Bc;
}, Fs = /* @__PURE__ */ function() {
  function i(e) {
    this.vars = e, this._delay = +e.delay || 0, (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) && (this._rDelay = e.repeatDelay || 0, this._yoyo = !!e.yoyo || !!e.yoyoEase), this._ts = 1, wr(this, +e.duration, 1, 1), this.data = e.data, At && (this._ctx = At, At.data.push(this)), Vs || He.wake();
  }
  var t = i.prototype;
  return t.delay = function(e) {
    return e || e === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + e - this._delay), this._delay = e, this) : this._delay;
  }, t.duration = function(e) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? e + (e + this._rDelay) * this._repeat : e) : this.totalDuration() && this._dur;
  }, t.totalDuration = function(e) {
    return arguments.length ? (this._dirty = 0, wr(this, this._repeat < 0 ? e : (e - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur;
  }, t.totalTime = function(e, n) {
    if (Ar(), !arguments.length)
      return this._tTime;
    var r = this._dp;
    if (r && r.smoothChildTiming && this._ts) {
      for (La(this, e), !r._dp || r.parent || og(r, this); r && r.parent; )
        r.parent._time !== r._start + (r._ts >= 0 ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) && r.totalTime(r._tTime, !0), r = r.parent;
      !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && e < this._tDur || this._ts < 0 && e > 0 || !this._tDur && !e) && fi(this._dp, this, this._start - this._delay);
    }
    return (this._tTime !== e || !this._dur && !n || this._initted && Math.abs(this._zTime) === vt || !e && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = e), ig(this, e, n)), this;
  }, t.time = function(e, n) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), e + cp(this)) % (this._dur + this._rDelay) || (e ? this._dur : 0), n) : this._time;
  }, t.totalProgress = function(e, n) {
    return arguments.length ? this.totalTime(this.totalDuration() * e, n) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0;
  }, t.progress = function(e, n) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - e : e) + cp(this), n) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
  }, t.iteration = function(e, n) {
    var r = this.duration() + this._rDelay;
    return arguments.length ? this.totalTime(this._time + (e - 1) * r, n) : this._repeat ? br(this._tTime, r) + 1 : 1;
  }, t.timeScale = function(e, n) {
    if (!arguments.length)
      return this._rts === -vt ? 0 : this._rts;
    if (this._rts === e)
      return this;
    var r = this.parent && this._ts ? ia(this.parent._time, this) : this._tTime;
    return this._rts = +e || 0, this._ts = this._ps || e === -vt ? 0 : this._rts, this.totalTime(Js(-Math.abs(this._delay), this._tDur, r), n !== !1), Fa(this), V1(this);
  }, t.paused = function(e) {
    return arguments.length ? (this._ps !== e && (this._ps = e, e ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Ar(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== vt && (this._tTime -= vt)))), this) : this._ps;
  }, t.startTime = function(e) {
    if (arguments.length) {
      this._start = e;
      var n = this.parent || this._dp;
      return n && (n._sort || !this.parent) && fi(n, this, e - this._delay), this;
    }
    return this._start;
  }, t.endTime = function(e) {
    return this._start + (Re(e) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  }, t.rawTime = function(e) {
    var n = this.parent || this._dp;
    return n ? e && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? ia(n.rawTime(e), this) : this._tTime : this._tTime;
  }, t.revert = function(e) {
    e === void 0 && (e = M1);
    var n = ye;
    return ye = e, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(e), this.totalTime(-0.01, e.suppressEvents)), this.data !== "nested" && e.kill !== !1 && this.kill(), ye = n, this;
  }, t.globalTime = function(e) {
    for (var n = this, r = arguments.length ? e : n.rawTime(); n; )
      r = n._start + r / (Math.abs(n._ts) || 1), n = n._dp;
    return !this.parent && this._sat ? this._sat.globalTime(e) : r;
  }, t.repeat = function(e) {
    return arguments.length ? (this._repeat = e === 1 / 0 ? -2 : e, up(this)) : this._repeat === -2 ? 1 / 0 : this._repeat;
  }, t.repeatDelay = function(e) {
    if (arguments.length) {
      var n = this._time;
      return this._rDelay = e, up(this), n ? this.time(n) : this;
    }
    return this._rDelay;
  }, t.yoyo = function(e) {
    return arguments.length ? (this._yoyo = e, this) : this._yoyo;
  }, t.seek = function(e, n) {
    return this.totalTime(Ke(this, e), Re(n));
  }, t.restart = function(e, n) {
    return this.play().totalTime(e ? -this._delay : 0, Re(n));
  }, t.play = function(e, n) {
    return e != null && this.seek(e, n), this.reversed(!1).paused(!1);
  }, t.reverse = function(e, n) {
    return e != null && this.seek(e || this.totalDuration(), n), this.reversed(!0).paused(!1);
  }, t.pause = function(e, n) {
    return e != null && this.seek(e, n), this.paused(!0);
  }, t.resume = function() {
    return this.paused(!1);
  }, t.reversed = function(e) {
    return arguments.length ? (!!e !== this.reversed() && this.timeScale(-this._rts || (e ? -vt : 0)), this) : this._rts < 0;
  }, t.invalidate = function() {
    return this._initted = this._act = 0, this._zTime = -vt, this;
  }, t.isActive = function() {
    var e = this.parent || this._dp, n = this._start, r;
    return !!(!e || this._ts && this._initted && e.isActive() && (r = e.rawTime(!0)) >= n && r < this.endTime(!0) - vt);
  }, t.eventCallback = function(e, n, r) {
    var s = this.vars;
    return arguments.length > 1 ? (n ? (s[e] = n, r && (s[e + "Params"] = r), e === "onUpdate" && (this._onUpdate = n)) : delete s[e], this) : s[e];
  }, t.then = function(e) {
    var n = this;
    return new Promise(function(r) {
      var s = Dt(e) ? e : rg, o = function() {
        var a = n.then;
        n.then = null, Dt(s) && (s = s(n)) && (s.then || s === n) && (n.then = a), r(s), n.then = a;
      };
      n._initted && n.totalProgress() === 1 && n._ts >= 0 || !n._tTime && n._ts < 0 ? o() : n._prom = o;
    });
  }, t.kill = function() {
    cs(this);
  }, i;
}();
ti(Fs.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -vt,
  _prom: 0,
  _ps: !1,
  _rts: 1
});
var Se = /* @__PURE__ */ function(i) {
  Wm(t, i);
  function t(n, r) {
    var s;
    return n === void 0 && (n = {}), s = i.call(this, n) || this, s.labels = {}, s.smoothChildTiming = !!n.smoothChildTiming, s.autoRemoveChildren = !!n.autoRemoveChildren, s._sort = Re(n.sortChildren), Pt && fi(n.parent || Pt, Ci(s), r), n.reversed && s.reverse(), n.paused && s.paused(!0), n.scrollTrigger && ag(Ci(s), n.scrollTrigger), s;
  }
  var e = t.prototype;
  return e.to = function(n, r, s) {
    return _s(0, arguments, this), this;
  }, e.from = function(n, r, s) {
    return _s(1, arguments, this), this;
  }, e.fromTo = function(n, r, s, o) {
    return _s(2, arguments, this), this;
  }, e.set = function(n, r, s) {
    return r.duration = 0, r.parent = this, vs(r).repeatDelay || (r.repeat = 0), r.immediateRender = !!r.immediateRender, new Ut(n, r, Ke(this, s), 1), this;
  }, e.call = function(n, r, s) {
    return fi(this, Ut.delayedCall(0, n, r), s);
  }, e.staggerTo = function(n, r, s, o, a, l, h) {
    return s.duration = r, s.stagger = s.stagger || o, s.onComplete = l, s.onCompleteParams = h, s.parent = this, new Ut(n, s, Ke(this, a)), this;
  }, e.staggerFrom = function(n, r, s, o, a, l, h) {
    return s.runBackwards = 1, vs(s).immediateRender = Re(s.immediateRender), this.staggerTo(n, r, s, o, a, l, h);
  }, e.staggerFromTo = function(n, r, s, o, a, l, h, c) {
    return o.startAt = s, vs(o).immediateRender = Re(o.immediateRender), this.staggerTo(n, r, o, a, l, h, c);
  }, e.render = function(n, r, s) {
    var o = this._time, a = this._dirty ? this.totalDuration() : this._tDur, l = this._dur, h = n <= 0 ? 0 : Zt(n), c = this._zTime < 0 != n < 0 && (this._initted || !l), p, f, d, m, g, y, b, S, C, I, T, R;
    if (this !== Pt && h > a && n >= 0 && (h = a), h !== this._tTime || s || c) {
      if (o !== this._time && l && (h += this._time - o, n += this._time - o), p = h, C = this._start, S = this._ts, y = !S, c && (l || (o = this._zTime), (n || !r) && (this._zTime = n)), this._repeat) {
        if (T = this._yoyo, g = l + this._rDelay, this._repeat < -1 && n < 0)
          return this.totalTime(g * 100 + n, r, s);
        if (p = Zt(h % g), h === a ? (m = this._repeat, p = l) : (m = ~~(h / g), m && m === h / g && (p = l, m--), p > l && (p = l)), I = br(this._tTime, g), !o && this._tTime && I !== m && this._tTime - I * g - this._dur <= 0 && (I = m), T && m & 1 && (p = l - p, R = 1), m !== I && !this._lock) {
          var w = T && I & 1, v = w === (T && m & 1);
          if (m < I && (w = !w), o = w ? 0 : h % l ? l : h, this._lock = 1, this.render(o || (R ? 0 : Zt(m * g)), r, !l)._lock = 0, this._tTime = h, !r && this.parent && We(this, "onRepeat"), this.vars.repeatRefresh && !R && (this.invalidate()._lock = 1), o && o !== this._time || y !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
            return this;
          if (l = this._dur, a = this._tDur, v && (this._lock = 2, o = w ? l : -1e-4, this.render(o, !0), this.vars.repeatRefresh && !R && this.invalidate()), this._lock = 0, !this._ts && !y)
            return this;
          wg(this, R);
        }
      }
      if (this._hasPause && !this._forcing && this._lock < 2 && (b = U1(this, Zt(o), Zt(p)), b && (h -= p - (p = b._start))), this._tTime = h, this._time = p, this._act = !S, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = n, o = 0), !o && p && !r && !m && (We(this, "onStart"), this._tTime !== h))
        return this;
      if (p >= o && n >= 0)
        for (f = this._first; f; ) {
          if (d = f._next, (f._act || p >= f._start) && f._ts && b !== f) {
            if (f.parent !== this)
              return this.render(n, r, s);
            if (f.render(f._ts > 0 ? (p - f._start) * f._ts : (f._dirty ? f.totalDuration() : f._tDur) + (p - f._start) * f._ts, r, s), p !== this._time || !this._ts && !y) {
              b = 0, d && (h += this._zTime = -vt);
              break;
            }
          }
          f = d;
        }
      else {
        f = this._last;
        for (var x = n < 0 ? n : p; f; ) {
          if (d = f._prev, (f._act || x <= f._end) && f._ts && b !== f) {
            if (f.parent !== this)
              return this.render(n, r, s);
            if (f.render(f._ts > 0 ? (x - f._start) * f._ts : (f._dirty ? f.totalDuration() : f._tDur) + (x - f._start) * f._ts, r, s || ye && (f._initted || f._startAt)), p !== this._time || !this._ts && !y) {
              b = 0, d && (h += this._zTime = x ? -vt : vt);
              break;
            }
          }
          f = d;
        }
      }
      if (b && !r && (this.pause(), b.render(p >= o ? 0 : -vt)._zTime = p >= o ? 1 : -1, this._ts))
        return this._start = C, Fa(this), this.render(n, r, s);
      this._onUpdate && !r && We(this, "onUpdate", !0), (h === a && this._tTime >= this.totalDuration() || !h && o) && (C === this._start || Math.abs(S) !== Math.abs(this._ts)) && (this._lock || ((n || !l) && (h === a && this._ts > 0 || !h && this._ts < 0) && Zi(this, 1), !r && !(n < 0 && !o) && (h || o || !a) && (We(this, h === a && n >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(h < a && this.timeScale() > 0) && this._prom())));
    }
    return this;
  }, e.add = function(n, r) {
    var s = this;
    if (Bi(r) || (r = Ke(this, r, n)), !(n instanceof Fs)) {
      if (ve(n))
        return n.forEach(function(o) {
          return s.add(o, r);
        }), this;
      if (ee(n))
        return this.addLabel(n, r);
      if (Dt(n))
        n = Ut.delayedCall(0, n);
      else
        return this;
    }
    return this !== n ? fi(this, n, r) : this;
  }, e.getChildren = function(n, r, s, o) {
    n === void 0 && (n = !0), r === void 0 && (r = !0), s === void 0 && (s = !0), o === void 0 && (o = -Ze);
    for (var a = [], l = this._first; l; )
      l._start >= o && (l instanceof Ut ? r && a.push(l) : (s && a.push(l), n && a.push.apply(a, l.getChildren(!0, r, s)))), l = l._next;
    return a;
  }, e.getById = function(n) {
    for (var r = this.getChildren(1, 1, 1), s = r.length; s--; )
      if (r[s].vars.id === n)
        return r[s];
  }, e.remove = function(n) {
    return ee(n) ? this.removeLabel(n) : Dt(n) ? this.killTweensOf(n) : (Va(this, n), n === this._recent && (this._recent = this._last), Pn(this));
  }, e.totalTime = function(n, r) {
    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = Zt(He.time - (this._ts > 0 ? n / this._ts : (this.totalDuration() - n) / -this._ts))), i.prototype.totalTime.call(this, n, r), this._forcing = 0, this) : this._tTime;
  }, e.addLabel = function(n, r) {
    return this.labels[n] = Ke(this, r), this;
  }, e.removeLabel = function(n) {
    return delete this.labels[n], this;
  }, e.addPause = function(n, r, s) {
    var o = Ut.delayedCall(0, r || Ds, s);
    return o.data = "isPause", this._hasPause = 1, fi(this, o, Ke(this, n));
  }, e.removePause = function(n) {
    var r = this._first;
    for (n = Ke(this, n); r; )
      r._start === n && r.data === "isPause" && Zi(r), r = r._next;
  }, e.killTweensOf = function(n, r, s) {
    for (var o = this.getTweensOf(n, s), a = o.length; a--; )
      Hi !== o[a] && o[a].kill(n, r);
    return this;
  }, e.getTweensOf = function(n, r) {
    for (var s = [], o = $e(n), a = this._first, l = Bi(r), h; a; )
      a instanceof Ut ? O1(a._targets, o) && (l ? (!Hi || a._initted && a._ts) && a.globalTime(0) <= r && a.globalTime(a.totalDuration()) > r : !r || a.isActive()) && s.push(a) : (h = a.getTweensOf(o, r)).length && s.push.apply(s, h), a = a._next;
    return s;
  }, e.tweenTo = function(n, r) {
    r = r || {};
    var s = this, o = Ke(s, n), a = r, l = a.startAt, h = a.onStart, c = a.onStartParams, p = a.immediateRender, f, d = Ut.to(s, ti({
      ease: r.ease || "none",
      lazy: !1,
      immediateRender: !1,
      time: o,
      overwrite: "auto",
      duration: r.duration || Math.abs((o - (l && "time" in l ? l.time : s._time)) / s.timeScale()) || vt,
      onStart: function() {
        if (s.pause(), !f) {
          var m = r.duration || Math.abs((o - (l && "time" in l ? l.time : s._time)) / s.timeScale());
          d._dur !== m && wr(d, m, 0, 1).render(d._time, !0, !0), f = 1;
        }
        h && h.apply(d, c || []);
      }
    }, r));
    return p ? d.render(0) : d;
  }, e.tweenFromTo = function(n, r, s) {
    return this.tweenTo(r, ti({
      startAt: {
        time: Ke(this, n)
      }
    }, s));
  }, e.recent = function() {
    return this._recent;
  }, e.nextLabel = function(n) {
    return n === void 0 && (n = this._time), dp(this, Ke(this, n));
  }, e.previousLabel = function(n) {
    return n === void 0 && (n = this._time), dp(this, Ke(this, n), 1);
  }, e.currentLabel = function(n) {
    return arguments.length ? this.seek(n, !0) : this.previousLabel(this._time + vt);
  }, e.shiftChildren = function(n, r, s) {
    s === void 0 && (s = 0);
    for (var o = this._first, a = this.labels, l; o; )
      o._start >= s && (o._start += n, o._end += n), o = o._next;
    if (r)
      for (l in a)
        a[l] >= s && (a[l] += n);
    return Pn(this);
  }, e.invalidate = function(n) {
    var r = this._first;
    for (this._lock = 0; r; )
      r.invalidate(n), r = r._next;
    return i.prototype.invalidate.call(this, n);
  }, e.clear = function(n) {
    n === void 0 && (n = !0);
    for (var r = this._first, s; r; )
      s = r._next, this.remove(r), r = s;
    return this._dp && (this._time = this._tTime = this._pTime = 0), n && (this.labels = {}), Pn(this);
  }, e.totalDuration = function(n) {
    var r = 0, s = this, o = s._last, a = Ze, l, h, c;
    if (arguments.length)
      return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -n : n));
    if (s._dirty) {
      for (c = s.parent; o; )
        l = o._prev, o._dirty && o.totalDuration(), h = o._start, h > a && s._sort && o._ts && !s._lock ? (s._lock = 1, fi(s, o, h - o._delay, 1)._lock = 0) : a = h, h < 0 && o._ts && (r -= h, (!c && !s._dp || c && c.smoothChildTiming) && (s._start += h / s._ts, s._time -= h, s._tTime -= h), s.shiftChildren(-h, !1, -1 / 0), a = 0), o._end > r && o._ts && (r = o._end), o = l;
      wr(s, s === Pt && s._time > r ? s._time : r, 1, 1), s._dirty = 0;
    }
    return s._tDur;
  }, t.updateRoot = function(n) {
    if (Pt._ts && (ig(Pt, ia(n, Pt)), tg = He.frame), He.frame >= lp) {
      lp += qe.autoSleep || 120;
      var r = Pt._first;
      if ((!r || !r._ts) && qe.autoSleep && He._listeners.length < 2) {
        for (; r && !r._ts; )
          r = r._next;
        r || He.sleep();
      }
    }
  }, t;
}(Fs);
ti(Se.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});
var iw = function(i, t, e, n, r, s, o) {
  var a = new Me(this._pt, i, t, 0, 1, Rg, null, r), l = 0, h = 0, c, p, f, d, m, g, y, b;
  for (a.b = e, a.e = n, e += "", n += "", (y = ~n.indexOf("random(")) && (n = Bs(n)), s && (b = [e, n], s(b, i, t), e = b[0], n = b[1]), p = e.match(jl) || []; c = jl.exec(n); )
    d = c[0], m = n.substring(l, c.index), f ? f = (f + 1) % 5 : m.substr(-5) === "rgba(" && (f = 1), d !== p[h++] && (g = parseFloat(p[h - 1]) || 0, a._pt = {
      _next: a._pt,
      p: m || h === 1 ? m : ",",
      //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
      s: g,
      c: d.charAt(1) === "=" ? ur(g, d) - g : parseFloat(d) - g,
      m: f && f < 4 ? Math.round : 0
    }, l = jl.lastIndex);
  return a.c = l < n.length ? n.substring(l, n.length) : "", a.fp = o, (Km.test(n) || y) && (a.e = 0), this._pt = a, a;
}, Mc = function(i, t, e, n, r, s, o, a, l, h) {
  Dt(n) && (n = n(r || 0, i, s));
  var c = i[t], p = e !== "get" ? e : Dt(c) ? l ? i[t.indexOf("set") || !Dt(i["get" + t.substr(3)]) ? t : "get" + t.substr(3)](l) : i[t]() : c, f = Dt(c) ? l ? aw : Pg : Dc, d;
  if (ee(n) && (~n.indexOf("random(") && (n = Bs(n)), n.charAt(1) === "=" && (d = ur(p, n) + (fe(p) || 0), (d || d === 0) && (n = d))), !h || p !== n || Nh)
    return !isNaN(p * n) && n !== "" ? (d = new Me(this._pt, i, t, +p || 0, n - (p || 0), typeof c == "boolean" ? hw : Ig, 0, f), l && (d.fp = l), o && d.modifier(o, this, i), this._pt = d) : (!c && !(t in i) && Pc(t, n), iw.call(this, i, t, p, n, f, a || qe.stringFilter, l));
}, nw = function(i, t, e, n, r) {
  if (Dt(i) && (i = xs(i, r, t, e, n)), !vi(i) || i.style && i.nodeType || ve(i) || Ym(i))
    return ee(i) ? xs(i, r, t, e, n) : i;
  var s = {}, o;
  for (o in i)
    s[o] = xs(i[o], r, t, e, n);
  return s;
}, Tg = function(i, t, e, n, r, s) {
  var o, a, l, h;
  if (Ge[i] && (o = new Ge[i]()).init(r, o.rawVars ? t[i] : nw(t[i], n, r, s, e), e, n, s) !== !1 && (e._pt = a = new Me(e._pt, r, i, 0, 1, o.render, o, 0, o.priority), e !== or))
    for (l = e._ptLookup[e._targets.indexOf(r)], h = o._props.length; h--; )
      l[o._props[h]] = a;
  return o;
}, Hi, Nh, Oc = function i(t, e, n) {
  var r = t.vars, s = r.ease, o = r.startAt, a = r.immediateRender, l = r.lazy, h = r.onUpdate, c = r.runBackwards, p = r.yoyoEase, f = r.keyframes, d = r.autoRevert, m = t._dur, g = t._startAt, y = t._targets, b = t.parent, S = b && b.data === "nested" ? b.vars.targets : y, C = t._overwrite === "auto" && !Sc, I = t.timeline, T, R, w, v, x, A, P, M, k, B, V, N, U;
  if (I && (!f || !s) && (s = "none"), t._ease = In(s, xr.ease), t._yEase = p ? bg(In(p === !0 ? s : p, xr.ease)) : 0, p && t._yoyo && !t._repeat && (p = t._yEase, t._yEase = t._ease, t._ease = p), t._from = !I && !!r.runBackwards, !I || f && !r.stagger) {
    if (M = y[0] ? Cn(y[0]).harness : 0, N = M && r[M.prop], T = ea(r, Ic), g && (g._zTime < 0 && g.progress(1), e < 0 && c && a && !d ? g.render(-1, !0) : g.revert(c && m ? Uo : k1), g._lazy = 0), o) {
      if (Zi(t._startAt = Ut.set(y, ti({
        data: "isStart",
        overwrite: !1,
        parent: b,
        immediateRender: !0,
        lazy: !g && Re(l),
        startAt: null,
        delay: 0,
        onUpdate: h && function() {
          return We(t, "onUpdate");
        },
        stagger: 0
      }, o))), t._startAt._dp = 0, t._startAt._sat = t, e < 0 && (ye || !a && !d) && t._startAt.revert(Uo), a && m && e <= 0 && n <= 0) {
        e && (t._zTime = e);
        return;
      }
    } else if (c && m && !g) {
      if (e && (a = !1), w = ti({
        overwrite: !1,
        data: "isFromStart",
        //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
        lazy: a && !g && Re(l),
        immediateRender: a,
        //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
        stagger: 0,
        parent: b
        //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})
      }, T), N && (w[M.prop] = N), Zi(t._startAt = Ut.set(y, w)), t._startAt._dp = 0, t._startAt._sat = t, e < 0 && (ye ? t._startAt.revert(Uo) : t._startAt.render(-1, !0)), t._zTime = e, !a)
        i(t._startAt, vt, vt);
      else if (!e)
        return;
    }
    for (t._pt = t._ptCache = 0, l = m && Re(l) || l && !m, R = 0; R < y.length; R++) {
      if (x = y[R], P = x._gsap || kc(y)[R]._gsap, t._ptLookup[R] = B = {}, Oh[P.id] && Yi.length && ta(), V = S === y ? R : S.indexOf(x), M && (k = new M()).init(x, N || T, t, V, S) !== !1 && (t._pt = v = new Me(t._pt, x, k.name, 0, 1, k.render, k, 0, k.priority), k._props.forEach(function(K) {
        B[K] = v;
      }), k.priority && (A = 1)), !M || N)
        for (w in T)
          Ge[w] && (k = Tg(w, T, t, V, x, S)) ? k.priority && (A = 1) : B[w] = v = Mc.call(t, x, w, "get", T[w], V, S, 0, r.stringFilter);
      t._op && t._op[R] && t.kill(x, t._op[R]), C && t._pt && (Hi = t, Pt.killTweensOf(x, B, t.globalTime(e)), U = !t.parent, Hi = 0), t._pt && l && (Oh[P.id] = 1);
    }
    A && kg(t), t._onInit && t._onInit(t);
  }
  t._onUpdate = h, t._initted = (!t._op || t._pt) && !U, f && e <= 0 && I.render(Ze, !0, !0);
}, rw = function(i, t, e, n, r, s, o, a) {
  var l = (i._pt && i._ptCache || (i._ptCache = {}))[t], h, c, p, f;
  if (!l)
    for (l = i._ptCache[t] = [], p = i._ptLookup, f = i._targets.length; f--; ) {
      if (h = p[f][t], h && h.d && h.d._pt)
        for (h = h.d._pt; h && h.p !== t && h.fp !== t; )
          h = h._next;
      if (!h)
        return Nh = 1, i.vars[t] = "+=0", Oc(i, o), Nh = 0, a ? Os(t + " not eligible for reset") : 1;
      l.push(h);
    }
  for (f = l.length; f--; )
    c = l[f], h = c._pt || c, h.s = (n || n === 0) && !r ? n : h.s + (n || 0) + s * h.c, h.c = e - h.s, c.e && (c.e = Ft(e) + fe(c.e)), c.b && (c.b = h.s + fe(c.b));
}, sw = function(i, t) {
  var e = i[0] ? Cn(i[0]).harness : 0, n = e && e.aliases, r, s, o, a;
  if (!n)
    return t;
  r = Bn({}, t);
  for (s in n)
    if (s in r)
      for (a = n[s].split(","), o = a.length; o--; )
        r[a[o]] = r[s];
  return r;
}, ow = function(i, t, e, n) {
  var r = t.ease || n || "power1.inOut", s, o;
  if (ve(t))
    o = e[i] || (e[i] = []), t.forEach(function(a, l) {
      return o.push({
        t: l / (t.length - 1) * 100,
        v: a,
        e: r
      });
    });
  else
    for (s in t)
      o = e[s] || (e[s] = []), s === "ease" || o.push({
        t: parseFloat(i),
        v: t[s],
        e: r
      });
}, xs = function(i, t, e, n, r) {
  return Dt(i) ? i.call(t, e, n, r) : ee(i) && ~i.indexOf("random(") ? Bs(i) : i;
}, Eg = Rc + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", Cg = {};
ke(Eg + ",id,stagger,delay,duration,paused,scrollTrigger", function(i) {
  return Cg[i] = 1;
});
var Ut = /* @__PURE__ */ function(i) {
  Wm(t, i);
  function t(n, r, s, o) {
    var a;
    typeof r == "number" && (s.duration = r, r = s, s = null), a = i.call(this, o ? r : vs(r)) || this;
    var l = a.vars, h = l.duration, c = l.delay, p = l.immediateRender, f = l.stagger, d = l.overwrite, m = l.keyframes, g = l.defaults, y = l.scrollTrigger, b = l.yoyoEase, S = r.parent || Pt, C = (ve(n) || Ym(n) ? Bi(n[0]) : "length" in r) ? [n] : $e(n), I, T, R, w, v, x, A, P;
    if (a._targets = C.length ? kc(C) : Os("GSAP target " + n + " not found. https://gsap.com", !qe.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = d, m || f || Io(h) || Io(c)) {
      if (r = a.vars, I = a.timeline = new Se({
        data: "nested",
        defaults: g || {},
        targets: S && S.data === "nested" ? S.vars.targets : C
      }), I.kill(), I.parent = I._dp = Ci(a), I._start = 0, f || Io(h) || Io(c)) {
        if (w = C.length, A = f && ug(f), vi(f))
          for (v in f)
            ~Eg.indexOf(v) && (P || (P = {}), P[v] = f[v]);
        for (T = 0; T < w; T++)
          R = ea(r, Cg), R.stagger = 0, b && (R.yoyoEase = b), P && Bn(R, P), x = C[T], R.duration = +xs(h, Ci(a), T, x, C), R.delay = (+xs(c, Ci(a), T, x, C) || 0) - a._delay, !f && w === 1 && R.delay && (a._delay = c = R.delay, a._start += c, R.delay = 0), I.to(x, R, A ? A(T, x, C) : 0), I._ease = st.none;
        I.duration() ? h = c = 0 : a.timeline = 0;
      } else if (m) {
        vs(ti(I.vars.defaults, {
          ease: "none"
        })), I._ease = In(m.ease || r.ease || "none");
        var M = 0, k, B, V;
        if (ve(m))
          m.forEach(function(N) {
            return I.to(C, N, ">");
          }), I.duration();
        else {
          R = {};
          for (v in m)
            v === "ease" || v === "easeEach" || ow(v, m[v], R, m.easeEach);
          for (v in R)
            for (k = R[v].sort(function(N, U) {
              return N.t - U.t;
            }), M = 0, T = 0; T < k.length; T++)
              B = k[T], V = {
                ease: B.e,
                duration: (B.t - (T ? k[T - 1].t : 0)) / 100 * h
              }, V[v] = B.v, I.to(C, V, M), M += V.duration;
          I.duration() < h && I.to({}, {
            duration: h - I.duration()
          });
        }
      }
      h || a.duration(h = I.duration());
    } else
      a.timeline = 0;
    return d === !0 && !Sc && (Hi = Ci(a), Pt.killTweensOf(C), Hi = 0), fi(S, Ci(a), s), r.reversed && a.reverse(), r.paused && a.paused(!0), (p || !h && !m && a._start === Zt(S._time) && Re(p) && F1(Ci(a)) && S.data !== "nested") && (a._tTime = -vt, a.render(Math.max(0, -c) || 0)), y && ag(Ci(a), y), a;
  }
  var e = t.prototype;
  return e.render = function(n, r, s) {
    var o = this._time, a = this._tDur, l = this._dur, h = n < 0, c = n > a - vt && !h ? a : n < vt ? 0 : n, p, f, d, m, g, y, b, S, C;
    if (!l)
      N1(this, n, r, s);
    else if (c !== this._tTime || !n || s || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== h) {
      if (p = c, S = this.timeline, this._repeat) {
        if (m = l + this._rDelay, this._repeat < -1 && h)
          return this.totalTime(m * 100 + n, r, s);
        if (p = Zt(c % m), c === a ? (d = this._repeat, p = l) : (d = ~~(c / m), d && d === Zt(c / m) && (p = l, d--), p > l && (p = l)), y = this._yoyo && d & 1, y && (C = this._yEase, p = l - p), g = br(this._tTime, m), p === o && !s && this._initted && d === g)
          return this._tTime = c, this;
        d !== g && (S && this._yEase && wg(S, y), this.vars.repeatRefresh && !y && !this._lock && this._time !== m && this._initted && (this._lock = s = 1, this.render(Zt(m * d), !0).invalidate()._lock = 0));
      }
      if (!this._initted) {
        if (lg(this, h ? n : p, s, r, c))
          return this._tTime = 0, this;
        if (o !== this._time && !(s && this.vars.repeatRefresh && d !== g))
          return this;
        if (l !== this._dur)
          return this.render(n, r, s);
      }
      if (this._tTime = c, this._time = p, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = b = (C || this._ease)(p / l), this._from && (this.ratio = b = 1 - b), p && !o && !r && !d && (We(this, "onStart"), this._tTime !== c))
        return this;
      for (f = this._pt; f; )
        f.r(b, f.d), f = f._next;
      S && S.render(n < 0 ? n : S._dur * S._ease(p / this._dur), r, s) || this._startAt && (this._zTime = n), this._onUpdate && !r && (h && Dh(this, n, r, s), We(this, "onUpdate")), this._repeat && d !== g && this.vars.onRepeat && !r && this.parent && We(this, "onRepeat"), (c === this._tDur || !c) && this._tTime === c && (h && !this._onUpdate && Dh(this, n, !0, !0), (n || !l) && (c === this._tDur && this._ts > 0 || !c && this._ts < 0) && Zi(this, 1), !r && !(h && !o) && (c || o || y) && (We(this, c === a ? "onComplete" : "onReverseComplete", !0), this._prom && !(c < a && this.timeScale() > 0) && this._prom()));
    }
    return this;
  }, e.targets = function() {
    return this._targets;
  }, e.invalidate = function(n) {
    return (!n || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(n), i.prototype.invalidate.call(this, n);
  }, e.resetTo = function(n, r, s, o, a) {
    Vs || He.wake(), this._ts || this.play();
    var l = Math.min(this._dur, (this._dp._time - this._start) * this._ts), h;
    return this._initted || Oc(this, l), h = this._ease(l / this._dur), rw(this, n, r, s, o, h, l, a) ? this.resetTo(n, r, s, o, 1) : (La(this, 0), this.parent || sg(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0));
  }, e.kill = function(n, r) {
    if (r === void 0 && (r = "all"), !n && (!r || r === "all"))
      return this._lazy = this._pt = 0, this.parent ? cs(this) : this;
    if (this.timeline) {
      var s = this.timeline.totalDuration();
      return this.timeline.killTweensOf(n, r, Hi && Hi.vars.overwrite !== !0)._first || cs(this), this.parent && s !== this.timeline.totalDuration() && wr(this, this._dur * this.timeline._tDur / s, 0, 1), this;
    }
    var o = this._targets, a = n ? $e(n) : o, l = this._ptLookup, h = this._pt, c, p, f, d, m, g, y;
    if ((!r || r === "all") && B1(o, a))
      return r === "all" && (this._pt = 0), cs(this);
    for (c = this._op = this._op || [], r !== "all" && (ee(r) && (m = {}, ke(r, function(b) {
      return m[b] = 1;
    }), r = m), r = sw(o, r)), y = o.length; y--; )
      if (~a.indexOf(o[y])) {
        p = l[y], r === "all" ? (c[y] = r, d = p, f = {}) : (f = c[y] = c[y] || {}, d = r);
        for (m in d)
          g = p && p[m], g && ((!("kill" in g.d) || g.d.kill(m) === !0) && Va(this, g, "_pt"), delete p[m]), f !== "all" && (f[m] = 1);
      }
    return this._initted && !this._pt && h && cs(this), this;
  }, t.to = function(n, r) {
    return new t(n, r, arguments[2]);
  }, t.from = function(n, r) {
    return _s(1, arguments);
  }, t.delayedCall = function(n, r, s, o) {
    return new t(r, 0, {
      immediateRender: !1,
      lazy: !1,
      overwrite: !1,
      delay: n,
      onComplete: r,
      onReverseComplete: r,
      onCompleteParams: s,
      onReverseCompleteParams: s,
      callbackScope: o
    });
  }, t.fromTo = function(n, r, s) {
    return _s(2, arguments);
  }, t.set = function(n, r) {
    return r.duration = 0, r.repeatDelay || (r.repeat = 0), new t(n, r);
  }, t.killTweensOf = function(n, r, s) {
    return Pt.killTweensOf(n, r, s);
  }, t;
}(Fs);
ti(Ut.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
});
ke("staggerTo,staggerFrom,staggerFromTo", function(i) {
  Ut[i] = function() {
    var t = new Se(), e = Vh.call(arguments, 0);
    return e.splice(i === "staggerFromTo" ? 5 : 4, 0, 0), t[i].apply(t, e);
  };
});
var Dc = function(i, t, e) {
  return i[t] = e;
}, Pg = function(i, t, e) {
  return i[t](e);
}, aw = function(i, t, e, n) {
  return i[t](n.fp, e);
}, lw = function(i, t, e) {
  return i.setAttribute(t, e);
}, Bc = function(i, t) {
  return Dt(i[t]) ? Pg : Tc(i[t]) && i.setAttribute ? lw : Dc;
}, Ig = function(i, t) {
  return t.set(t.t, t.p, Math.round((t.s + t.c * i) * 1e6) / 1e6, t);
}, hw = function(i, t) {
  return t.set(t.t, t.p, !!(t.s + t.c * i), t);
}, Rg = function(i, t) {
  var e = t._pt, n = "";
  if (!i && t.b)
    n = t.b;
  else if (i === 1 && t.e)
    n = t.e;
  else {
    for (; e; )
      n = e.p + (e.m ? e.m(e.s + e.c * i) : Math.round((e.s + e.c * i) * 1e4) / 1e4) + n, e = e._next;
    n += t.c;
  }
  t.set(t.t, t.p, n, t);
}, Vc = function(i, t) {
  for (var e = t._pt; e; )
    e.r(i, e.d), e = e._next;
}, cw = function(i, t, e, n) {
  for (var r = this._pt, s; r; )
    s = r._next, r.p === n && r.modifier(i, t, e), r = s;
}, uw = function(i) {
  for (var t = this._pt, e, n; t; )
    n = t._next, t.p === i && !t.op || t.op === i ? Va(this, t, "_pt") : t.dep || (e = 1), t = n;
  return !e;
}, dw = function(i, t, e, n) {
  n.mSet(i, t, n.m.call(n.tween, e, n.mt), n);
}, kg = function(i) {
  for (var t = i._pt, e, n, r, s; t; ) {
    for (e = t._next, n = r; n && n.pr > t.pr; )
      n = n._next;
    (t._prev = n ? n._prev : s) ? t._prev._next = t : r = t, (t._next = n) ? n._prev = t : s = t, t = e;
  }
  i._pt = r;
}, Me = /* @__PURE__ */ function() {
  function i(e, n, r, s, o, a, l, h, c) {
    this.t = n, this.s = s, this.c = o, this.p = r, this.r = a || Ig, this.d = l || this, this.set = h || Dc, this.pr = c || 0, this._next = e, e && (e._prev = this);
  }
  var t = i.prototype;
  return t.modifier = function(e, n, r) {
    this.mSet = this.mSet || this.set, this.set = dw, this.m = e, this.mt = r, this.tween = n;
  }, i;
}();
ke(Rc + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(i) {
  return Ic[i] = 1;
});
Ye.TweenMax = Ye.TweenLite = Ut;
Ye.TimelineLite = Ye.TimelineMax = Se;
Pt = new Se({
  sortChildren: !1,
  defaults: xr,
  autoRemoveChildren: !0,
  id: "root",
  smoothChildTiming: !0
});
qe.stringFilter = xg;
var Rn = [], jo = {}, pw = [], fp = 0, fw = 0, Yl = function(i) {
  return (jo[i] || pw).map(function(t) {
    return t();
  });
}, Uh = function() {
  var i = Date.now(), t = [];
  i - fp > 2 && (Yl("matchMediaInit"), Rn.forEach(function(e) {
    var n = e.queries, r = e.conditions, s, o, a, l;
    for (o in n)
      s = pi.matchMedia(n[o]).matches, s && (a = 1), s !== r[o] && (r[o] = s, l = 1);
    l && (e.revert(), a && t.push(e));
  }), Yl("matchMediaRevert"), t.forEach(function(e) {
    return e.onMatch(e, function(n) {
      return e.add(null, n);
    });
  }), fp = i, Yl("matchMedia"));
}, Mg = /* @__PURE__ */ function() {
  function i(e, n) {
    this.selector = n && Fh(n), this.data = [], this._r = [], this.isReverted = !1, this.id = fw++, e && this.add(e);
  }
  var t = i.prototype;
  return t.add = function(e, n, r) {
    Dt(e) && (r = n, n = e, e = Dt);
    var s = this, o = function() {
      var a = At, l = s.selector, h;
      return a && a !== s && a.data.push(s), r && (s.selector = Fh(r)), At = s, h = n.apply(s, arguments), Dt(h) && s._r.push(h), At = a, s.selector = l, s.isReverted = !1, h;
    };
    return s.last = o, e === Dt ? o(s, function(a) {
      return s.add(null, a);
    }) : e ? s[e] = o : o;
  }, t.ignore = function(e) {
    var n = At;
    At = null, e(this), At = n;
  }, t.getTweens = function() {
    var e = [];
    return this.data.forEach(function(n) {
      return n instanceof i ? e.push.apply(e, n.getTweens()) : n instanceof Ut && !(n.parent && n.parent.data === "nested") && e.push(n);
    }), e;
  }, t.clear = function() {
    this._r.length = this.data.length = 0;
  }, t.kill = function(e, n) {
    var r = this;
    if (e ? function() {
      for (var o = r.getTweens(), a = r.data.length, l; a--; )
        l = r.data[a], l.data === "isFlip" && (l.revert(), l.getChildren(!0, !0, !1).forEach(function(h) {
          return o.splice(o.indexOf(h), 1);
        }));
      for (o.map(function(h) {
        return {
          g: h._dur || h._delay || h._sat && !h._sat.vars.immediateRender ? h.globalTime(0) : -1 / 0,
          t: h
        };
      }).sort(function(h, c) {
        return c.g - h.g || -1 / 0;
      }).forEach(function(h) {
        return h.t.revert(e);
      }), a = r.data.length; a--; )
        l = r.data[a], l instanceof Se ? l.data !== "nested" && (l.scrollTrigger && l.scrollTrigger.revert(), l.kill()) : !(l instanceof Ut) && l.revert && l.revert(e);
      r._r.forEach(function(h) {
        return h(e, r);
      }), r.isReverted = !0;
    }() : this.data.forEach(function(o) {
      return o.kill && o.kill();
    }), this.clear(), n)
      for (var s = Rn.length; s--; )
        Rn[s].id === this.id && Rn.splice(s, 1);
  }, t.revert = function(e) {
    this.kill(e || {});
  }, i;
}(), mw = /* @__PURE__ */ function() {
  function i(e) {
    this.contexts = [], this.scope = e, At && At.data.push(this);
  }
  var t = i.prototype;
  return t.add = function(e, n, r) {
    vi(e) || (e = {
      matches: e
    });
    var s = new Mg(0, r || this.scope), o = s.conditions = {}, a, l, h;
    At && !s.selector && (s.selector = At.selector), this.contexts.push(s), n = s.add("onMatch", n), s.queries = e;
    for (l in e)
      l === "all" ? h = 1 : (a = pi.matchMedia(e[l]), a && (Rn.indexOf(s) < 0 && Rn.push(s), (o[l] = a.matches) && (h = 1), a.addListener ? a.addListener(Uh) : a.addEventListener("change", Uh)));
    return h && n(s, function(c) {
      return s.add(null, c);
    }), this;
  }, t.revert = function(e) {
    this.kill(e || {});
  }, t.kill = function(e) {
    this.contexts.forEach(function(n) {
      return n.kill(e, !0);
    });
  }, i;
}(), na = {
  registerPlugin: function() {
    for (var i = arguments.length, t = new Array(i), e = 0; e < i; e++)
      t[e] = arguments[e];
    t.forEach(function(n) {
      return yg(n);
    });
  },
  timeline: function(i) {
    return new Se(i);
  },
  getTweensOf: function(i, t) {
    return Pt.getTweensOf(i, t);
  },
  getProperty: function(i, t, e, n) {
    ee(i) && (i = $e(i)[0]);
    var r = Cn(i || {}).get, s = e ? rg : ng;
    return e === "native" && (e = ""), i && (t ? s((Ge[t] && Ge[t].get || r)(i, t, e, n)) : function(o, a, l) {
      return s((Ge[o] && Ge[o].get || r)(i, o, a, l));
    });
  },
  quickSetter: function(i, t, e) {
    if (i = $e(i), i.length > 1) {
      var n = i.map(function(h) {
        return De.quickSetter(h, t, e);
      }), r = n.length;
      return function(h) {
        for (var c = r; c--; )
          n[c](h);
      };
    }
    i = i[0] || {};
    var s = Ge[t], o = Cn(i), a = o.harness && (o.harness.aliases || {})[t] || t, l = s ? function(h) {
      var c = new s();
      or._pt = 0, c.init(i, e ? h + e : h, or, 0, [i]), c.render(1, c), or._pt && Vc(1, or);
    } : o.set(i, a);
    return s ? l : function(h) {
      return l(i, a, e ? h + e : h, o, 1);
    };
  },
  quickTo: function(i, t, e) {
    var n, r = De.to(i, Bn((n = {}, n[t] = "+=0.1", n.paused = !0, n), e || {})), s = function(o, a, l) {
      return r.resetTo(t, o, a, l);
    };
    return s.tween = r, s;
  },
  isTweening: function(i) {
    return Pt.getTweensOf(i, !0).length > 0;
  },
  defaults: function(i) {
    return i && i.ease && (i.ease = In(i.ease, xr.ease)), hp(xr, i || {});
  },
  config: function(i) {
    return hp(qe, i || {});
  },
  registerEffect: function(i) {
    var t = i.name, e = i.effect, n = i.plugins, r = i.defaults, s = i.extendTimeline;
    (n || "").split(",").forEach(function(o) {
      return o && !Ge[o] && !Ye[o] && Os(t + " effect requires " + o + " plugin.");
    }), Gl[t] = function(o, a, l) {
      return e($e(o), ti(a || {}, r), l);
    }, s && (Se.prototype[t] = function(o, a, l) {
      return this.add(Gl[t](o, vi(a) ? a : (l = a) && {}, this), l);
    });
  },
  registerEase: function(i, t) {
    st[i] = In(t);
  },
  parseEase: function(i, t) {
    return arguments.length ? In(i, t) : st;
  },
  getById: function(i) {
    return Pt.getById(i);
  },
  exportRoot: function(i, t) {
    i === void 0 && (i = {});
    var e = new Se(i), n, r;
    for (e.smoothChildTiming = Re(i.smoothChildTiming), Pt.remove(e), e._dp = 0, e._time = e._tTime = Pt._time, n = Pt._first; n; )
      r = n._next, (t || !(!n._dur && n instanceof Ut && n.vars.onComplete === n._targets[0])) && fi(e, n, n._start - n._delay), n = r;
    return fi(Pt, e, 0), e;
  },
  context: function(i, t) {
    return i ? new Mg(i, t) : At;
  },
  matchMedia: function(i) {
    return new mw(i);
  },
  matchMediaRefresh: function() {
    return Rn.forEach(function(i) {
      var t = i.conditions, e, n;
      for (n in t)
        t[n] && (t[n] = !1, e = 1);
      e && i.revert();
    }) || Uh();
  },
  addEventListener: function(i, t) {
    var e = jo[i] || (jo[i] = []);
    ~e.indexOf(t) || e.push(t);
  },
  removeEventListener: function(i, t) {
    var e = jo[i], n = e && e.indexOf(t);
    n >= 0 && e.splice(n, 1);
  },
  utils: {
    wrap: Y1,
    wrapYoyo: X1,
    distribute: ug,
    random: pg,
    snap: dg,
    normalize: q1,
    getUnit: fe,
    clamp: j1,
    splitColor: vg,
    toArray: $e,
    selector: Fh,
    mapRange: mg,
    pipe: H1,
    unitize: W1,
    interpolate: K1,
    shuffle: cg
  },
  install: Zm,
  effects: Gl,
  ticker: He,
  updateRoot: Se.updateRoot,
  plugins: Ge,
  globalTimeline: Pt,
  core: {
    PropTween: Me,
    globals: $m,
    Tween: Ut,
    Timeline: Se,
    Animation: Fs,
    getCache: Cn,
    _removeLinkedListItem: Va,
    reverting: function() {
      return ye;
    },
    context: function(i) {
      return i && At && (At.data.push(i), i._ctx = At), At;
    },
    suppressOverwrites: function(i) {
      return Sc = i;
    }
  }
};
ke("to,from,fromTo,delayedCall,set,killTweensOf", function(i) {
  return na[i] = Ut[i];
});
He.add(Se.updateRoot);
or = na.to({}, {
  duration: 0
});
var gw = function(i, t) {
  for (var e = i._pt; e && e.p !== t && e.op !== t && e.fp !== t; )
    e = e._next;
  return e;
}, yw = function(i, t) {
  var e = i._targets, n, r, s;
  for (n in t)
    for (r = e.length; r--; )
      s = i._ptLookup[r][n], s && (s = s.d) && (s._pt && (s = gw(s, n)), s && s.modifier && s.modifier(t[n], i, e[r], n));
}, Xl = function(i, t) {
  return {
    name: i,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function(e, n, r) {
      r._onInit = function(s) {
        var o, a;
        if (ee(n) && (o = {}, ke(n, function(l) {
          return o[l] = 1;
        }), n = o), t) {
          o = {};
          for (a in n)
            o[a] = t(n[a]);
          n = o;
        }
        yw(s, n);
      };
    }
  };
}, De = na.registerPlugin({
  name: "attr",
  init: function(i, t, e, n, r) {
    var s, o, a;
    this.tween = e;
    for (s in t)
      a = i.getAttribute(s) || "", o = this.add(i, "setAttribute", (a || 0) + "", t[s], n, r, 0, 0, s), o.op = s, o.b = a, this._props.push(s);
  },
  render: function(i, t) {
    for (var e = t._pt; e; )
      ye ? e.set(e.t, e.p, e.b, e) : e.r(i, e.d), e = e._next;
  }
}, {
  name: "endArray",
  init: function(i, t) {
    for (var e = t.length; e--; )
      this.add(i, e, i[e] || 0, t[e], 0, 0, 0, 0, 0, 1);
  }
}, Xl("roundProps", Lh), Xl("modifiers"), Xl("snap", dg)) || na;
Ut.version = Se.version = De.version = "3.12.5";
Jm = 1;
Ec() && Ar();
st.Power0;
st.Power1;
st.Power2;
st.Power3;
st.Power4;
st.Linear;
st.Quad;
st.Cubic;
st.Quart;
st.Quint;
st.Strong;
st.Elastic;
st.Back;
st.SteppedEase;
st.Bounce;
st.Sine;
st.Expo;
st.Circ;
/*!
 * CSSPlugin 3.12.5
 * https://gsap.com
 *
 * Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var mp, Wi, dr, Fc, Sn, gp, Lc, vw = function() {
  return typeof window < "u";
}, Vi = {}, vn = 180 / Math.PI, pr = Math.PI / 180, $n = Math.atan2, yp = 1e8, Nc = /([A-Z])/g, _w = /(left|right|width|margin|padding|x)/i, xw = /[\s,\(]\S/, gi = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
}, zh = function(i, t) {
  return t.set(t.t, t.p, Math.round((t.s + t.c * i) * 1e4) / 1e4 + t.u, t);
}, bw = function(i, t) {
  return t.set(t.t, t.p, i === 1 ? t.e : Math.round((t.s + t.c * i) * 1e4) / 1e4 + t.u, t);
}, ww = function(i, t) {
  return t.set(t.t, t.p, i ? Math.round((t.s + t.c * i) * 1e4) / 1e4 + t.u : t.b, t);
}, Aw = function(i, t) {
  var e = t.s + t.c * i;
  t.set(t.t, t.p, ~~(e + (e < 0 ? -0.5 : 0.5)) + t.u, t);
}, Og = function(i, t) {
  return t.set(t.t, t.p, i ? t.e : t.b, t);
}, Dg = function(i, t) {
  return t.set(t.t, t.p, i !== 1 ? t.b : t.e, t);
}, Sw = function(i, t, e) {
  return i.style[t] = e;
}, Tw = function(i, t, e) {
  return i.style.setProperty(t, e);
}, Ew = function(i, t, e) {
  return i._gsap[t] = e;
}, Cw = function(i, t, e) {
  return i._gsap.scaleX = i._gsap.scaleY = e;
}, Pw = function(i, t, e, n, r) {
  var s = i._gsap;
  s.scaleX = s.scaleY = e, s.renderTransform(r, s);
}, Iw = function(i, t, e, n, r) {
  var s = i._gsap;
  s[t] = e, s.renderTransform(r, s);
}, kt = "transform", Oe = kt + "Origin", Rw = function i(t, e) {
  var n = this, r = this.target, s = r.style, o = r._gsap;
  if (t in Vi && s) {
    if (this.tfm = this.tfm || {}, t !== "transform")
      t = gi[t] || t, ~t.indexOf(",") ? t.split(",").forEach(function(a) {
        return n.tfm[a] = Pi(r, a);
      }) : this.tfm[t] = o.x ? o[t] : Pi(r, t), t === Oe && (this.tfm.zOrigin = o.zOrigin);
    else
      return gi.transform.split(",").forEach(function(a) {
        return i.call(n, a, e);
      });
    if (this.props.indexOf(kt) >= 0)
      return;
    o.svg && (this.svgo = r.getAttribute("data-svg-origin"), this.props.push(Oe, e, "")), t = kt;
  }
  (s || e) && this.props.push(t, e, s[t]);
}, Bg = function(i) {
  i.translate && (i.removeProperty("translate"), i.removeProperty("scale"), i.removeProperty("rotate"));
}, kw = function() {
  var i = this.props, t = this.target, e = t.style, n = t._gsap, r, s;
  for (r = 0; r < i.length; r += 3)
    i[r + 1] ? t[i[r]] = i[r + 2] : i[r + 2] ? e[i[r]] = i[r + 2] : e.removeProperty(i[r].substr(0, 2) === "--" ? i[r] : i[r].replace(Nc, "-$1").toLowerCase());
  if (this.tfm) {
    for (s in this.tfm)
      n[s] = this.tfm[s];
    n.svg && (n.renderTransform(), t.setAttribute("data-svg-origin", this.svgo || "")), r = Lc(), (!r || !r.isStart) && !e[kt] && (Bg(e), n.zOrigin && e[Oe] && (e[Oe] += " " + n.zOrigin + "px", n.zOrigin = 0, n.renderTransform()), n.uncache = 1);
  }
}, Vg = function(i, t) {
  var e = {
    target: i,
    props: [],
    revert: kw,
    save: Rw
  };
  return i._gsap || De.core.getCache(i), t && t.split(",").forEach(function(n) {
    return e.save(n);
  }), e;
}, Fg, jh = function(i, t) {
  var e = Wi.createElementNS ? Wi.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), i) : Wi.createElement(i);
  return e && e.style ? e : Wi.createElement(i);
}, yi = function i(t, e, n) {
  var r = getComputedStyle(t);
  return r[e] || r.getPropertyValue(e.replace(Nc, "-$1").toLowerCase()) || r.getPropertyValue(e) || !n && i(t, Sr(e) || e, 1) || "";
}, vp = "O,Moz,ms,Ms,Webkit".split(","), Sr = function(i, t, e) {
  var n = t || Sn, r = n.style, s = 5;
  if (i in r && !e)
    return i;
  for (i = i.charAt(0).toUpperCase() + i.substr(1); s-- && !(vp[s] + i in r); )
    ;
  return s < 0 ? null : (s === 3 ? "ms" : s >= 0 ? vp[s] : "") + i;
}, Gh = function() {
  vw() && window.document && (mp = window, Wi = mp.document, dr = Wi.documentElement, Sn = jh("div") || {
    style: {}
  }, jh("div"), kt = Sr(kt), Oe = kt + "Origin", Sn.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Fg = !!Sr("perspective"), Lc = De.core.reverting, Fc = 1);
}, Kl = function i(t) {
  var e = jh("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), n = this.parentNode, r = this.nextSibling, s = this.style.cssText, o;
  if (dr.appendChild(e), e.appendChild(this), this.style.display = "block", t)
    try {
      o = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = i;
    } catch {
    }
  else this._gsapBBox && (o = this._gsapBBox());
  return n && (r ? n.insertBefore(this, r) : n.appendChild(this)), dr.removeChild(e), this.style.cssText = s, o;
}, _p = function(i, t) {
  for (var e = t.length; e--; )
    if (i.hasAttribute(t[e]))
      return i.getAttribute(t[e]);
}, Lg = function(i) {
  var t;
  try {
    t = i.getBBox();
  } catch {
    t = Kl.call(i, !0);
  }
  return t && (t.width || t.height) || i.getBBox === Kl || (t = Kl.call(i, !0)), t && !t.width && !t.x && !t.y ? {
    x: +_p(i, ["x", "cx", "x1"]) || 0,
    y: +_p(i, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : t;
}, Ng = function(i) {
  return !!(i.getCTM && (!i.parentNode || i.ownerSVGElement) && Lg(i));
}, Vn = function(i, t) {
  if (t) {
    var e = i.style, n;
    t in Vi && t !== Oe && (t = kt), e.removeProperty ? (n = t.substr(0, 2), (n === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t), e.removeProperty(n === "--" ? t : t.replace(Nc, "-$1").toLowerCase())) : e.removeAttribute(t);
  }
}, qi = function(i, t, e, n, r, s) {
  var o = new Me(i._pt, t, e, 0, 1, s ? Dg : Og);
  return i._pt = o, o.b = n, o.e = r, i._props.push(e), o;
}, xp = {
  deg: 1,
  rad: 1,
  turn: 1
}, Mw = {
  grid: 1,
  flex: 1
}, $i = function i(t, e, n, r) {
  var s = parseFloat(n) || 0, o = (n + "").trim().substr((s + "").length) || "px", a = Sn.style, l = _w.test(e), h = t.tagName.toLowerCase() === "svg", c = (h ? "client" : "offset") + (l ? "Width" : "Height"), p = 100, f = r === "px", d = r === "%", m, g, y, b;
  if (r === o || !s || xp[r] || xp[o])
    return s;
  if (o !== "px" && !f && (s = i(t, e, n, "px")), b = t.getCTM && Ng(t), (d || o === "%") && (Vi[e] || ~e.indexOf("adius")))
    return m = b ? t.getBBox()[l ? "width" : "height"] : t[c], Ft(d ? s / m * p : s / 100 * m);
  if (a[l ? "width" : "height"] = p + (f ? o : r), g = ~e.indexOf("adius") || r === "em" && t.appendChild && !h ? t : t.parentNode, b && (g = (t.ownerSVGElement || {}).parentNode), (!g || g === Wi || !g.appendChild) && (g = Wi.body), y = g._gsap, y && d && y.width && l && y.time === He.time && !y.uncache)
    return Ft(s / y.width * p);
  if (d && (e === "height" || e === "width")) {
    var S = t.style[e];
    t.style[e] = p + r, m = t[c], S ? t.style[e] = S : Vn(t, e);
  } else
    (d || o === "%") && !Mw[yi(g, "display")] && (a.position = yi(t, "position")), g === t && (a.position = "static"), g.appendChild(Sn), m = Sn[c], g.removeChild(Sn), a.position = "absolute";
  return l && d && (y = Cn(g), y.time = He.time, y.width = g[c]), Ft(f ? m * s / p : m && s ? p / m * s : 0);
}, Pi = function(i, t, e, n) {
  var r;
  return Fc || Gh(), t in gi && t !== "transform" && (t = gi[t], ~t.indexOf(",") && (t = t.split(",")[0])), Vi[t] && t !== "transform" ? (r = Ns(i, n), r = t !== "transformOrigin" ? r[t] : r.svg ? r.origin : sa(yi(i, Oe)) + " " + r.zOrigin + "px") : (r = i.style[t], (!r || r === "auto" || n || ~(r + "").indexOf("calc(")) && (r = ra[t] && ra[t](i, t, e) || yi(i, t) || eg(i, t) || (t === "opacity" ? 1 : 0))), e && !~(r + "").trim().indexOf(" ") ? $i(i, t, r, e) + e : r;
}, Ow = function(i, t, e, n) {
  if (!e || e === "none") {
    var r = Sr(t, i, 1), s = r && yi(i, r, 1);
    s && s !== e ? (t = r, e = s) : t === "borderColor" && (e = yi(i, "borderTopColor"));
  }
  var o = new Me(this._pt, i.style, t, 0, 1, Rg), a = 0, l = 0, h, c, p, f, d, m, g, y, b, S, C, I;
  if (o.b = e, o.e = n, e += "", n += "", n === "auto" && (m = i.style[t], i.style[t] = n, n = yi(i, t) || n, m ? i.style[t] = m : Vn(i, t)), h = [e, n], xg(h), e = h[0], n = h[1], p = e.match(sr) || [], I = n.match(sr) || [], I.length) {
    for (; c = sr.exec(n); )
      g = c[0], b = n.substring(a, c.index), d ? d = (d + 1) % 5 : (b.substr(-5) === "rgba(" || b.substr(-5) === "hsla(") && (d = 1), g !== (m = p[l++] || "") && (f = parseFloat(m) || 0, C = m.substr((f + "").length), g.charAt(1) === "=" && (g = ur(f, g) + C), y = parseFloat(g), S = g.substr((y + "").length), a = sr.lastIndex - S.length, S || (S = S || qe.units[t] || C, a === n.length && (n += S, o.e += S)), C !== S && (f = $i(i, t, m, S) || 0), o._pt = {
        _next: o._pt,
        p: b || l === 1 ? b : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: f,
        c: y - f,
        m: d && d < 4 || t === "zIndex" ? Math.round : 0
      });
    o.c = a < n.length ? n.substring(a, n.length) : "";
  } else
    o.r = t === "display" && n === "none" ? Dg : Og;
  return Km.test(n) && (o.e = 0), this._pt = o, o;
}, bp = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
}, Dw = function(i) {
  var t = i.split(" "), e = t[0], n = t[1] || "50%";
  return (e === "top" || e === "bottom" || n === "left" || n === "right") && (i = e, e = n, n = i), t[0] = bp[e] || e, t[1] = bp[n] || n, t.join(" ");
}, Bw = function(i, t) {
  if (t.tween && t.tween._time === t.tween._dur) {
    var e = t.t, n = e.style, r = t.u, s = e._gsap, o, a, l;
    if (r === "all" || r === !0)
      n.cssText = "", a = 1;
    else
      for (r = r.split(","), l = r.length; --l > -1; )
        o = r[l], Vi[o] && (a = 1, o = o === "transformOrigin" ? Oe : kt), Vn(e, o);
    a && (Vn(e, kt), s && (s.svg && e.removeAttribute("transform"), Ns(e, 1), s.uncache = 1, Bg(n)));
  }
}, ra = {
  clearProps: function(i, t, e, n, r) {
    if (r.data !== "isFromStart") {
      var s = i._pt = new Me(i._pt, t, e, 0, 0, Bw);
      return s.u = n, s.pr = -10, s.tween = r, i._props.push(e), 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */
}, Ls = [1, 0, 0, 1, 0, 0], Ug = {}, zg = function(i) {
  return i === "matrix(1, 0, 0, 1, 0, 0)" || i === "none" || !i;
}, wp = function(i) {
  var t = yi(i, kt);
  return zg(t) ? Ls : t.substr(7).match(Xm).map(Ft);
}, Uc = function(i, t) {
  var e = i._gsap || Cn(i), n = i.style, r = wp(i), s, o, a, l;
  return e.svg && i.getAttribute("transform") ? (a = i.transform.baseVal.consolidate().matrix, r = [a.a, a.b, a.c, a.d, a.e, a.f], r.join(",") === "1,0,0,1,0,0" ? Ls : r) : (r === Ls && !i.offsetParent && i !== dr && !e.svg && (a = n.display, n.display = "block", s = i.parentNode, (!s || !i.offsetParent) && (l = 1, o = i.nextElementSibling, dr.appendChild(i)), r = wp(i), a ? n.display = a : Vn(i, "display"), l && (o ? s.insertBefore(i, o) : s ? s.appendChild(i) : dr.removeChild(i))), t && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r);
}, Hh = function(i, t, e, n, r, s) {
  var o = i._gsap, a = r || Uc(i, !0), l = o.xOrigin || 0, h = o.yOrigin || 0, c = o.xOffset || 0, p = o.yOffset || 0, f = a[0], d = a[1], m = a[2], g = a[3], y = a[4], b = a[5], S = t.split(" "), C = parseFloat(S[0]) || 0, I = parseFloat(S[1]) || 0, T, R, w, v;
  e ? a !== Ls && (R = f * g - d * m) && (w = C * (g / R) + I * (-m / R) + (m * b - g * y) / R, v = C * (-d / R) + I * (f / R) - (f * b - d * y) / R, C = w, I = v) : (T = Lg(i), C = T.x + (~S[0].indexOf("%") ? C / 100 * T.width : C), I = T.y + (~(S[1] || S[0]).indexOf("%") ? I / 100 * T.height : I)), n || n !== !1 && o.smooth ? (y = C - l, b = I - h, o.xOffset = c + (y * f + b * m) - y, o.yOffset = p + (y * d + b * g) - b) : o.xOffset = o.yOffset = 0, o.xOrigin = C, o.yOrigin = I, o.smooth = !!n, o.origin = t, o.originIsAbsolute = !!e, i.style[Oe] = "0px 0px", s && (qi(s, o, "xOrigin", l, C), qi(s, o, "yOrigin", h, I), qi(s, o, "xOffset", c, o.xOffset), qi(s, o, "yOffset", p, o.yOffset)), i.setAttribute("data-svg-origin", C + " " + I);
}, Ns = function(i, t) {
  var e = i._gsap || new Sg(i);
  if ("x" in e && !t && !e.uncache)
    return e;
  var n = i.style, r = e.scaleX < 0, s = "px", o = "deg", a = getComputedStyle(i), l = yi(i, Oe) || "0", h, c, p, f, d, m, g, y, b, S, C, I, T, R, w, v, x, A, P, M, k, B, V, N, U, K, j, H, pt, Q, J, bt;
  return h = c = p = m = g = y = b = S = C = 0, f = d = 1, e.svg = !!(i.getCTM && Ng(i)), a.translate && ((a.translate !== "none" || a.scale !== "none" || a.rotate !== "none") && (n[kt] = (a.translate !== "none" ? "translate3d(" + (a.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (a.rotate !== "none" ? "rotate(" + a.rotate + ") " : "") + (a.scale !== "none" ? "scale(" + a.scale.split(" ").join(",") + ") " : "") + (a[kt] !== "none" ? a[kt] : "")), n.scale = n.rotate = n.translate = "none"), R = Uc(i, e.svg), e.svg && (e.uncache ? (U = i.getBBox(), l = e.xOrigin - U.x + "px " + (e.yOrigin - U.y) + "px", N = "") : N = !t && i.getAttribute("data-svg-origin"), Hh(i, N || l, !!N || e.originIsAbsolute, e.smooth !== !1, R)), I = e.xOrigin || 0, T = e.yOrigin || 0, R !== Ls && (A = R[0], P = R[1], M = R[2], k = R[3], h = B = R[4], c = V = R[5], R.length === 6 ? (f = Math.sqrt(A * A + P * P), d = Math.sqrt(k * k + M * M), m = A || P ? $n(P, A) * vn : 0, b = M || k ? $n(M, k) * vn + m : 0, b && (d *= Math.abs(Math.cos(b * pr))), e.svg && (h -= I - (I * A + T * M), c -= T - (I * P + T * k))) : (bt = R[6], Q = R[7], j = R[8], H = R[9], pt = R[10], J = R[11], h = R[12], c = R[13], p = R[14], w = $n(bt, pt), g = w * vn, w && (v = Math.cos(-w), x = Math.sin(-w), N = B * v + j * x, U = V * v + H * x, K = bt * v + pt * x, j = B * -x + j * v, H = V * -x + H * v, pt = bt * -x + pt * v, J = Q * -x + J * v, B = N, V = U, bt = K), w = $n(-M, pt), y = w * vn, w && (v = Math.cos(-w), x = Math.sin(-w), N = A * v - j * x, U = P * v - H * x, K = M * v - pt * x, J = k * x + J * v, A = N, P = U, M = K), w = $n(P, A), m = w * vn, w && (v = Math.cos(w), x = Math.sin(w), N = A * v + P * x, U = B * v + V * x, P = P * v - A * x, V = V * v - B * x, A = N, B = U), g && Math.abs(g) + Math.abs(m) > 359.9 && (g = m = 0, y = 180 - y), f = Ft(Math.sqrt(A * A + P * P + M * M)), d = Ft(Math.sqrt(V * V + bt * bt)), w = $n(B, V), b = Math.abs(w) > 2e-4 ? w * vn : 0, C = J ? 1 / (J < 0 ? -J : J) : 0), e.svg && (N = i.getAttribute("transform"), e.forceCSS = i.setAttribute("transform", "") || !zg(yi(i, kt)), N && i.setAttribute("transform", N))), Math.abs(b) > 90 && Math.abs(b) < 270 && (r ? (f *= -1, b += m <= 0 ? 180 : -180, m += m <= 0 ? 180 : -180) : (d *= -1, b += b <= 0 ? 180 : -180)), t = t || e.uncache, e.x = h - ((e.xPercent = h && (!t && e.xPercent || (Math.round(i.offsetWidth / 2) === Math.round(-h) ? -50 : 0))) ? i.offsetWidth * e.xPercent / 100 : 0) + s, e.y = c - ((e.yPercent = c && (!t && e.yPercent || (Math.round(i.offsetHeight / 2) === Math.round(-c) ? -50 : 0))) ? i.offsetHeight * e.yPercent / 100 : 0) + s, e.z = p + s, e.scaleX = Ft(f), e.scaleY = Ft(d), e.rotation = Ft(m) + o, e.rotationX = Ft(g) + o, e.rotationY = Ft(y) + o, e.skewX = b + o, e.skewY = S + o, e.transformPerspective = C + s, (e.zOrigin = parseFloat(l.split(" ")[2]) || !t && e.zOrigin || 0) && (n[Oe] = sa(l)), e.xOffset = e.yOffset = 0, e.force3D = qe.force3D, e.renderTransform = e.svg ? Fw : Fg ? jg : Vw, e.uncache = 0, e;
}, sa = function(i) {
  return (i = i.split(" "))[0] + " " + i[1];
}, Ql = function(i, t, e) {
  var n = fe(t);
  return Ft(parseFloat(t) + parseFloat($i(i, "x", e + "px", n))) + n;
}, Vw = function(i, t) {
  t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, jg(i, t);
}, dn = "0deg", rs = "0px", pn = ") ", jg = function(i, t) {
  var e = t || this, n = e.xPercent, r = e.yPercent, s = e.x, o = e.y, a = e.z, l = e.rotation, h = e.rotationY, c = e.rotationX, p = e.skewX, f = e.skewY, d = e.scaleX, m = e.scaleY, g = e.transformPerspective, y = e.force3D, b = e.target, S = e.zOrigin, C = "", I = y === "auto" && i && i !== 1 || y === !0;
  if (S && (c !== dn || h !== dn)) {
    var T = parseFloat(h) * pr, R = Math.sin(T), w = Math.cos(T), v;
    T = parseFloat(c) * pr, v = Math.cos(T), s = Ql(b, s, R * v * -S), o = Ql(b, o, -Math.sin(T) * -S), a = Ql(b, a, w * v * -S + S);
  }
  g !== rs && (C += "perspective(" + g + pn), (n || r) && (C += "translate(" + n + "%, " + r + "%) "), (I || s !== rs || o !== rs || a !== rs) && (C += a !== rs || I ? "translate3d(" + s + ", " + o + ", " + a + ") " : "translate(" + s + ", " + o + pn), l !== dn && (C += "rotate(" + l + pn), h !== dn && (C += "rotateY(" + h + pn), c !== dn && (C += "rotateX(" + c + pn), (p !== dn || f !== dn) && (C += "skew(" + p + ", " + f + pn), (d !== 1 || m !== 1) && (C += "scale(" + d + ", " + m + pn), b.style[kt] = C || "translate(0, 0)";
}, Fw = function(i, t) {
  var e = t || this, n = e.xPercent, r = e.yPercent, s = e.x, o = e.y, a = e.rotation, l = e.skewX, h = e.skewY, c = e.scaleX, p = e.scaleY, f = e.target, d = e.xOrigin, m = e.yOrigin, g = e.xOffset, y = e.yOffset, b = e.forceCSS, S = parseFloat(s), C = parseFloat(o), I, T, R, w, v;
  a = parseFloat(a), l = parseFloat(l), h = parseFloat(h), h && (h = parseFloat(h), l += h, a += h), a || l ? (a *= pr, l *= pr, I = Math.cos(a) * c, T = Math.sin(a) * c, R = Math.sin(a - l) * -p, w = Math.cos(a - l) * p, l && (h *= pr, v = Math.tan(l - h), v = Math.sqrt(1 + v * v), R *= v, w *= v, h && (v = Math.tan(h), v = Math.sqrt(1 + v * v), I *= v, T *= v)), I = Ft(I), T = Ft(T), R = Ft(R), w = Ft(w)) : (I = c, w = p, T = R = 0), (S && !~(s + "").indexOf("px") || C && !~(o + "").indexOf("px")) && (S = $i(f, "x", s, "px"), C = $i(f, "y", o, "px")), (d || m || g || y) && (S = Ft(S + d - (d * I + m * R) + g), C = Ft(C + m - (d * T + m * w) + y)), (n || r) && (v = f.getBBox(), S = Ft(S + n / 100 * v.width), C = Ft(C + r / 100 * v.height)), v = "matrix(" + I + "," + T + "," + R + "," + w + "," + S + "," + C + ")", f.setAttribute("transform", v), b && (f.style[kt] = v);
}, Lw = function(i, t, e, n, r) {
  var s = 360, o = ee(r), a = parseFloat(r) * (o && ~r.indexOf("rad") ? vn : 1), l = a - n, h = n + l + "deg", c, p;
  return o && (c = r.split("_")[1], c === "short" && (l %= s, l !== l % (s / 2) && (l += l < 0 ? s : -s)), c === "cw" && l < 0 ? l = (l + s * yp) % s - ~~(l / s) * s : c === "ccw" && l > 0 && (l = (l - s * yp) % s - ~~(l / s) * s)), i._pt = p = new Me(i._pt, t, e, n, l, bw), p.e = h, p.u = "deg", i._props.push(e), p;
}, Ap = function(i, t) {
  for (var e in t)
    i[e] = t[e];
  return i;
}, Nw = function(i, t, e) {
  var n = Ap({}, e._gsap), r = "perspective,force3D,transformOrigin,svgOrigin", s = e.style, o, a, l, h, c, p, f, d;
  n.svg ? (l = e.getAttribute("transform"), e.setAttribute("transform", ""), s[kt] = t, o = Ns(e, 1), Vn(e, kt), e.setAttribute("transform", l)) : (l = getComputedStyle(e)[kt], s[kt] = t, o = Ns(e, 1), s[kt] = l);
  for (a in Vi)
    l = n[a], h = o[a], l !== h && r.indexOf(a) < 0 && (f = fe(l), d = fe(h), c = f !== d ? $i(e, a, l, d) : parseFloat(l), p = parseFloat(h), i._pt = new Me(i._pt, o, a, c, p - c, zh), i._pt.u = d || 0, i._props.push(a));
  Ap(o, n);
};
ke("padding,margin,Width,Radius", function(i, t) {
  var e = "Top", n = "Right", r = "Bottom", s = "Left", o = (t < 3 ? [e, n, r, s] : [e + s, e + n, r + n, r + s]).map(function(a) {
    return t < 2 ? i + a : "border" + a + i;
  });
  ra[t > 1 ? "border" + i : i] = function(a, l, h, c, p) {
    var f, d;
    if (arguments.length < 4)
      return f = o.map(function(m) {
        return Pi(a, m, h);
      }), d = f.join(" "), d.split(f[0]).length === 5 ? f[0] : d;
    f = (c + "").split(" "), d = {}, o.forEach(function(m, g) {
      return d[m] = f[g] = f[g] || f[(g - 1) / 2 | 0];
    }), a.init(l, d, p);
  };
});
var Gg = {
  name: "css",
  register: Gh,
  targetTest: function(i) {
    return i.style && i.nodeType;
  },
  init: function(i, t, e, n, r) {
    var s = this._props, o = i.style, a = e.vars.startAt, l, h, c, p, f, d, m, g, y, b, S, C, I, T, R, w;
    Fc || Gh(), this.styles = this.styles || Vg(i), w = this.styles.props, this.tween = e;
    for (m in t)
      if (m !== "autoRound" && (h = t[m], !(Ge[m] && Tg(m, t, e, n, i, r)))) {
        if (f = typeof h, d = ra[m], f === "function" && (h = h.call(e, n, i, r), f = typeof h), f === "string" && ~h.indexOf("random(") && (h = Bs(h)), d)
          d(this, i, m, h, e) && (R = 1);
        else if (m.substr(0, 2) === "--")
          l = (getComputedStyle(i).getPropertyValue(m) + "").trim(), h += "", Xi.lastIndex = 0, Xi.test(l) || (g = fe(l), y = fe(h)), y ? g !== y && (l = $i(i, m, l, y) + y) : g && (h += g), this.add(o, "setProperty", l, h, n, r, 0, 0, m), s.push(m), w.push(m, 0, o[m]);
        else if (f !== "undefined") {
          if (a && m in a ? (l = typeof a[m] == "function" ? a[m].call(e, n, i, r) : a[m], ee(l) && ~l.indexOf("random(") && (l = Bs(l)), fe(l + "") || l === "auto" || (l += qe.units[m] || fe(Pi(i, m)) || ""), (l + "").charAt(1) === "=" && (l = Pi(i, m))) : l = Pi(i, m), p = parseFloat(l), b = f === "string" && h.charAt(1) === "=" && h.substr(0, 2), b && (h = h.substr(2)), c = parseFloat(h), m in gi && (m === "autoAlpha" && (p === 1 && Pi(i, "visibility") === "hidden" && c && (p = 0), w.push("visibility", 0, o.visibility), qi(this, o, "visibility", p ? "inherit" : "hidden", c ? "inherit" : "hidden", !c)), m !== "scale" && m !== "transform" && (m = gi[m], ~m.indexOf(",") && (m = m.split(",")[0]))), S = m in Vi, S) {
            if (this.styles.save(m), C || (I = i._gsap, I.renderTransform && !t.parseTransform || Ns(i, t.parseTransform), T = t.smoothOrigin !== !1 && I.smooth, C = this._pt = new Me(this._pt, o, kt, 0, 1, I.renderTransform, I, 0, -1), C.dep = 1), m === "scale")
              this._pt = new Me(this._pt, I, "scaleY", I.scaleY, (b ? ur(I.scaleY, b + c) : c) - I.scaleY || 0, zh), this._pt.u = 0, s.push("scaleY", m), m += "X";
            else if (m === "transformOrigin") {
              w.push(Oe, 0, o[Oe]), h = Dw(h), I.svg ? Hh(i, h, 0, T, 0, this) : (y = parseFloat(h.split(" ")[2]) || 0, y !== I.zOrigin && qi(this, I, "zOrigin", I.zOrigin, y), qi(this, o, m, sa(l), sa(h)));
              continue;
            } else if (m === "svgOrigin") {
              Hh(i, h, 1, T, 0, this);
              continue;
            } else if (m in Ug) {
              Lw(this, I, m, p, b ? ur(p, b + h) : h);
              continue;
            } else if (m === "smoothOrigin") {
              qi(this, I, "smooth", I.smooth, h);
              continue;
            } else if (m === "force3D") {
              I[m] = h;
              continue;
            } else if (m === "transform") {
              Nw(this, h, i);
              continue;
            }
          } else m in o || (m = Sr(m) || m);
          if (S || (c || c === 0) && (p || p === 0) && !xw.test(h) && m in o)
            g = (l + "").substr((p + "").length), c || (c = 0), y = fe(h) || (m in qe.units ? qe.units[m] : g), g !== y && (p = $i(i, m, l, y)), this._pt = new Me(this._pt, S ? I : o, m, p, (b ? ur(p, b + c) : c) - p, !S && (y === "px" || m === "zIndex") && t.autoRound !== !1 ? Aw : zh), this._pt.u = y || 0, g !== y && y !== "%" && (this._pt.b = l, this._pt.r = ww);
          else if (m in o)
            Ow.call(this, i, m, l, b ? b + h : h);
          else if (m in i)
            this.add(i, m, l || i[m], b ? b + h : h, n, r);
          else if (m !== "parseTransform") {
            Pc(m, h);
            continue;
          }
          S || (m in o ? w.push(m, 0, o[m]) : w.push(m, 1, l || i[m])), s.push(m);
        }
      }
    R && kg(this);
  },
  render: function(i, t) {
    if (t.tween._time || !Lc())
      for (var e = t._pt; e; )
        e.r(i, e.d), e = e._next;
    else
      t.styles.revert();
  },
  get: Pi,
  aliases: gi,
  getSetter: function(i, t, e) {
    var n = gi[t];
    return n && n.indexOf(",") < 0 && (t = n), t in Vi && t !== Oe && (i._gsap.x || Pi(i, "x")) ? e && gp === e ? t === "scale" ? Cw : Ew : (gp = e || {}) && (t === "scale" ? Pw : Iw) : i.style && !Tc(i.style[t]) ? Sw : ~t.indexOf("-") ? Tw : Bc(i, t);
  },
  core: {
    _removeProperty: Vn,
    _getMatrix: Uc
  }
};
De.utils.checkPrefix = Sr;
De.core.getStyleSaver = Vg;
(function(i, t, e, n) {
  var r = ke(i + "," + t + "," + e, function(s) {
    Vi[s] = 1;
  });
  ke(t, function(s) {
    qe.units[s] = "deg", Ug[s] = 1;
  }), gi[r[13]] = i + "," + t, ke(n, function(s) {
    var o = s.split(":");
    gi[o[1]] = r[o[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
ke("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(i) {
  qe.units[i] = "px";
});
De.registerPlugin(Gg);
var ds = De.registerPlugin(Gg) || De;
ds.core.Tween;
class Dr {
  constructor(t) {
    Ae(this, "_options"), Ae(this, "_tween", null), this._options = t;
  }
  get options() {
    return this._options;
  }
  get name() {
    return this._options.name;
  }
  start(t) {
    return new Promise((e) => {
      this._tween = ds.fromTo(t, this.options.from, {
        ...this.options.to,
        onComplete: () => e(),
        duration: this.options.duration,
        repeat: this.options.repeat,
        yoyo: this.options.revert,
        ease: this.options.ease,
        delay: this.options.delay,
        repeatDelay: this.options.repeatDelay
      }), this._tween.play();
    });
  }
  stop() {
    var t;
    (t = this._tween) == null || t.kill();
  }
  pause() {
    var t;
    (t = this._tween) == null || t.pause();
  }
  resume() {
    var t;
    (t = this._tween) == null || t.resume();
  }
  finish() {
    var t;
    (t = this._tween) == null || t.progress(1);
  }
  static initEngine() {
    ds.ticker.remove(ds.updateRoot);
  }
  static updateEngine(t) {
    this._rootTimeMs += t, ds.updateRoot(this._rootTimeMs / 1e3);
  }
}
Ae(Dr, "_rootTimeMs", 0);
var Hg = { exports: {} };
/*!
 * matter-js 0.20.0 by @liabru
 * http://brm.io/matter-js/
 * License MIT
 * 
 * The MIT License (MIT)
 * 
 * Copyright (c) Liam Brummitt and contributors.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
(function(i, t) {
  (function(e, n) {
    i.exports = n();
  })(xn, function() {
    return (
      /******/
      function(e) {
        var n = {};
        function r(s) {
          if (n[s])
            return n[s].exports;
          var o = n[s] = {
            /******/
            i: s,
            /******/
            l: !1,
            /******/
            exports: {}
            /******/
          };
          return e[s].call(o.exports, o, o.exports, r), o.l = !0, o.exports;
        }
        return r.m = e, r.c = n, r.d = function(s, o, a) {
          r.o(s, o) || Object.defineProperty(s, o, { enumerable: !0, get: a });
        }, r.r = function(s) {
          typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(s, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(s, "__esModule", { value: !0 });
        }, r.t = function(s, o) {
          if (o & 1 && (s = r(s)), o & 8 || o & 4 && typeof s == "object" && s && s.__esModule) return s;
          var a = /* @__PURE__ */ Object.create(null);
          if (r.r(a), Object.defineProperty(a, "default", { enumerable: !0, value: s }), o & 2 && typeof s != "string") for (var l in s) r.d(a, l, (function(h) {
            return s[h];
          }).bind(null, l));
          return a;
        }, r.n = function(s) {
          var o = s && s.__esModule ? (
            /******/
            function() {
              return s.default;
            }
          ) : (
            /******/
            function() {
              return s;
            }
          );
          return r.d(o, "a", o), o;
        }, r.o = function(s, o) {
          return Object.prototype.hasOwnProperty.call(s, o);
        }, r.p = "", r(r.s = 20);
      }([
        /* 0 */
        /***/
        function(e, n) {
          var r = {};
          e.exports = r, function() {
            r._baseDelta = 1e3 / 60, r._nextId = 0, r._seed = 0, r._nowStartTime = +/* @__PURE__ */ new Date(), r._warnedOnce = {}, r._decomp = null, r.extend = function(o, a) {
              var l, h;
              typeof a == "boolean" ? (l = 2, h = a) : (l = 1, h = !0);
              for (var c = l; c < arguments.length; c++) {
                var p = arguments[c];
                if (p)
                  for (var f in p)
                    h && p[f] && p[f].constructor === Object && (!o[f] || o[f].constructor === Object) ? (o[f] = o[f] || {}, r.extend(o[f], h, p[f])) : o[f] = p[f];
              }
              return o;
            }, r.clone = function(o, a) {
              return r.extend({}, a, o);
            }, r.keys = function(o) {
              if (Object.keys)
                return Object.keys(o);
              var a = [];
              for (var l in o)
                a.push(l);
              return a;
            }, r.values = function(o) {
              var a = [];
              if (Object.keys) {
                for (var l = Object.keys(o), h = 0; h < l.length; h++)
                  a.push(o[l[h]]);
                return a;
              }
              for (var c in o)
                a.push(o[c]);
              return a;
            }, r.get = function(o, a, l, h) {
              a = a.split(".").slice(l, h);
              for (var c = 0; c < a.length; c += 1)
                o = o[a[c]];
              return o;
            }, r.set = function(o, a, l, h, c) {
              var p = a.split(".").slice(h, c);
              return r.get(o, a, 0, -1)[p[p.length - 1]] = l, l;
            }, r.shuffle = function(o) {
              for (var a = o.length - 1; a > 0; a--) {
                var l = Math.floor(r.random() * (a + 1)), h = o[a];
                o[a] = o[l], o[l] = h;
              }
              return o;
            }, r.choose = function(o) {
              return o[Math.floor(r.random() * o.length)];
            }, r.isElement = function(o) {
              return typeof HTMLElement < "u" ? o instanceof HTMLElement : !!(o && o.nodeType && o.nodeName);
            }, r.isArray = function(o) {
              return Object.prototype.toString.call(o) === "[object Array]";
            }, r.isFunction = function(o) {
              return typeof o == "function";
            }, r.isPlainObject = function(o) {
              return typeof o == "object" && o.constructor === Object;
            }, r.isString = function(o) {
              return toString.call(o) === "[object String]";
            }, r.clamp = function(o, a, l) {
              return o < a ? a : o > l ? l : o;
            }, r.sign = function(o) {
              return o < 0 ? -1 : 1;
            }, r.now = function() {
              if (typeof window < "u" && window.performance) {
                if (window.performance.now)
                  return window.performance.now();
                if (window.performance.webkitNow)
                  return window.performance.webkitNow();
              }
              return Date.now ? Date.now() : /* @__PURE__ */ new Date() - r._nowStartTime;
            }, r.random = function(o, a) {
              return o = typeof o < "u" ? o : 0, a = typeof a < "u" ? a : 1, o + s() * (a - o);
            };
            var s = function() {
              return r._seed = (r._seed * 9301 + 49297) % 233280, r._seed / 233280;
            };
            r.colorToNumber = function(o) {
              return o = o.replace("#", ""), o.length == 3 && (o = o.charAt(0) + o.charAt(0) + o.charAt(1) + o.charAt(1) + o.charAt(2) + o.charAt(2)), parseInt(o, 16);
            }, r.logLevel = 1, r.log = function() {
              console && r.logLevel > 0 && r.logLevel <= 3 && console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
            }, r.info = function() {
              console && r.logLevel > 0 && r.logLevel <= 2 && console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
            }, r.warn = function() {
              console && r.logLevel > 0 && r.logLevel <= 3 && console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
            }, r.warnOnce = function() {
              var o = Array.prototype.slice.call(arguments).join(" ");
              r._warnedOnce[o] || (r.warn(o), r._warnedOnce[o] = !0);
            }, r.deprecated = function(o, a, l) {
              o[a] = r.chain(function() {
                r.warnOnce("🔅 deprecated 🔅", l);
              }, o[a]);
            }, r.nextId = function() {
              return r._nextId++;
            }, r.indexOf = function(o, a) {
              if (o.indexOf)
                return o.indexOf(a);
              for (var l = 0; l < o.length; l++)
                if (o[l] === a)
                  return l;
              return -1;
            }, r.map = function(o, a) {
              if (o.map)
                return o.map(a);
              for (var l = [], h = 0; h < o.length; h += 1)
                l.push(a(o[h]));
              return l;
            }, r.topologicalSort = function(o) {
              var a = [], l = [], h = [];
              for (var c in o)
                !l[c] && !h[c] && r._topologicalSort(c, l, h, o, a);
              return a;
            }, r._topologicalSort = function(o, a, l, h, c) {
              var p = h[o] || [];
              l[o] = !0;
              for (var f = 0; f < p.length; f += 1) {
                var d = p[f];
                l[d] || a[d] || r._topologicalSort(d, a, l, h, c);
              }
              l[o] = !1, a[o] = !0, c.push(o);
            }, r.chain = function() {
              for (var o = [], a = 0; a < arguments.length; a += 1) {
                var l = arguments[a];
                l._chained ? o.push.apply(o, l._chained) : o.push(l);
              }
              var h = function() {
                for (var c, p = new Array(arguments.length), f = 0, d = arguments.length; f < d; f++)
                  p[f] = arguments[f];
                for (f = 0; f < o.length; f += 1) {
                  var m = o[f].apply(c, p);
                  typeof m < "u" && (c = m);
                }
                return c;
              };
              return h._chained = o, h;
            }, r.chainPathBefore = function(o, a, l) {
              return r.set(o, a, r.chain(
                l,
                r.get(o, a)
              ));
            }, r.chainPathAfter = function(o, a, l) {
              return r.set(o, a, r.chain(
                r.get(o, a),
                l
              ));
            }, r.setDecomp = function(o) {
              r._decomp = o;
            }, r.getDecomp = function() {
              var o = r._decomp;
              try {
                !o && typeof window < "u" && (o = window.decomp), !o && typeof xn < "u" && (o = xn.decomp);
              } catch {
                o = null;
              }
              return o;
            };
          }();
        },
        /* 1 */
        /***/
        function(e, n) {
          var r = {};
          e.exports = r, function() {
            r.create = function(s) {
              var o = {
                min: { x: 0, y: 0 },
                max: { x: 0, y: 0 }
              };
              return s && r.update(o, s), o;
            }, r.update = function(s, o, a) {
              s.min.x = 1 / 0, s.max.x = -1 / 0, s.min.y = 1 / 0, s.max.y = -1 / 0;
              for (var l = 0; l < o.length; l++) {
                var h = o[l];
                h.x > s.max.x && (s.max.x = h.x), h.x < s.min.x && (s.min.x = h.x), h.y > s.max.y && (s.max.y = h.y), h.y < s.min.y && (s.min.y = h.y);
              }
              a && (a.x > 0 ? s.max.x += a.x : s.min.x += a.x, a.y > 0 ? s.max.y += a.y : s.min.y += a.y);
            }, r.contains = function(s, o) {
              return o.x >= s.min.x && o.x <= s.max.x && o.y >= s.min.y && o.y <= s.max.y;
            }, r.overlaps = function(s, o) {
              return s.min.x <= o.max.x && s.max.x >= o.min.x && s.max.y >= o.min.y && s.min.y <= o.max.y;
            }, r.translate = function(s, o) {
              s.min.x += o.x, s.max.x += o.x, s.min.y += o.y, s.max.y += o.y;
            }, r.shift = function(s, o) {
              var a = s.max.x - s.min.x, l = s.max.y - s.min.y;
              s.min.x = o.x, s.max.x = o.x + a, s.min.y = o.y, s.max.y = o.y + l;
            };
          }();
        },
        /* 2 */
        /***/
        function(e, n) {
          var r = {};
          e.exports = r, function() {
            r.create = function(s, o) {
              return { x: s || 0, y: o || 0 };
            }, r.clone = function(s) {
              return { x: s.x, y: s.y };
            }, r.magnitude = function(s) {
              return Math.sqrt(s.x * s.x + s.y * s.y);
            }, r.magnitudeSquared = function(s) {
              return s.x * s.x + s.y * s.y;
            }, r.rotate = function(s, o, a) {
              var l = Math.cos(o), h = Math.sin(o);
              a || (a = {});
              var c = s.x * l - s.y * h;
              return a.y = s.x * h + s.y * l, a.x = c, a;
            }, r.rotateAbout = function(s, o, a, l) {
              var h = Math.cos(o), c = Math.sin(o);
              l || (l = {});
              var p = a.x + ((s.x - a.x) * h - (s.y - a.y) * c);
              return l.y = a.y + ((s.x - a.x) * c + (s.y - a.y) * h), l.x = p, l;
            }, r.normalise = function(s) {
              var o = r.magnitude(s);
              return o === 0 ? { x: 0, y: 0 } : { x: s.x / o, y: s.y / o };
            }, r.dot = function(s, o) {
              return s.x * o.x + s.y * o.y;
            }, r.cross = function(s, o) {
              return s.x * o.y - s.y * o.x;
            }, r.cross3 = function(s, o, a) {
              return (o.x - s.x) * (a.y - s.y) - (o.y - s.y) * (a.x - s.x);
            }, r.add = function(s, o, a) {
              return a || (a = {}), a.x = s.x + o.x, a.y = s.y + o.y, a;
            }, r.sub = function(s, o, a) {
              return a || (a = {}), a.x = s.x - o.x, a.y = s.y - o.y, a;
            }, r.mult = function(s, o) {
              return { x: s.x * o, y: s.y * o };
            }, r.div = function(s, o) {
              return { x: s.x / o, y: s.y / o };
            }, r.perp = function(s, o) {
              return o = o === !0 ? -1 : 1, { x: o * -s.y, y: o * s.x };
            }, r.neg = function(s) {
              return { x: -s.x, y: -s.y };
            }, r.angle = function(s, o) {
              return Math.atan2(o.y - s.y, o.x - s.x);
            }, r._temp = [
              r.create(),
              r.create(),
              r.create(),
              r.create(),
              r.create(),
              r.create()
            ];
          }();
        },
        /* 3 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(2), a = r(0);
          (function() {
            s.create = function(l, h) {
              for (var c = [], p = 0; p < l.length; p++) {
                var f = l[p], d = {
                  x: f.x,
                  y: f.y,
                  index: p,
                  body: h,
                  isInternal: !1
                };
                c.push(d);
              }
              return c;
            }, s.fromPath = function(l, h) {
              var c = /L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/ig, p = [];
              return l.replace(c, function(f, d, m) {
                p.push({ x: parseFloat(d), y: parseFloat(m) });
              }), s.create(p, h);
            }, s.centre = function(l) {
              for (var h = s.area(l, !0), c = { x: 0, y: 0 }, p, f, d, m = 0; m < l.length; m++)
                d = (m + 1) % l.length, p = o.cross(l[m], l[d]), f = o.mult(o.add(l[m], l[d]), p), c = o.add(c, f);
              return o.div(c, 6 * h);
            }, s.mean = function(l) {
              for (var h = { x: 0, y: 0 }, c = 0; c < l.length; c++)
                h.x += l[c].x, h.y += l[c].y;
              return o.div(h, l.length);
            }, s.area = function(l, h) {
              for (var c = 0, p = l.length - 1, f = 0; f < l.length; f++)
                c += (l[p].x - l[f].x) * (l[p].y + l[f].y), p = f;
              return h ? c / 2 : Math.abs(c) / 2;
            }, s.inertia = function(l, h) {
              for (var c = 0, p = 0, f = l, d, m, g = 0; g < f.length; g++)
                m = (g + 1) % f.length, d = Math.abs(o.cross(f[m], f[g])), c += d * (o.dot(f[m], f[m]) + o.dot(f[m], f[g]) + o.dot(f[g], f[g])), p += d;
              return h / 6 * (c / p);
            }, s.translate = function(l, h, c) {
              c = typeof c < "u" ? c : 1;
              var p = l.length, f = h.x * c, d = h.y * c, m;
              for (m = 0; m < p; m++)
                l[m].x += f, l[m].y += d;
              return l;
            }, s.rotate = function(l, h, c) {
              if (h !== 0) {
                var p = Math.cos(h), f = Math.sin(h), d = c.x, m = c.y, g = l.length, y, b, S, C;
                for (C = 0; C < g; C++)
                  y = l[C], b = y.x - d, S = y.y - m, y.x = d + (b * p - S * f), y.y = m + (b * f + S * p);
                return l;
              }
            }, s.contains = function(l, h) {
              for (var c = h.x, p = h.y, f = l.length, d = l[f - 1], m, g = 0; g < f; g++) {
                if (m = l[g], (c - d.x) * (m.y - d.y) + (p - d.y) * (d.x - m.x) > 0)
                  return !1;
                d = m;
              }
              return !0;
            }, s.scale = function(l, h, c, p) {
              if (h === 1 && c === 1)
                return l;
              p = p || s.centre(l);
              for (var f, d, m = 0; m < l.length; m++)
                f = l[m], d = o.sub(f, p), l[m].x = p.x + d.x * h, l[m].y = p.y + d.y * c;
              return l;
            }, s.chamfer = function(l, h, c, p, f) {
              typeof h == "number" ? h = [h] : h = h || [8], c = typeof c < "u" ? c : -1, p = p || 2, f = f || 14;
              for (var d = [], m = 0; m < l.length; m++) {
                var g = l[m - 1 >= 0 ? m - 1 : l.length - 1], y = l[m], b = l[(m + 1) % l.length], S = h[m < h.length ? m : h.length - 1];
                if (S === 0) {
                  d.push(y);
                  continue;
                }
                var C = o.normalise({
                  x: y.y - g.y,
                  y: g.x - y.x
                }), I = o.normalise({
                  x: b.y - y.y,
                  y: y.x - b.x
                }), T = Math.sqrt(2 * Math.pow(S, 2)), R = o.mult(a.clone(C), S), w = o.normalise(o.mult(o.add(C, I), 0.5)), v = o.sub(y, o.mult(w, T)), x = c;
                c === -1 && (x = Math.pow(S, 0.32) * 1.75), x = a.clamp(x, p, f), x % 2 === 1 && (x += 1);
                for (var A = Math.acos(o.dot(C, I)), P = A / x, M = 0; M < x; M++)
                  d.push(o.add(o.rotate(R, P * M), v));
              }
              return d;
            }, s.clockwiseSort = function(l) {
              var h = s.mean(l);
              return l.sort(function(c, p) {
                return o.angle(h, c) - o.angle(h, p);
              }), l;
            }, s.isConvex = function(l) {
              var h = 0, c = l.length, p, f, d, m;
              if (c < 3)
                return null;
              for (p = 0; p < c; p++)
                if (f = (p + 1) % c, d = (p + 2) % c, m = (l[f].x - l[p].x) * (l[d].y - l[f].y), m -= (l[f].y - l[p].y) * (l[d].x - l[f].x), m < 0 ? h |= 1 : m > 0 && (h |= 2), h === 3)
                  return !1;
              return h !== 0 ? !0 : null;
            }, s.hull = function(l) {
              var h = [], c = [], p, f;
              for (l = l.slice(0), l.sort(function(d, m) {
                var g = d.x - m.x;
                return g !== 0 ? g : d.y - m.y;
              }), f = 0; f < l.length; f += 1) {
                for (p = l[f]; c.length >= 2 && o.cross3(c[c.length - 2], c[c.length - 1], p) <= 0; )
                  c.pop();
                c.push(p);
              }
              for (f = l.length - 1; f >= 0; f -= 1) {
                for (p = l[f]; h.length >= 2 && o.cross3(h[h.length - 2], h[h.length - 1], p) <= 0; )
                  h.pop();
                h.push(p);
              }
              return h.pop(), c.pop(), h.concat(c);
            };
          })();
        },
        /* 4 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(3), a = r(2), l = r(7), h = r(0), c = r(1), p = r(11);
          (function() {
            s._timeCorrection = !0, s._inertiaScale = 4, s._nextCollidingGroupId = 1, s._nextNonCollidingGroupId = -1, s._nextCategory = 1, s._baseDelta = 1e3 / 60, s.create = function(d) {
              var m = {
                id: h.nextId(),
                type: "body",
                label: "Body",
                parts: [],
                plugin: {},
                angle: 0,
                vertices: o.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"),
                position: { x: 0, y: 0 },
                force: { x: 0, y: 0 },
                torque: 0,
                positionImpulse: { x: 0, y: 0 },
                constraintImpulse: { x: 0, y: 0, angle: 0 },
                totalContacts: 0,
                speed: 0,
                angularSpeed: 0,
                velocity: { x: 0, y: 0 },
                angularVelocity: 0,
                isSensor: !1,
                isStatic: !1,
                isSleeping: !1,
                motion: 0,
                sleepThreshold: 60,
                density: 1e-3,
                restitution: 0,
                friction: 0.1,
                frictionStatic: 0.5,
                frictionAir: 0.01,
                collisionFilter: {
                  category: 1,
                  mask: 4294967295,
                  group: 0
                },
                slop: 0.05,
                timeScale: 1,
                render: {
                  visible: !0,
                  opacity: 1,
                  strokeStyle: null,
                  fillStyle: null,
                  lineWidth: null,
                  sprite: {
                    xScale: 1,
                    yScale: 1,
                    xOffset: 0,
                    yOffset: 0
                  }
                },
                events: null,
                bounds: null,
                chamfer: null,
                circleRadius: 0,
                positionPrev: null,
                anglePrev: 0,
                parent: null,
                axes: null,
                area: 0,
                mass: 0,
                inertia: 0,
                deltaTime: 16.666666666666668,
                _original: null
              }, g = h.extend(m, d);
              return f(g, d), g;
            }, s.nextGroup = function(d) {
              return d ? s._nextNonCollidingGroupId-- : s._nextCollidingGroupId++;
            }, s.nextCategory = function() {
              return s._nextCategory = s._nextCategory << 1, s._nextCategory;
            };
            var f = function(d, m) {
              m = m || {}, s.set(d, {
                bounds: d.bounds || c.create(d.vertices),
                positionPrev: d.positionPrev || a.clone(d.position),
                anglePrev: d.anglePrev || d.angle,
                vertices: d.vertices,
                parts: d.parts || [d],
                isStatic: d.isStatic,
                isSleeping: d.isSleeping,
                parent: d.parent || d
              }), o.rotate(d.vertices, d.angle, d.position), p.rotate(d.axes, d.angle), c.update(d.bounds, d.vertices, d.velocity), s.set(d, {
                axes: m.axes || d.axes,
                area: m.area || d.area,
                mass: m.mass || d.mass,
                inertia: m.inertia || d.inertia
              });
              var g = d.isStatic ? "#14151f" : h.choose(["#f19648", "#f5d259", "#f55a3c", "#063e7b", "#ececd1"]), y = d.isStatic ? "#555" : "#ccc", b = d.isStatic && d.render.fillStyle === null ? 1 : 0;
              d.render.fillStyle = d.render.fillStyle || g, d.render.strokeStyle = d.render.strokeStyle || y, d.render.lineWidth = d.render.lineWidth || b, d.render.sprite.xOffset += -(d.bounds.min.x - d.position.x) / (d.bounds.max.x - d.bounds.min.x), d.render.sprite.yOffset += -(d.bounds.min.y - d.position.y) / (d.bounds.max.y - d.bounds.min.y);
            };
            s.set = function(d, m, g) {
              var y;
              typeof m == "string" && (y = m, m = {}, m[y] = g);
              for (y in m)
                if (Object.prototype.hasOwnProperty.call(m, y))
                  switch (g = m[y], y) {
                    case "isStatic":
                      s.setStatic(d, g);
                      break;
                    case "isSleeping":
                      l.set(d, g);
                      break;
                    case "mass":
                      s.setMass(d, g);
                      break;
                    case "density":
                      s.setDensity(d, g);
                      break;
                    case "inertia":
                      s.setInertia(d, g);
                      break;
                    case "vertices":
                      s.setVertices(d, g);
                      break;
                    case "position":
                      s.setPosition(d, g);
                      break;
                    case "angle":
                      s.setAngle(d, g);
                      break;
                    case "velocity":
                      s.setVelocity(d, g);
                      break;
                    case "angularVelocity":
                      s.setAngularVelocity(d, g);
                      break;
                    case "speed":
                      s.setSpeed(d, g);
                      break;
                    case "angularSpeed":
                      s.setAngularSpeed(d, g);
                      break;
                    case "parts":
                      s.setParts(d, g);
                      break;
                    case "centre":
                      s.setCentre(d, g);
                      break;
                    default:
                      d[y] = g;
                  }
            }, s.setStatic = function(d, m) {
              for (var g = 0; g < d.parts.length; g++) {
                var y = d.parts[g];
                m ? (y.isStatic || (y._original = {
                  restitution: y.restitution,
                  friction: y.friction,
                  mass: y.mass,
                  inertia: y.inertia,
                  density: y.density,
                  inverseMass: y.inverseMass,
                  inverseInertia: y.inverseInertia
                }), y.restitution = 0, y.friction = 1, y.mass = y.inertia = y.density = 1 / 0, y.inverseMass = y.inverseInertia = 0, y.positionPrev.x = y.position.x, y.positionPrev.y = y.position.y, y.anglePrev = y.angle, y.angularVelocity = 0, y.speed = 0, y.angularSpeed = 0, y.motion = 0) : y._original && (y.restitution = y._original.restitution, y.friction = y._original.friction, y.mass = y._original.mass, y.inertia = y._original.inertia, y.density = y._original.density, y.inverseMass = y._original.inverseMass, y.inverseInertia = y._original.inverseInertia, y._original = null), y.isStatic = m;
              }
            }, s.setMass = function(d, m) {
              var g = d.inertia / (d.mass / 6);
              d.inertia = g * (m / 6), d.inverseInertia = 1 / d.inertia, d.mass = m, d.inverseMass = 1 / d.mass, d.density = d.mass / d.area;
            }, s.setDensity = function(d, m) {
              s.setMass(d, m * d.area), d.density = m;
            }, s.setInertia = function(d, m) {
              d.inertia = m, d.inverseInertia = 1 / d.inertia;
            }, s.setVertices = function(d, m) {
              m[0].body === d ? d.vertices = m : d.vertices = o.create(m, d), d.axes = p.fromVertices(d.vertices), d.area = o.area(d.vertices), s.setMass(d, d.density * d.area);
              var g = o.centre(d.vertices);
              o.translate(d.vertices, g, -1), s.setInertia(d, s._inertiaScale * o.inertia(d.vertices, d.mass)), o.translate(d.vertices, d.position), c.update(d.bounds, d.vertices, d.velocity);
            }, s.setParts = function(d, m, g) {
              var y;
              for (m = m.slice(0), d.parts.length = 0, d.parts.push(d), d.parent = d, y = 0; y < m.length; y++) {
                var b = m[y];
                b !== d && (b.parent = d, d.parts.push(b));
              }
              if (d.parts.length !== 1) {
                if (g = typeof g < "u" ? g : !0, g) {
                  var S = [];
                  for (y = 0; y < m.length; y++)
                    S = S.concat(m[y].vertices);
                  o.clockwiseSort(S);
                  var C = o.hull(S), I = o.centre(C);
                  s.setVertices(d, C), o.translate(d.vertices, I);
                }
                var T = s._totalProperties(d);
                d.area = T.area, d.parent = d, d.position.x = T.centre.x, d.position.y = T.centre.y, d.positionPrev.x = T.centre.x, d.positionPrev.y = T.centre.y, s.setMass(d, T.mass), s.setInertia(d, T.inertia), s.setPosition(d, T.centre);
              }
            }, s.setCentre = function(d, m, g) {
              g ? (d.positionPrev.x += m.x, d.positionPrev.y += m.y, d.position.x += m.x, d.position.y += m.y) : (d.positionPrev.x = m.x - (d.position.x - d.positionPrev.x), d.positionPrev.y = m.y - (d.position.y - d.positionPrev.y), d.position.x = m.x, d.position.y = m.y);
            }, s.setPosition = function(d, m, g) {
              var y = a.sub(m, d.position);
              g ? (d.positionPrev.x = d.position.x, d.positionPrev.y = d.position.y, d.velocity.x = y.x, d.velocity.y = y.y, d.speed = a.magnitude(y)) : (d.positionPrev.x += y.x, d.positionPrev.y += y.y);
              for (var b = 0; b < d.parts.length; b++) {
                var S = d.parts[b];
                S.position.x += y.x, S.position.y += y.y, o.translate(S.vertices, y), c.update(S.bounds, S.vertices, d.velocity);
              }
            }, s.setAngle = function(d, m, g) {
              var y = m - d.angle;
              g ? (d.anglePrev = d.angle, d.angularVelocity = y, d.angularSpeed = Math.abs(y)) : d.anglePrev += y;
              for (var b = 0; b < d.parts.length; b++) {
                var S = d.parts[b];
                S.angle += y, o.rotate(S.vertices, y, d.position), p.rotate(S.axes, y), c.update(S.bounds, S.vertices, d.velocity), b > 0 && a.rotateAbout(S.position, y, d.position, S.position);
              }
            }, s.setVelocity = function(d, m) {
              var g = d.deltaTime / s._baseDelta;
              d.positionPrev.x = d.position.x - m.x * g, d.positionPrev.y = d.position.y - m.y * g, d.velocity.x = (d.position.x - d.positionPrev.x) / g, d.velocity.y = (d.position.y - d.positionPrev.y) / g, d.speed = a.magnitude(d.velocity);
            }, s.getVelocity = function(d) {
              var m = s._baseDelta / d.deltaTime;
              return {
                x: (d.position.x - d.positionPrev.x) * m,
                y: (d.position.y - d.positionPrev.y) * m
              };
            }, s.getSpeed = function(d) {
              return a.magnitude(s.getVelocity(d));
            }, s.setSpeed = function(d, m) {
              s.setVelocity(d, a.mult(a.normalise(s.getVelocity(d)), m));
            }, s.setAngularVelocity = function(d, m) {
              var g = d.deltaTime / s._baseDelta;
              d.anglePrev = d.angle - m * g, d.angularVelocity = (d.angle - d.anglePrev) / g, d.angularSpeed = Math.abs(d.angularVelocity);
            }, s.getAngularVelocity = function(d) {
              return (d.angle - d.anglePrev) * s._baseDelta / d.deltaTime;
            }, s.getAngularSpeed = function(d) {
              return Math.abs(s.getAngularVelocity(d));
            }, s.setAngularSpeed = function(d, m) {
              s.setAngularVelocity(d, h.sign(s.getAngularVelocity(d)) * m);
            }, s.translate = function(d, m, g) {
              s.setPosition(d, a.add(d.position, m), g);
            }, s.rotate = function(d, m, g, y) {
              if (!g)
                s.setAngle(d, d.angle + m, y);
              else {
                var b = Math.cos(m), S = Math.sin(m), C = d.position.x - g.x, I = d.position.y - g.y;
                s.setPosition(d, {
                  x: g.x + (C * b - I * S),
                  y: g.y + (C * S + I * b)
                }, y), s.setAngle(d, d.angle + m, y);
              }
            }, s.scale = function(d, m, g, y) {
              var b = 0, S = 0;
              y = y || d.position;
              for (var C = 0; C < d.parts.length; C++) {
                var I = d.parts[C];
                o.scale(I.vertices, m, g, y), I.axes = p.fromVertices(I.vertices), I.area = o.area(I.vertices), s.setMass(I, d.density * I.area), o.translate(I.vertices, { x: -I.position.x, y: -I.position.y }), s.setInertia(I, s._inertiaScale * o.inertia(I.vertices, I.mass)), o.translate(I.vertices, { x: I.position.x, y: I.position.y }), C > 0 && (b += I.area, S += I.inertia), I.position.x = y.x + (I.position.x - y.x) * m, I.position.y = y.y + (I.position.y - y.y) * g, c.update(I.bounds, I.vertices, d.velocity);
              }
              d.parts.length > 1 && (d.area = b, d.isStatic || (s.setMass(d, d.density * b), s.setInertia(d, S))), d.circleRadius && (m === g ? d.circleRadius *= m : d.circleRadius = null);
            }, s.update = function(d, m) {
              m = (typeof m < "u" ? m : 1e3 / 60) * d.timeScale;
              var g = m * m, y = s._timeCorrection ? m / (d.deltaTime || m) : 1, b = 1 - d.frictionAir * (m / h._baseDelta), S = (d.position.x - d.positionPrev.x) * y, C = (d.position.y - d.positionPrev.y) * y;
              d.velocity.x = S * b + d.force.x / d.mass * g, d.velocity.y = C * b + d.force.y / d.mass * g, d.positionPrev.x = d.position.x, d.positionPrev.y = d.position.y, d.position.x += d.velocity.x, d.position.y += d.velocity.y, d.deltaTime = m, d.angularVelocity = (d.angle - d.anglePrev) * b * y + d.torque / d.inertia * g, d.anglePrev = d.angle, d.angle += d.angularVelocity;
              for (var I = 0; I < d.parts.length; I++) {
                var T = d.parts[I];
                o.translate(T.vertices, d.velocity), I > 0 && (T.position.x += d.velocity.x, T.position.y += d.velocity.y), d.angularVelocity !== 0 && (o.rotate(T.vertices, d.angularVelocity, d.position), p.rotate(T.axes, d.angularVelocity), I > 0 && a.rotateAbout(T.position, d.angularVelocity, d.position, T.position)), c.update(T.bounds, T.vertices, d.velocity);
              }
            }, s.updateVelocities = function(d) {
              var m = s._baseDelta / d.deltaTime, g = d.velocity;
              g.x = (d.position.x - d.positionPrev.x) * m, g.y = (d.position.y - d.positionPrev.y) * m, d.speed = Math.sqrt(g.x * g.x + g.y * g.y), d.angularVelocity = (d.angle - d.anglePrev) * m, d.angularSpeed = Math.abs(d.angularVelocity);
            }, s.applyForce = function(d, m, g) {
              var y = { x: m.x - d.position.x, y: m.y - d.position.y };
              d.force.x += g.x, d.force.y += g.y, d.torque += y.x * g.y - y.y * g.x;
            }, s._totalProperties = function(d) {
              for (var m = {
                mass: 0,
                area: 0,
                inertia: 0,
                centre: { x: 0, y: 0 }
              }, g = d.parts.length === 1 ? 0 : 1; g < d.parts.length; g++) {
                var y = d.parts[g], b = y.mass !== 1 / 0 ? y.mass : 1;
                m.mass += b, m.area += y.area, m.inertia += y.inertia, m.centre = a.add(m.centre, a.mult(y.position, b));
              }
              return m.centre = a.div(m.centre, m.mass), m;
            };
          })();
        },
        /* 5 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(0);
          (function() {
            s.on = function(a, l, h) {
              for (var c = l.split(" "), p, f = 0; f < c.length; f++)
                p = c[f], a.events = a.events || {}, a.events[p] = a.events[p] || [], a.events[p].push(h);
              return h;
            }, s.off = function(a, l, h) {
              if (!l) {
                a.events = {};
                return;
              }
              typeof l == "function" && (h = l, l = o.keys(a.events).join(" "));
              for (var c = l.split(" "), p = 0; p < c.length; p++) {
                var f = a.events[c[p]], d = [];
                if (h && f)
                  for (var m = 0; m < f.length; m++)
                    f[m] !== h && d.push(f[m]);
                a.events[c[p]] = d;
              }
            }, s.trigger = function(a, l, h) {
              var c, p, f, d, m = a.events;
              if (m && o.keys(m).length > 0) {
                h || (h = {}), c = l.split(" ");
                for (var g = 0; g < c.length; g++)
                  if (p = c[g], f = m[p], f) {
                    d = o.clone(h, !1), d.name = p, d.source = a;
                    for (var y = 0; y < f.length; y++)
                      f[y].apply(a, [d]);
                  }
              }
            };
          })();
        },
        /* 6 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(5), a = r(0), l = r(1), h = r(4);
          (function() {
            s.create = function(c) {
              return a.extend({
                id: a.nextId(),
                type: "composite",
                parent: null,
                isModified: !1,
                bodies: [],
                constraints: [],
                composites: [],
                label: "Composite",
                plugin: {},
                cache: {
                  allBodies: null,
                  allConstraints: null,
                  allComposites: null
                }
              }, c);
            }, s.setModified = function(c, p, f, d) {
              if (c.isModified = p, p && c.cache && (c.cache.allBodies = null, c.cache.allConstraints = null, c.cache.allComposites = null), f && c.parent && s.setModified(c.parent, p, f, d), d)
                for (var m = 0; m < c.composites.length; m++) {
                  var g = c.composites[m];
                  s.setModified(g, p, f, d);
                }
            }, s.add = function(c, p) {
              var f = [].concat(p);
              o.trigger(c, "beforeAdd", { object: p });
              for (var d = 0; d < f.length; d++) {
                var m = f[d];
                switch (m.type) {
                  case "body":
                    if (m.parent !== m) {
                      a.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)");
                      break;
                    }
                    s.addBody(c, m);
                    break;
                  case "constraint":
                    s.addConstraint(c, m);
                    break;
                  case "composite":
                    s.addComposite(c, m);
                    break;
                  case "mouseConstraint":
                    s.addConstraint(c, m.constraint);
                    break;
                }
              }
              return o.trigger(c, "afterAdd", { object: p }), c;
            }, s.remove = function(c, p, f) {
              var d = [].concat(p);
              o.trigger(c, "beforeRemove", { object: p });
              for (var m = 0; m < d.length; m++) {
                var g = d[m];
                switch (g.type) {
                  case "body":
                    s.removeBody(c, g, f);
                    break;
                  case "constraint":
                    s.removeConstraint(c, g, f);
                    break;
                  case "composite":
                    s.removeComposite(c, g, f);
                    break;
                  case "mouseConstraint":
                    s.removeConstraint(c, g.constraint);
                    break;
                }
              }
              return o.trigger(c, "afterRemove", { object: p }), c;
            }, s.addComposite = function(c, p) {
              return c.composites.push(p), p.parent = c, s.setModified(c, !0, !0, !1), c;
            }, s.removeComposite = function(c, p, f) {
              var d = a.indexOf(c.composites, p);
              if (d !== -1) {
                var m = s.allBodies(p);
                s.removeCompositeAt(c, d);
                for (var g = 0; g < m.length; g++)
                  m[g].sleepCounter = 0;
              }
              if (f)
                for (var g = 0; g < c.composites.length; g++)
                  s.removeComposite(c.composites[g], p, !0);
              return c;
            }, s.removeCompositeAt = function(c, p) {
              return c.composites.splice(p, 1), s.setModified(c, !0, !0, !1), c;
            }, s.addBody = function(c, p) {
              return c.bodies.push(p), s.setModified(c, !0, !0, !1), c;
            }, s.removeBody = function(c, p, f) {
              var d = a.indexOf(c.bodies, p);
              if (d !== -1 && (s.removeBodyAt(c, d), p.sleepCounter = 0), f)
                for (var m = 0; m < c.composites.length; m++)
                  s.removeBody(c.composites[m], p, !0);
              return c;
            }, s.removeBodyAt = function(c, p) {
              return c.bodies.splice(p, 1), s.setModified(c, !0, !0, !1), c;
            }, s.addConstraint = function(c, p) {
              return c.constraints.push(p), s.setModified(c, !0, !0, !1), c;
            }, s.removeConstraint = function(c, p, f) {
              var d = a.indexOf(c.constraints, p);
              if (d !== -1 && s.removeConstraintAt(c, d), f)
                for (var m = 0; m < c.composites.length; m++)
                  s.removeConstraint(c.composites[m], p, !0);
              return c;
            }, s.removeConstraintAt = function(c, p) {
              return c.constraints.splice(p, 1), s.setModified(c, !0, !0, !1), c;
            }, s.clear = function(c, p, f) {
              if (f)
                for (var d = 0; d < c.composites.length; d++)
                  s.clear(c.composites[d], p, !0);
              return p ? c.bodies = c.bodies.filter(function(m) {
                return m.isStatic;
              }) : c.bodies.length = 0, c.constraints.length = 0, c.composites.length = 0, s.setModified(c, !0, !0, !1), c;
            }, s.allBodies = function(c) {
              if (c.cache && c.cache.allBodies)
                return c.cache.allBodies;
              for (var p = [].concat(c.bodies), f = 0; f < c.composites.length; f++)
                p = p.concat(s.allBodies(c.composites[f]));
              return c.cache && (c.cache.allBodies = p), p;
            }, s.allConstraints = function(c) {
              if (c.cache && c.cache.allConstraints)
                return c.cache.allConstraints;
              for (var p = [].concat(c.constraints), f = 0; f < c.composites.length; f++)
                p = p.concat(s.allConstraints(c.composites[f]));
              return c.cache && (c.cache.allConstraints = p), p;
            }, s.allComposites = function(c) {
              if (c.cache && c.cache.allComposites)
                return c.cache.allComposites;
              for (var p = [].concat(c.composites), f = 0; f < c.composites.length; f++)
                p = p.concat(s.allComposites(c.composites[f]));
              return c.cache && (c.cache.allComposites = p), p;
            }, s.get = function(c, p, f) {
              var d, m;
              switch (f) {
                case "body":
                  d = s.allBodies(c);
                  break;
                case "constraint":
                  d = s.allConstraints(c);
                  break;
                case "composite":
                  d = s.allComposites(c).concat(c);
                  break;
              }
              return d ? (m = d.filter(function(g) {
                return g.id.toString() === p.toString();
              }), m.length === 0 ? null : m[0]) : null;
            }, s.move = function(c, p, f) {
              return s.remove(c, p), s.add(f, p), c;
            }, s.rebase = function(c) {
              for (var p = s.allBodies(c).concat(s.allConstraints(c)).concat(s.allComposites(c)), f = 0; f < p.length; f++)
                p[f].id = a.nextId();
              return c;
            }, s.translate = function(c, p, f) {
              for (var d = f ? s.allBodies(c) : c.bodies, m = 0; m < d.length; m++)
                h.translate(d[m], p);
              return c;
            }, s.rotate = function(c, p, f, d) {
              for (var m = Math.cos(p), g = Math.sin(p), y = d ? s.allBodies(c) : c.bodies, b = 0; b < y.length; b++) {
                var S = y[b], C = S.position.x - f.x, I = S.position.y - f.y;
                h.setPosition(S, {
                  x: f.x + (C * m - I * g),
                  y: f.y + (C * g + I * m)
                }), h.rotate(S, p);
              }
              return c;
            }, s.scale = function(c, p, f, d, m) {
              for (var g = m ? s.allBodies(c) : c.bodies, y = 0; y < g.length; y++) {
                var b = g[y], S = b.position.x - d.x, C = b.position.y - d.y;
                h.setPosition(b, {
                  x: d.x + S * p,
                  y: d.y + C * f
                }), h.scale(b, p, f);
              }
              return c;
            }, s.bounds = function(c) {
              for (var p = s.allBodies(c), f = [], d = 0; d < p.length; d += 1) {
                var m = p[d];
                f.push(m.bounds.min, m.bounds.max);
              }
              return l.create(f);
            };
          })();
        },
        /* 7 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(4), a = r(5), l = r(0);
          (function() {
            s._motionWakeThreshold = 0.18, s._motionSleepThreshold = 0.08, s._minBias = 0.9, s.update = function(h, c) {
              for (var p = c / l._baseDelta, f = s._motionSleepThreshold, d = 0; d < h.length; d++) {
                var m = h[d], g = o.getSpeed(m), y = o.getAngularSpeed(m), b = g * g + y * y;
                if (m.force.x !== 0 || m.force.y !== 0) {
                  s.set(m, !1);
                  continue;
                }
                var S = Math.min(m.motion, b), C = Math.max(m.motion, b);
                m.motion = s._minBias * S + (1 - s._minBias) * C, m.sleepThreshold > 0 && m.motion < f ? (m.sleepCounter += 1, m.sleepCounter >= m.sleepThreshold / p && s.set(m, !0)) : m.sleepCounter > 0 && (m.sleepCounter -= 1);
              }
            }, s.afterCollisions = function(h) {
              for (var c = s._motionSleepThreshold, p = 0; p < h.length; p++) {
                var f = h[p];
                if (f.isActive) {
                  var d = f.collision, m = d.bodyA.parent, g = d.bodyB.parent;
                  if (!(m.isSleeping && g.isSleeping || m.isStatic || g.isStatic) && (m.isSleeping || g.isSleeping)) {
                    var y = m.isSleeping && !m.isStatic ? m : g, b = y === m ? g : m;
                    !y.isStatic && b.motion > c && s.set(y, !1);
                  }
                }
              }
            }, s.set = function(h, c) {
              var p = h.isSleeping;
              c ? (h.isSleeping = !0, h.sleepCounter = h.sleepThreshold, h.positionImpulse.x = 0, h.positionImpulse.y = 0, h.positionPrev.x = h.position.x, h.positionPrev.y = h.position.y, h.anglePrev = h.angle, h.speed = 0, h.angularSpeed = 0, h.motion = 0, p || a.trigger(h, "sleepStart")) : (h.isSleeping = !1, h.sleepCounter = 0, p && a.trigger(h, "sleepEnd"));
            };
          })();
        },
        /* 8 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(3), a = r(9);
          (function() {
            var l = [], h = {
              overlap: 0,
              axis: null
            }, c = {
              overlap: 0,
              axis: null
            };
            s.create = function(p, f) {
              return {
                pair: null,
                collided: !1,
                bodyA: p,
                bodyB: f,
                parentA: p.parent,
                parentB: f.parent,
                depth: 0,
                normal: { x: 0, y: 0 },
                tangent: { x: 0, y: 0 },
                penetration: { x: 0, y: 0 },
                supports: [null, null],
                supportCount: 0
              };
            }, s.collides = function(p, f, d) {
              if (s._overlapAxes(h, p.vertices, f.vertices, p.axes), h.overlap <= 0 || (s._overlapAxes(c, f.vertices, p.vertices, f.axes), c.overlap <= 0))
                return null;
              var m = d && d.table[a.id(p, f)], g;
              m ? g = m.collision : (g = s.create(p, f), g.collided = !0, g.bodyA = p.id < f.id ? p : f, g.bodyB = p.id < f.id ? f : p, g.parentA = g.bodyA.parent, g.parentB = g.bodyB.parent), p = g.bodyA, f = g.bodyB;
              var y;
              h.overlap < c.overlap ? y = h : y = c;
              var b = g.normal, S = g.tangent, C = g.penetration, I = g.supports, T = y.overlap, R = y.axis, w = R.x, v = R.y, x = f.position.x - p.position.x, A = f.position.y - p.position.y;
              w * x + v * A >= 0 && (w = -w, v = -v), b.x = w, b.y = v, S.x = -v, S.y = w, C.x = w * T, C.y = v * T, g.depth = T;
              var P = s._findSupports(p, f, b, 1), M = 0;
              if (o.contains(p.vertices, P[0]) && (I[M++] = P[0]), o.contains(p.vertices, P[1]) && (I[M++] = P[1]), M < 2) {
                var k = s._findSupports(f, p, b, -1);
                o.contains(f.vertices, k[0]) && (I[M++] = k[0]), M < 2 && o.contains(f.vertices, k[1]) && (I[M++] = k[1]);
              }
              return M === 0 && (I[M++] = P[0]), g.supportCount = M, g;
            }, s._overlapAxes = function(p, f, d, m) {
              var g = f.length, y = d.length, b = f[0].x, S = f[0].y, C = d[0].x, I = d[0].y, T = m.length, R = Number.MAX_VALUE, w = 0, v, x, A, P, M, k;
              for (M = 0; M < T; M++) {
                var B = m[M], V = B.x, N = B.y, U = b * V + S * N, K = C * V + I * N, j = U, H = K;
                for (k = 1; k < g; k += 1)
                  P = f[k].x * V + f[k].y * N, P > j ? j = P : P < U && (U = P);
                for (k = 1; k < y; k += 1)
                  P = d[k].x * V + d[k].y * N, P > H ? H = P : P < K && (K = P);
                if (x = j - K, A = H - U, v = x < A ? x : A, v < R && (R = v, w = M, v <= 0))
                  break;
              }
              p.axis = m[w], p.overlap = R;
            }, s._findSupports = function(p, f, d, m) {
              var g = f.vertices, y = g.length, b = p.position.x, S = p.position.y, C = d.x * m, I = d.y * m, T = g[0], R = T, w = C * (b - R.x) + I * (S - R.y), v, x, A;
              for (A = 1; A < y; A += 1)
                R = g[A], x = C * (b - R.x) + I * (S - R.y), x < w && (w = x, T = R);
              return v = g[(y + T.index - 1) % y], w = C * (b - v.x) + I * (S - v.y), R = g[(T.index + 1) % y], C * (b - R.x) + I * (S - R.y) < w ? (l[0] = T, l[1] = R, l) : (l[0] = T, l[1] = v, l);
            };
          })();
        },
        /* 9 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(16);
          (function() {
            s.create = function(a, l) {
              var h = a.bodyA, c = a.bodyB, p = {
                id: s.id(h, c),
                bodyA: h,
                bodyB: c,
                collision: a,
                contacts: [o.create(), o.create()],
                contactCount: 0,
                separation: 0,
                isActive: !0,
                isSensor: h.isSensor || c.isSensor,
                timeCreated: l,
                timeUpdated: l,
                inverseMass: 0,
                friction: 0,
                frictionStatic: 0,
                restitution: 0,
                slop: 0
              };
              return s.update(p, a, l), p;
            }, s.update = function(a, l, h) {
              var c = l.supports, p = l.supportCount, f = a.contacts, d = l.parentA, m = l.parentB;
              a.isActive = !0, a.timeUpdated = h, a.collision = l, a.separation = l.depth, a.inverseMass = d.inverseMass + m.inverseMass, a.friction = d.friction < m.friction ? d.friction : m.friction, a.frictionStatic = d.frictionStatic > m.frictionStatic ? d.frictionStatic : m.frictionStatic, a.restitution = d.restitution > m.restitution ? d.restitution : m.restitution, a.slop = d.slop > m.slop ? d.slop : m.slop, a.contactCount = p, l.pair = a;
              var g = c[0], y = f[0], b = c[1], S = f[1];
              (S.vertex === g || y.vertex === b) && (f[1] = y, f[0] = y = S, S = f[1]), y.vertex = g, S.vertex = b;
            }, s.setActive = function(a, l, h) {
              l ? (a.isActive = !0, a.timeUpdated = h) : (a.isActive = !1, a.contactCount = 0);
            }, s.id = function(a, l) {
              return a.id < l.id ? a.id.toString(36) + ":" + l.id.toString(36) : l.id.toString(36) + ":" + a.id.toString(36);
            };
          })();
        },
        /* 10 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(3), a = r(2), l = r(7), h = r(1), c = r(11), p = r(0);
          (function() {
            s._warming = 0.4, s._torqueDampen = 1, s._minLength = 1e-6, s.create = function(f) {
              var d = f;
              d.bodyA && !d.pointA && (d.pointA = { x: 0, y: 0 }), d.bodyB && !d.pointB && (d.pointB = { x: 0, y: 0 });
              var m = d.bodyA ? a.add(d.bodyA.position, d.pointA) : d.pointA, g = d.bodyB ? a.add(d.bodyB.position, d.pointB) : d.pointB, y = a.magnitude(a.sub(m, g));
              d.length = typeof d.length < "u" ? d.length : y, d.id = d.id || p.nextId(), d.label = d.label || "Constraint", d.type = "constraint", d.stiffness = d.stiffness || (d.length > 0 ? 1 : 0.7), d.damping = d.damping || 0, d.angularStiffness = d.angularStiffness || 0, d.angleA = d.bodyA ? d.bodyA.angle : d.angleA, d.angleB = d.bodyB ? d.bodyB.angle : d.angleB, d.plugin = {};
              var b = {
                visible: !0,
                lineWidth: 2,
                strokeStyle: "#ffffff",
                type: "line",
                anchors: !0
              };
              return d.length === 0 && d.stiffness > 0.1 ? (b.type = "pin", b.anchors = !1) : d.stiffness < 0.9 && (b.type = "spring"), d.render = p.extend(b, d.render), d;
            }, s.preSolveAll = function(f) {
              for (var d = 0; d < f.length; d += 1) {
                var m = f[d], g = m.constraintImpulse;
                m.isStatic || g.x === 0 && g.y === 0 && g.angle === 0 || (m.position.x += g.x, m.position.y += g.y, m.angle += g.angle);
              }
            }, s.solveAll = function(f, d) {
              for (var m = p.clamp(d / p._baseDelta, 0, 1), g = 0; g < f.length; g += 1) {
                var y = f[g], b = !y.bodyA || y.bodyA && y.bodyA.isStatic, S = !y.bodyB || y.bodyB && y.bodyB.isStatic;
                (b || S) && s.solve(f[g], m);
              }
              for (g = 0; g < f.length; g += 1)
                y = f[g], b = !y.bodyA || y.bodyA && y.bodyA.isStatic, S = !y.bodyB || y.bodyB && y.bodyB.isStatic, !b && !S && s.solve(f[g], m);
            }, s.solve = function(f, d) {
              var m = f.bodyA, g = f.bodyB, y = f.pointA, b = f.pointB;
              if (!(!m && !g)) {
                m && !m.isStatic && (a.rotate(y, m.angle - f.angleA, y), f.angleA = m.angle), g && !g.isStatic && (a.rotate(b, g.angle - f.angleB, b), f.angleB = g.angle);
                var S = y, C = b;
                if (m && (S = a.add(m.position, y)), g && (C = a.add(g.position, b)), !(!S || !C)) {
                  var I = a.sub(S, C), T = a.magnitude(I);
                  T < s._minLength && (T = s._minLength);
                  var R = (T - f.length) / T, w = f.stiffness >= 1 || f.length === 0, v = w ? f.stiffness * d : f.stiffness * d * d, x = f.damping * d, A = a.mult(I, R * v), P = (m ? m.inverseMass : 0) + (g ? g.inverseMass : 0), M = (m ? m.inverseInertia : 0) + (g ? g.inverseInertia : 0), k = P + M, B, V, N, U, K;
                  if (x > 0) {
                    var j = a.create();
                    N = a.div(I, T), K = a.sub(
                      g && a.sub(g.position, g.positionPrev) || j,
                      m && a.sub(m.position, m.positionPrev) || j
                    ), U = a.dot(N, K);
                  }
                  m && !m.isStatic && (V = m.inverseMass / P, m.constraintImpulse.x -= A.x * V, m.constraintImpulse.y -= A.y * V, m.position.x -= A.x * V, m.position.y -= A.y * V, x > 0 && (m.positionPrev.x -= x * N.x * U * V, m.positionPrev.y -= x * N.y * U * V), B = a.cross(y, A) / k * s._torqueDampen * m.inverseInertia * (1 - f.angularStiffness), m.constraintImpulse.angle -= B, m.angle -= B), g && !g.isStatic && (V = g.inverseMass / P, g.constraintImpulse.x += A.x * V, g.constraintImpulse.y += A.y * V, g.position.x += A.x * V, g.position.y += A.y * V, x > 0 && (g.positionPrev.x += x * N.x * U * V, g.positionPrev.y += x * N.y * U * V), B = a.cross(b, A) / k * s._torqueDampen * g.inverseInertia * (1 - f.angularStiffness), g.constraintImpulse.angle += B, g.angle += B);
                }
              }
            }, s.postSolveAll = function(f) {
              for (var d = 0; d < f.length; d++) {
                var m = f[d], g = m.constraintImpulse;
                if (!(m.isStatic || g.x === 0 && g.y === 0 && g.angle === 0)) {
                  l.set(m, !1);
                  for (var y = 0; y < m.parts.length; y++) {
                    var b = m.parts[y];
                    o.translate(b.vertices, g), y > 0 && (b.position.x += g.x, b.position.y += g.y), g.angle !== 0 && (o.rotate(b.vertices, g.angle, m.position), c.rotate(b.axes, g.angle), y > 0 && a.rotateAbout(b.position, g.angle, m.position, b.position)), h.update(b.bounds, b.vertices, m.velocity);
                  }
                  g.angle *= s._warming, g.x *= s._warming, g.y *= s._warming;
                }
              }
            }, s.pointAWorld = function(f) {
              return {
                x: (f.bodyA ? f.bodyA.position.x : 0) + (f.pointA ? f.pointA.x : 0),
                y: (f.bodyA ? f.bodyA.position.y : 0) + (f.pointA ? f.pointA.y : 0)
              };
            }, s.pointBWorld = function(f) {
              return {
                x: (f.bodyB ? f.bodyB.position.x : 0) + (f.pointB ? f.pointB.x : 0),
                y: (f.bodyB ? f.bodyB.position.y : 0) + (f.pointB ? f.pointB.y : 0)
              };
            }, s.currentLength = function(f) {
              var d = (f.bodyA ? f.bodyA.position.x : 0) + (f.pointA ? f.pointA.x : 0), m = (f.bodyA ? f.bodyA.position.y : 0) + (f.pointA ? f.pointA.y : 0), g = (f.bodyB ? f.bodyB.position.x : 0) + (f.pointB ? f.pointB.x : 0), y = (f.bodyB ? f.bodyB.position.y : 0) + (f.pointB ? f.pointB.y : 0), b = d - g, S = m - y;
              return Math.sqrt(b * b + S * S);
            };
          })();
        },
        /* 11 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(2), a = r(0);
          (function() {
            s.fromVertices = function(l) {
              for (var h = {}, c = 0; c < l.length; c++) {
                var p = (c + 1) % l.length, f = o.normalise({
                  x: l[p].y - l[c].y,
                  y: l[c].x - l[p].x
                }), d = f.y === 0 ? 1 / 0 : f.x / f.y;
                d = d.toFixed(3).toString(), h[d] = f;
              }
              return a.values(h);
            }, s.rotate = function(l, h) {
              if (h !== 0)
                for (var c = Math.cos(h), p = Math.sin(h), f = 0; f < l.length; f++) {
                  var d = l[f], m;
                  m = d.x * c - d.y * p, d.y = d.x * p + d.y * c, d.x = m;
                }
            };
          })();
        },
        /* 12 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(3), a = r(0), l = r(4), h = r(1), c = r(2);
          (function() {
            s.rectangle = function(p, f, d, m, g) {
              g = g || {};
              var y = {
                label: "Rectangle Body",
                position: { x: p, y: f },
                vertices: o.fromPath("L 0 0 L " + d + " 0 L " + d + " " + m + " L 0 " + m)
              };
              if (g.chamfer) {
                var b = g.chamfer;
                y.vertices = o.chamfer(
                  y.vertices,
                  b.radius,
                  b.quality,
                  b.qualityMin,
                  b.qualityMax
                ), delete g.chamfer;
              }
              return l.create(a.extend({}, y, g));
            }, s.trapezoid = function(p, f, d, m, g, y) {
              y = y || {}, g >= 1 && a.warn("Bodies.trapezoid: slope parameter must be < 1."), g *= 0.5;
              var b = (1 - g * 2) * d, S = d * g, C = S + b, I = C + S, T;
              g < 0.5 ? T = "L 0 0 L " + S + " " + -m + " L " + C + " " + -m + " L " + I + " 0" : T = "L 0 0 L " + C + " " + -m + " L " + I + " 0";
              var R = {
                label: "Trapezoid Body",
                position: { x: p, y: f },
                vertices: o.fromPath(T)
              };
              if (y.chamfer) {
                var w = y.chamfer;
                R.vertices = o.chamfer(
                  R.vertices,
                  w.radius,
                  w.quality,
                  w.qualityMin,
                  w.qualityMax
                ), delete y.chamfer;
              }
              return l.create(a.extend({}, R, y));
            }, s.circle = function(p, f, d, m, g) {
              m = m || {};
              var y = {
                label: "Circle Body",
                circleRadius: d
              };
              g = g || 25;
              var b = Math.ceil(Math.max(10, Math.min(g, d)));
              return b % 2 === 1 && (b += 1), s.polygon(p, f, b, d, a.extend({}, y, m));
            }, s.polygon = function(p, f, d, m, g) {
              if (g = g || {}, d < 3)
                return s.circle(p, f, m, g);
              for (var y = 2 * Math.PI / d, b = "", S = y * 0.5, C = 0; C < d; C += 1) {
                var I = S + C * y, T = Math.cos(I) * m, R = Math.sin(I) * m;
                b += "L " + T.toFixed(3) + " " + R.toFixed(3) + " ";
              }
              var w = {
                label: "Polygon Body",
                position: { x: p, y: f },
                vertices: o.fromPath(b)
              };
              if (g.chamfer) {
                var v = g.chamfer;
                w.vertices = o.chamfer(
                  w.vertices,
                  v.radius,
                  v.quality,
                  v.qualityMin,
                  v.qualityMax
                ), delete g.chamfer;
              }
              return l.create(a.extend({}, w, g));
            }, s.fromVertices = function(p, f, d, m, g, y, b, S) {
              var C = a.getDecomp(), I, T, R, w, v, x, A, P, M, k, B;
              for (I = !!(C && C.quickDecomp), m = m || {}, R = [], g = typeof g < "u" ? g : !1, y = typeof y < "u" ? y : 0.01, b = typeof b < "u" ? b : 10, S = typeof S < "u" ? S : 0.01, a.isArray(d[0]) || (d = [d]), k = 0; k < d.length; k += 1)
                if (x = d[k], w = o.isConvex(x), v = !w, v && !I && a.warnOnce(
                  "Bodies.fromVertices: Install the 'poly-decomp' library and use Common.setDecomp or provide 'decomp' as a global to decompose concave vertices."
                ), w || !I)
                  w ? x = o.clockwiseSort(x) : x = o.hull(x), R.push({
                    position: { x: p, y: f },
                    vertices: x
                  });
                else {
                  var V = x.map(function($) {
                    return [$.x, $.y];
                  });
                  C.makeCCW(V), y !== !1 && C.removeCollinearPoints(V, y), S !== !1 && C.removeDuplicatePoints && C.removeDuplicatePoints(V, S);
                  var N = C.quickDecomp(V);
                  for (A = 0; A < N.length; A++) {
                    var U = N[A], K = U.map(function($) {
                      return {
                        x: $[0],
                        y: $[1]
                      };
                    });
                    b > 0 && o.area(K) < b || R.push({
                      position: o.centre(K),
                      vertices: K
                    });
                  }
                }
              for (A = 0; A < R.length; A++)
                R[A] = l.create(a.extend(R[A], m));
              if (g) {
                var j = 5;
                for (A = 0; A < R.length; A++) {
                  var H = R[A];
                  for (P = A + 1; P < R.length; P++) {
                    var pt = R[P];
                    if (h.overlaps(H.bounds, pt.bounds)) {
                      var Q = H.vertices, J = pt.vertices;
                      for (M = 0; M < H.vertices.length; M++)
                        for (B = 0; B < pt.vertices.length; B++) {
                          var bt = c.magnitudeSquared(c.sub(Q[(M + 1) % Q.length], J[B])), St = c.magnitudeSquared(c.sub(Q[M], J[(B + 1) % J.length]));
                          bt < j && St < j && (Q[M].isInternal = !0, J[B].isInternal = !0);
                        }
                    }
                  }
                }
              }
              return R.length > 1 ? (T = l.create(a.extend({ parts: R.slice(0) }, m)), l.setPosition(T, { x: p, y: f }), T) : R[0];
            };
          })();
        },
        /* 13 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(0), a = r(8);
          (function() {
            s.create = function(l) {
              var h = {
                bodies: [],
                collisions: [],
                pairs: null
              };
              return o.extend(h, l);
            }, s.setBodies = function(l, h) {
              l.bodies = h.slice(0);
            }, s.clear = function(l) {
              l.bodies = [], l.collisions = [];
            }, s.collisions = function(l) {
              var h = l.pairs, c = l.bodies, p = c.length, f = s.canCollide, d = a.collides, m = l.collisions, g = 0, y, b;
              for (c.sort(s._compareBoundsX), y = 0; y < p; y++) {
                var S = c[y], C = S.bounds, I = S.bounds.max.x, T = S.bounds.max.y, R = S.bounds.min.y, w = S.isStatic || S.isSleeping, v = S.parts.length, x = v === 1;
                for (b = y + 1; b < p; b++) {
                  var A = c[b], P = A.bounds;
                  if (P.min.x > I)
                    break;
                  if (!(T < P.min.y || R > P.max.y) && !(w && (A.isStatic || A.isSleeping)) && f(S.collisionFilter, A.collisionFilter)) {
                    var M = A.parts.length;
                    if (x && M === 1) {
                      var k = d(S, A, h);
                      k && (m[g++] = k);
                    } else
                      for (var B = v > 1 ? 1 : 0, V = M > 1 ? 1 : 0, N = B; N < v; N++)
                        for (var U = S.parts[N], C = U.bounds, K = V; K < M; K++) {
                          var j = A.parts[K], P = j.bounds;
                          if (!(C.min.x > P.max.x || C.max.x < P.min.x || C.max.y < P.min.y || C.min.y > P.max.y)) {
                            var k = d(U, j, h);
                            k && (m[g++] = k);
                          }
                        }
                  }
                }
              }
              return m.length !== g && (m.length = g), m;
            }, s.canCollide = function(l, h) {
              return l.group === h.group && l.group !== 0 ? l.group > 0 : (l.mask & h.category) !== 0 && (h.mask & l.category) !== 0;
            }, s._compareBoundsX = function(l, h) {
              return l.bounds.min.x - h.bounds.min.x;
            };
          })();
        },
        /* 14 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(0);
          (function() {
            s.create = function(a) {
              var l = {};
              return a || o.log("Mouse.create: element was undefined, defaulting to document.body", "warn"), l.element = a || document.body, l.absolute = { x: 0, y: 0 }, l.position = { x: 0, y: 0 }, l.mousedownPosition = { x: 0, y: 0 }, l.mouseupPosition = { x: 0, y: 0 }, l.offset = { x: 0, y: 0 }, l.scale = { x: 1, y: 1 }, l.wheelDelta = 0, l.button = -1, l.pixelRatio = parseInt(l.element.getAttribute("data-pixel-ratio"), 10) || 1, l.sourceEvents = {
                mousemove: null,
                mousedown: null,
                mouseup: null,
                mousewheel: null
              }, l.mousemove = function(h) {
                var c = s._getRelativeMousePosition(h, l.element, l.pixelRatio), p = h.changedTouches;
                p && (l.button = 0, h.preventDefault()), l.absolute.x = c.x, l.absolute.y = c.y, l.position.x = l.absolute.x * l.scale.x + l.offset.x, l.position.y = l.absolute.y * l.scale.y + l.offset.y, l.sourceEvents.mousemove = h;
              }, l.mousedown = function(h) {
                var c = s._getRelativeMousePosition(h, l.element, l.pixelRatio), p = h.changedTouches;
                p ? (l.button = 0, h.preventDefault()) : l.button = h.button, l.absolute.x = c.x, l.absolute.y = c.y, l.position.x = l.absolute.x * l.scale.x + l.offset.x, l.position.y = l.absolute.y * l.scale.y + l.offset.y, l.mousedownPosition.x = l.position.x, l.mousedownPosition.y = l.position.y, l.sourceEvents.mousedown = h;
              }, l.mouseup = function(h) {
                var c = s._getRelativeMousePosition(h, l.element, l.pixelRatio), p = h.changedTouches;
                p && h.preventDefault(), l.button = -1, l.absolute.x = c.x, l.absolute.y = c.y, l.position.x = l.absolute.x * l.scale.x + l.offset.x, l.position.y = l.absolute.y * l.scale.y + l.offset.y, l.mouseupPosition.x = l.position.x, l.mouseupPosition.y = l.position.y, l.sourceEvents.mouseup = h;
              }, l.mousewheel = function(h) {
                l.wheelDelta = Math.max(-1, Math.min(1, h.wheelDelta || -h.detail)), h.preventDefault(), l.sourceEvents.mousewheel = h;
              }, s.setElement(l, l.element), l;
            }, s.setElement = function(a, l) {
              a.element = l, l.addEventListener("mousemove", a.mousemove, { passive: !0 }), l.addEventListener("mousedown", a.mousedown, { passive: !0 }), l.addEventListener("mouseup", a.mouseup, { passive: !0 }), l.addEventListener("wheel", a.mousewheel, { passive: !1 }), l.addEventListener("touchmove", a.mousemove, { passive: !1 }), l.addEventListener("touchstart", a.mousedown, { passive: !1 }), l.addEventListener("touchend", a.mouseup, { passive: !1 });
            }, s.clearSourceEvents = function(a) {
              a.sourceEvents.mousemove = null, a.sourceEvents.mousedown = null, a.sourceEvents.mouseup = null, a.sourceEvents.mousewheel = null, a.wheelDelta = 0;
            }, s.setOffset = function(a, l) {
              a.offset.x = l.x, a.offset.y = l.y, a.position.x = a.absolute.x * a.scale.x + a.offset.x, a.position.y = a.absolute.y * a.scale.y + a.offset.y;
            }, s.setScale = function(a, l) {
              a.scale.x = l.x, a.scale.y = l.y, a.position.x = a.absolute.x * a.scale.x + a.offset.x, a.position.y = a.absolute.y * a.scale.y + a.offset.y;
            }, s._getRelativeMousePosition = function(a, l, h) {
              var c = l.getBoundingClientRect(), p = document.documentElement || document.body.parentNode || document.body, f = window.pageXOffset !== void 0 ? window.pageXOffset : p.scrollLeft, d = window.pageYOffset !== void 0 ? window.pageYOffset : p.scrollTop, m = a.changedTouches, g, y;
              return m ? (g = m[0].pageX - c.left - f, y = m[0].pageY - c.top - d) : (g = a.pageX - c.left - f, y = a.pageY - c.top - d), {
                x: g / (l.clientWidth / (l.width || l.clientWidth) * h),
                y: y / (l.clientHeight / (l.height || l.clientHeight) * h)
              };
            };
          })();
        },
        /* 15 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(0);
          (function() {
            s._registry = {}, s.register = function(a) {
              if (s.isPlugin(a) || o.warn("Plugin.register:", s.toString(a), "does not implement all required fields."), a.name in s._registry) {
                var l = s._registry[a.name], h = s.versionParse(a.version).number, c = s.versionParse(l.version).number;
                h > c ? (o.warn("Plugin.register:", s.toString(l), "was upgraded to", s.toString(a)), s._registry[a.name] = a) : h < c ? o.warn("Plugin.register:", s.toString(l), "can not be downgraded to", s.toString(a)) : a !== l && o.warn("Plugin.register:", s.toString(a), "is already registered to different plugin object");
              } else
                s._registry[a.name] = a;
              return a;
            }, s.resolve = function(a) {
              return s._registry[s.dependencyParse(a).name];
            }, s.toString = function(a) {
              return typeof a == "string" ? a : (a.name || "anonymous") + "@" + (a.version || a.range || "0.0.0");
            }, s.isPlugin = function(a) {
              return a && a.name && a.version && a.install;
            }, s.isUsed = function(a, l) {
              return a.used.indexOf(l) > -1;
            }, s.isFor = function(a, l) {
              var h = a.for && s.dependencyParse(a.for);
              return !a.for || l.name === h.name && s.versionSatisfies(l.version, h.range);
            }, s.use = function(a, l) {
              if (a.uses = (a.uses || []).concat(l || []), a.uses.length === 0) {
                o.warn("Plugin.use:", s.toString(a), "does not specify any dependencies to install.");
                return;
              }
              for (var h = s.dependencies(a), c = o.topologicalSort(h), p = [], f = 0; f < c.length; f += 1)
                if (c[f] !== a.name) {
                  var d = s.resolve(c[f]);
                  if (!d) {
                    p.push("❌ " + c[f]);
                    continue;
                  }
                  s.isUsed(a, d.name) || (s.isFor(d, a) || (o.warn("Plugin.use:", s.toString(d), "is for", d.for, "but installed on", s.toString(a) + "."), d._warned = !0), d.install ? d.install(a) : (o.warn("Plugin.use:", s.toString(d), "does not specify an install function."), d._warned = !0), d._warned ? (p.push("🔶 " + s.toString(d)), delete d._warned) : p.push("✅ " + s.toString(d)), a.used.push(d.name));
                }
              p.length > 0 && o.info(p.join("  "));
            }, s.dependencies = function(a, l) {
              var h = s.dependencyParse(a), c = h.name;
              if (l = l || {}, !(c in l)) {
                a = s.resolve(a) || a, l[c] = o.map(a.uses || [], function(f) {
                  s.isPlugin(f) && s.register(f);
                  var d = s.dependencyParse(f), m = s.resolve(f);
                  return m && !s.versionSatisfies(m.version, d.range) ? (o.warn(
                    "Plugin.dependencies:",
                    s.toString(m),
                    "does not satisfy",
                    s.toString(d),
                    "used by",
                    s.toString(h) + "."
                  ), m._warned = !0, a._warned = !0) : m || (o.warn(
                    "Plugin.dependencies:",
                    s.toString(f),
                    "used by",
                    s.toString(h),
                    "could not be resolved."
                  ), a._warned = !0), d.name;
                });
                for (var p = 0; p < l[c].length; p += 1)
                  s.dependencies(l[c][p], l);
                return l;
              }
            }, s.dependencyParse = function(a) {
              if (o.isString(a)) {
                var l = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-+]+)?))?$/;
                return l.test(a) || o.warn("Plugin.dependencyParse:", a, "is not a valid dependency string."), {
                  name: a.split("@")[0],
                  range: a.split("@")[1] || "*"
                };
              }
              return {
                name: a.name,
                range: a.range || a.version
              };
            }, s.versionParse = function(a) {
              var l = /^(\*)|(\^|~|>=|>)?\s*((\d+)\.(\d+)\.(\d+))(-[0-9A-Za-z-+]+)?$/;
              l.test(a) || o.warn("Plugin.versionParse:", a, "is not a valid version or range.");
              var h = l.exec(a), c = Number(h[4]), p = Number(h[5]), f = Number(h[6]);
              return {
                isRange: !!(h[1] || h[2]),
                version: h[3],
                range: a,
                operator: h[1] || h[2] || "",
                major: c,
                minor: p,
                patch: f,
                parts: [c, p, f],
                prerelease: h[7],
                number: c * 1e8 + p * 1e4 + f
              };
            }, s.versionSatisfies = function(a, l) {
              l = l || "*";
              var h = s.versionParse(l), c = s.versionParse(a);
              if (h.isRange) {
                if (h.operator === "*" || a === "*")
                  return !0;
                if (h.operator === ">")
                  return c.number > h.number;
                if (h.operator === ">=")
                  return c.number >= h.number;
                if (h.operator === "~")
                  return c.major === h.major && c.minor === h.minor && c.patch >= h.patch;
                if (h.operator === "^")
                  return h.major > 0 ? c.major === h.major && c.number >= h.number : h.minor > 0 ? c.minor === h.minor && c.patch >= h.patch : c.patch === h.patch;
              }
              return a === l || a === "*";
            };
          })();
        },
        /* 16 */
        /***/
        function(e, n) {
          var r = {};
          e.exports = r, function() {
            r.create = function(s) {
              return {
                vertex: s,
                normalImpulse: 0,
                tangentImpulse: 0
              };
            };
          }();
        },
        /* 17 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(7), a = r(18), l = r(13), h = r(19), c = r(5), p = r(6), f = r(10), d = r(0), m = r(4);
          (function() {
            s._deltaMax = 1e3 / 60, s.create = function(g) {
              g = g || {};
              var y = {
                positionIterations: 6,
                velocityIterations: 4,
                constraintIterations: 2,
                enableSleeping: !1,
                events: [],
                plugin: {},
                gravity: {
                  x: 0,
                  y: 1,
                  scale: 1e-3
                },
                timing: {
                  timestamp: 0,
                  timeScale: 1,
                  lastDelta: 0,
                  lastElapsed: 0,
                  lastUpdatesPerFrame: 0
                }
              }, b = d.extend(y, g);
              return b.world = g.world || p.create({ label: "World" }), b.pairs = g.pairs || h.create(), b.detector = g.detector || l.create(), b.detector.pairs = b.pairs, b.grid = { buckets: [] }, b.world.gravity = b.gravity, b.broadphase = b.grid, b.metrics = {}, b;
            }, s.update = function(g, y) {
              var b = d.now(), S = g.world, C = g.detector, I = g.pairs, T = g.timing, R = T.timestamp, w;
              y > s._deltaMax && d.warnOnce(
                "Matter.Engine.update: delta argument is recommended to be less than or equal to",
                s._deltaMax.toFixed(3),
                "ms."
              ), y = typeof y < "u" ? y : d._baseDelta, y *= T.timeScale, T.timestamp += y, T.lastDelta = y;
              var v = {
                timestamp: T.timestamp,
                delta: y
              };
              c.trigger(g, "beforeUpdate", v);
              var x = p.allBodies(S), A = p.allConstraints(S);
              for (S.isModified && (l.setBodies(C, x), p.setModified(S, !1, !1, !0)), g.enableSleeping && o.update(x, y), s._bodiesApplyGravity(x, g.gravity), y > 0 && s._bodiesUpdate(x, y), c.trigger(g, "beforeSolve", v), f.preSolveAll(x), w = 0; w < g.constraintIterations; w++)
                f.solveAll(A, y);
              f.postSolveAll(x);
              var P = l.collisions(C);
              h.update(I, P, R), g.enableSleeping && o.afterCollisions(I.list), I.collisionStart.length > 0 && c.trigger(g, "collisionStart", {
                pairs: I.collisionStart,
                timestamp: T.timestamp,
                delta: y
              });
              var M = d.clamp(20 / g.positionIterations, 0, 1);
              for (a.preSolvePosition(I.list), w = 0; w < g.positionIterations; w++)
                a.solvePosition(I.list, y, M);
              for (a.postSolvePosition(x), f.preSolveAll(x), w = 0; w < g.constraintIterations; w++)
                f.solveAll(A, y);
              for (f.postSolveAll(x), a.preSolveVelocity(I.list), w = 0; w < g.velocityIterations; w++)
                a.solveVelocity(I.list, y);
              return s._bodiesUpdateVelocities(x), I.collisionActive.length > 0 && c.trigger(g, "collisionActive", {
                pairs: I.collisionActive,
                timestamp: T.timestamp,
                delta: y
              }), I.collisionEnd.length > 0 && c.trigger(g, "collisionEnd", {
                pairs: I.collisionEnd,
                timestamp: T.timestamp,
                delta: y
              }), s._bodiesClearForces(x), c.trigger(g, "afterUpdate", v), g.timing.lastElapsed = d.now() - b, g;
            }, s.merge = function(g, y) {
              if (d.extend(g, y), y.world) {
                g.world = y.world, s.clear(g);
                for (var b = p.allBodies(g.world), S = 0; S < b.length; S++) {
                  var C = b[S];
                  o.set(C, !1), C.id = d.nextId();
                }
              }
            }, s.clear = function(g) {
              h.clear(g.pairs), l.clear(g.detector);
            }, s._bodiesClearForces = function(g) {
              for (var y = g.length, b = 0; b < y; b++) {
                var S = g[b];
                S.force.x = 0, S.force.y = 0, S.torque = 0;
              }
            }, s._bodiesApplyGravity = function(g, y) {
              var b = typeof y.scale < "u" ? y.scale : 1e-3, S = g.length;
              if (!(y.x === 0 && y.y === 0 || b === 0))
                for (var C = 0; C < S; C++) {
                  var I = g[C];
                  I.isStatic || I.isSleeping || (I.force.y += I.mass * y.y * b, I.force.x += I.mass * y.x * b);
                }
            }, s._bodiesUpdate = function(g, y) {
              for (var b = g.length, S = 0; S < b; S++) {
                var C = g[S];
                C.isStatic || C.isSleeping || m.update(C, y);
              }
            }, s._bodiesUpdateVelocities = function(g) {
              for (var y = g.length, b = 0; b < y; b++)
                m.updateVelocities(g[b]);
            };
          })();
        },
        /* 18 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(3), a = r(0), l = r(1);
          (function() {
            s._restingThresh = 2, s._restingThreshTangent = Math.sqrt(6), s._positionDampen = 0.9, s._positionWarming = 0.8, s._frictionNormalMultiplier = 5, s._frictionMaxStatic = Number.MAX_VALUE, s.preSolvePosition = function(h) {
              var c, p, f, d = h.length;
              for (c = 0; c < d; c++)
                p = h[c], p.isActive && (f = p.contactCount, p.collision.parentA.totalContacts += f, p.collision.parentB.totalContacts += f);
            }, s.solvePosition = function(h, c, p) {
              var f, d, m, g, y, b, S, C, I = s._positionDampen * (p || 1), T = a.clamp(c / a._baseDelta, 0, 1), R = h.length;
              for (f = 0; f < R; f++)
                d = h[f], !(!d.isActive || d.isSensor) && (m = d.collision, g = m.parentA, y = m.parentB, b = m.normal, d.separation = m.depth + b.x * (y.positionImpulse.x - g.positionImpulse.x) + b.y * (y.positionImpulse.y - g.positionImpulse.y));
              for (f = 0; f < R; f++)
                d = h[f], !(!d.isActive || d.isSensor) && (m = d.collision, g = m.parentA, y = m.parentB, b = m.normal, C = d.separation - d.slop * T, (g.isStatic || y.isStatic) && (C *= 2), g.isStatic || g.isSleeping || (S = I / g.totalContacts, g.positionImpulse.x += b.x * C * S, g.positionImpulse.y += b.y * C * S), y.isStatic || y.isSleeping || (S = I / y.totalContacts, y.positionImpulse.x -= b.x * C * S, y.positionImpulse.y -= b.y * C * S));
            }, s.postSolvePosition = function(h) {
              for (var c = s._positionWarming, p = h.length, f = o.translate, d = l.update, m = 0; m < p; m++) {
                var g = h[m], y = g.positionImpulse, b = y.x, S = y.y, C = g.velocity;
                if (g.totalContacts = 0, b !== 0 || S !== 0) {
                  for (var I = 0; I < g.parts.length; I++) {
                    var T = g.parts[I];
                    f(T.vertices, y), d(T.bounds, T.vertices, C), T.position.x += b, T.position.y += S;
                  }
                  g.positionPrev.x += b, g.positionPrev.y += S, b * C.x + S * C.y < 0 ? (y.x = 0, y.y = 0) : (y.x *= c, y.y *= c);
                }
              }
            }, s.preSolveVelocity = function(h) {
              var c = h.length, p, f;
              for (p = 0; p < c; p++) {
                var d = h[p];
                if (!(!d.isActive || d.isSensor)) {
                  var m = d.contacts, g = d.contactCount, y = d.collision, b = y.parentA, S = y.parentB, C = y.normal, I = y.tangent;
                  for (f = 0; f < g; f++) {
                    var T = m[f], R = T.vertex, w = T.normalImpulse, v = T.tangentImpulse;
                    if (w !== 0 || v !== 0) {
                      var x = C.x * w + I.x * v, A = C.y * w + I.y * v;
                      b.isStatic || b.isSleeping || (b.positionPrev.x += x * b.inverseMass, b.positionPrev.y += A * b.inverseMass, b.anglePrev += b.inverseInertia * ((R.x - b.position.x) * A - (R.y - b.position.y) * x)), S.isStatic || S.isSleeping || (S.positionPrev.x -= x * S.inverseMass, S.positionPrev.y -= A * S.inverseMass, S.anglePrev -= S.inverseInertia * ((R.x - S.position.x) * A - (R.y - S.position.y) * x));
                    }
                  }
                }
              }
            }, s.solveVelocity = function(h, c) {
              var p = c / a._baseDelta, f = p * p, d = f * p, m = -s._restingThresh * p, g = s._restingThreshTangent, y = s._frictionNormalMultiplier * p, b = s._frictionMaxStatic, S = h.length, C, I, T, R;
              for (T = 0; T < S; T++) {
                var w = h[T];
                if (!(!w.isActive || w.isSensor)) {
                  var v = w.collision, x = v.parentA, A = v.parentB, P = v.normal.x, M = v.normal.y, k = v.tangent.x, B = v.tangent.y, V = w.inverseMass, N = w.friction * w.frictionStatic * y, U = w.contacts, K = w.contactCount, j = 1 / K, H = x.position.x - x.positionPrev.x, pt = x.position.y - x.positionPrev.y, Q = x.angle - x.anglePrev, J = A.position.x - A.positionPrev.x, bt = A.position.y - A.positionPrev.y, St = A.angle - A.anglePrev;
                  for (R = 0; R < K; R++) {
                    var $ = U[R], Ht = $.vertex, Tt = Ht.x - x.position.x, Fe = Ht.y - x.position.y, Yt = Ht.x - A.position.x, Xt = Ht.y - A.position.y, Et = H - Fe * Q, ci = pt + Tt * Q, wi = J - Xt * St, Le = bt + Yt * St, Ne = Et - wi, Xe = ci - Le, Ue = P * Ne + M * Xe, Ee = k * Ne + B * Xe, Ai = w.separation + Ue, Ni = Math.min(Ai, 1);
                    Ni = Ai < 0 ? 0 : Ni;
                    var io = Ni * N;
                    Ee < -io || Ee > io ? (I = Ee > 0 ? Ee : -Ee, C = w.friction * (Ee > 0 ? 1 : -1) * d, C < -I ? C = -I : C > I && (C = I)) : (C = Ee, I = b);
                    var Wn = Tt * M - Fe * P, qn = Yt * M - Xt * P, Nr = j / (V + x.inverseInertia * Wn * Wn + A.inverseInertia * qn * qn), Vt = (1 + w.restitution) * Ue * Nr;
                    if (C *= Nr, Ue < m)
                      $.normalImpulse = 0;
                    else {
                      var ie = $.normalImpulse;
                      $.normalImpulse += Vt, $.normalImpulse > 0 && ($.normalImpulse = 0), Vt = $.normalImpulse - ie;
                    }
                    if (Ee < -g || Ee > g)
                      $.tangentImpulse = 0;
                    else {
                      var Yn = $.tangentImpulse;
                      $.tangentImpulse += C, $.tangentImpulse < -I && ($.tangentImpulse = -I), $.tangentImpulse > I && ($.tangentImpulse = I), C = $.tangentImpulse - Yn;
                    }
                    var sn = P * Vt + k * C, on = M * Vt + B * C;
                    x.isStatic || x.isSleeping || (x.positionPrev.x += sn * x.inverseMass, x.positionPrev.y += on * x.inverseMass, x.anglePrev += (Tt * on - Fe * sn) * x.inverseInertia), A.isStatic || A.isSleeping || (A.positionPrev.x -= sn * A.inverseMass, A.positionPrev.y -= on * A.inverseMass, A.anglePrev -= (Yt * on - Xt * sn) * A.inverseInertia);
                  }
                }
              }
            };
          })();
        },
        /* 19 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(9), a = r(0);
          (function() {
            s.create = function(l) {
              return a.extend({
                table: {},
                list: [],
                collisionStart: [],
                collisionActive: [],
                collisionEnd: []
              }, l);
            }, s.update = function(l, h, c) {
              var p = o.update, f = o.create, d = o.setActive, m = l.table, g = l.list, y = g.length, b = y, S = l.collisionStart, C = l.collisionEnd, I = l.collisionActive, T = h.length, R = 0, w = 0, v = 0, x, A, P;
              for (P = 0; P < T; P++)
                x = h[P], A = x.pair, A ? (A.isActive && (I[v++] = A), p(A, x, c)) : (A = f(x, c), m[A.id] = A, S[R++] = A, g[b++] = A);
              for (b = 0, y = g.length, P = 0; P < y; P++)
                A = g[P], A.timeUpdated >= c ? g[b++] = A : (d(A, !1, c), A.collision.bodyA.sleepCounter > 0 && A.collision.bodyB.sleepCounter > 0 ? g[b++] = A : (C[w++] = A, delete m[A.id]));
              g.length !== b && (g.length = b), S.length !== R && (S.length = R), C.length !== w && (C.length = w), I.length !== v && (I.length = v);
            }, s.clear = function(l) {
              return l.table = {}, l.list.length = 0, l.collisionStart.length = 0, l.collisionActive.length = 0, l.collisionEnd.length = 0, l;
            };
          })();
        },
        /* 20 */
        /***/
        function(e, n, r) {
          var s = e.exports = r(21);
          s.Axes = r(11), s.Bodies = r(12), s.Body = r(4), s.Bounds = r(1), s.Collision = r(8), s.Common = r(0), s.Composite = r(6), s.Composites = r(22), s.Constraint = r(10), s.Contact = r(16), s.Detector = r(13), s.Engine = r(17), s.Events = r(5), s.Grid = r(23), s.Mouse = r(14), s.MouseConstraint = r(24), s.Pair = r(9), s.Pairs = r(19), s.Plugin = r(15), s.Query = r(25), s.Render = r(26), s.Resolver = r(18), s.Runner = r(27), s.SAT = r(28), s.Sleeping = r(7), s.Svg = r(29), s.Vector = r(2), s.Vertices = r(3), s.World = r(30), s.Engine.run = s.Runner.run, s.Common.deprecated(s.Engine, "run", "Engine.run ➤ use Matter.Runner.run(engine) instead");
        },
        /* 21 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(15), a = r(0);
          (function() {
            s.name = "matter-js", s.version = "0.20.0", s.uses = [], s.used = [], s.use = function() {
              o.use(s, Array.prototype.slice.call(arguments));
            }, s.before = function(l, h) {
              return l = l.replace(/^Matter./, ""), a.chainPathBefore(s, l, h);
            }, s.after = function(l, h) {
              return l = l.replace(/^Matter./, ""), a.chainPathAfter(s, l, h);
            };
          })();
        },
        /* 22 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(6), a = r(10), l = r(0), h = r(4), c = r(12), p = l.deprecated;
          (function() {
            s.stack = function(f, d, m, g, y, b, S) {
              for (var C = o.create({ label: "Stack" }), I = f, T = d, R, w = 0, v = 0; v < g; v++) {
                for (var x = 0, A = 0; A < m; A++) {
                  var P = S(I, T, A, v, R, w);
                  if (P) {
                    var M = P.bounds.max.y - P.bounds.min.y, k = P.bounds.max.x - P.bounds.min.x;
                    M > x && (x = M), h.translate(P, { x: k * 0.5, y: M * 0.5 }), I = P.bounds.max.x + y, o.addBody(C, P), R = P, w += 1;
                  } else
                    I += y;
                }
                T += x + b, I = f;
              }
              return C;
            }, s.chain = function(f, d, m, g, y, b) {
              for (var S = f.bodies, C = 1; C < S.length; C++) {
                var I = S[C - 1], T = S[C], R = I.bounds.max.y - I.bounds.min.y, w = I.bounds.max.x - I.bounds.min.x, v = T.bounds.max.y - T.bounds.min.y, x = T.bounds.max.x - T.bounds.min.x, A = {
                  bodyA: I,
                  pointA: { x: w * d, y: R * m },
                  bodyB: T,
                  pointB: { x: x * g, y: v * y }
                }, P = l.extend(A, b);
                o.addConstraint(f, a.create(P));
              }
              return f.label += " Chain", f;
            }, s.mesh = function(f, d, m, g, y) {
              var b = f.bodies, S, C, I, T, R;
              for (S = 0; S < m; S++) {
                for (C = 1; C < d; C++)
                  I = b[C - 1 + S * d], T = b[C + S * d], o.addConstraint(f, a.create(l.extend({ bodyA: I, bodyB: T }, y)));
                if (S > 0)
                  for (C = 0; C < d; C++)
                    I = b[C + (S - 1) * d], T = b[C + S * d], o.addConstraint(f, a.create(l.extend({ bodyA: I, bodyB: T }, y))), g && C > 0 && (R = b[C - 1 + (S - 1) * d], o.addConstraint(f, a.create(l.extend({ bodyA: R, bodyB: T }, y)))), g && C < d - 1 && (R = b[C + 1 + (S - 1) * d], o.addConstraint(f, a.create(l.extend({ bodyA: R, bodyB: T }, y))));
              }
              return f.label += " Mesh", f;
            }, s.pyramid = function(f, d, m, g, y, b, S) {
              return s.stack(f, d, m, g, y, b, function(C, I, T, R, w, v) {
                var x = Math.min(g, Math.ceil(m / 2)), A = w ? w.bounds.max.x - w.bounds.min.x : 0;
                if (!(R > x)) {
                  R = x - R;
                  var P = R, M = m - 1 - R;
                  if (!(T < P || T > M)) {
                    v === 1 && h.translate(w, { x: (T + (m % 2 === 1 ? 1 : -1)) * A, y: 0 });
                    var k = w ? T * A : 0;
                    return S(f + k + T * y, I, T, R, w, v);
                  }
                }
              });
            }, s.newtonsCradle = function(f, d, m, g, y) {
              for (var b = o.create({ label: "Newtons Cradle" }), S = 0; S < m; S++) {
                var C = 1.9, I = c.circle(
                  f + S * (g * C),
                  d + y,
                  g,
                  { inertia: 1 / 0, restitution: 1, friction: 0, frictionAir: 1e-4, slop: 1 }
                ), T = a.create({ pointA: { x: f + S * (g * C), y: d }, bodyB: I });
                o.addBody(b, I), o.addConstraint(b, T);
              }
              return b;
            }, p(s, "newtonsCradle", "Composites.newtonsCradle ➤ moved to newtonsCradle example"), s.car = function(f, d, m, g, y) {
              var b = h.nextGroup(!0), S = 20, C = -m * 0.5 + S, I = m * 0.5 - S, T = 0, R = o.create({ label: "Car" }), w = c.rectangle(f, d, m, g, {
                collisionFilter: {
                  group: b
                },
                chamfer: {
                  radius: g * 0.5
                },
                density: 2e-4
              }), v = c.circle(f + C, d + T, y, {
                collisionFilter: {
                  group: b
                },
                friction: 0.8
              }), x = c.circle(f + I, d + T, y, {
                collisionFilter: {
                  group: b
                },
                friction: 0.8
              }), A = a.create({
                bodyB: w,
                pointB: { x: C, y: T },
                bodyA: v,
                stiffness: 1,
                length: 0
              }), P = a.create({
                bodyB: w,
                pointB: { x: I, y: T },
                bodyA: x,
                stiffness: 1,
                length: 0
              });
              return o.addBody(R, w), o.addBody(R, v), o.addBody(R, x), o.addConstraint(R, A), o.addConstraint(R, P), R;
            }, p(s, "car", "Composites.car ➤ moved to car example"), s.softBody = function(f, d, m, g, y, b, S, C, I, T) {
              I = l.extend({ inertia: 1 / 0 }, I), T = l.extend({ stiffness: 0.2, render: { type: "line", anchors: !1 } }, T);
              var R = s.stack(f, d, m, g, y, b, function(w, v) {
                return c.circle(w, v, C, I);
              });
              return s.mesh(R, m, g, S, T), R.label = "Soft Body", R;
            }, p(s, "softBody", "Composites.softBody ➤ moved to softBody and cloth examples");
          })();
        },
        /* 23 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(9), a = r(0), l = a.deprecated;
          (function() {
            s.create = function(h) {
              var c = {
                buckets: {},
                pairs: {},
                pairsList: [],
                bucketWidth: 48,
                bucketHeight: 48
              };
              return a.extend(c, h);
            }, s.update = function(h, c, p, f) {
              var d, m, g, y = p.world, b = h.buckets, S, C, I = !1;
              for (d = 0; d < c.length; d++) {
                var T = c[d];
                if (!(T.isSleeping && !f) && !(y.bounds && (T.bounds.max.x < y.bounds.min.x || T.bounds.min.x > y.bounds.max.x || T.bounds.max.y < y.bounds.min.y || T.bounds.min.y > y.bounds.max.y))) {
                  var R = s._getRegion(h, T);
                  if (!T.region || R.id !== T.region.id || f) {
                    (!T.region || f) && (T.region = R);
                    var w = s._regionUnion(R, T.region);
                    for (m = w.startCol; m <= w.endCol; m++)
                      for (g = w.startRow; g <= w.endRow; g++) {
                        C = s._getBucketId(m, g), S = b[C];
                        var v = m >= R.startCol && m <= R.endCol && g >= R.startRow && g <= R.endRow, x = m >= T.region.startCol && m <= T.region.endCol && g >= T.region.startRow && g <= T.region.endRow;
                        !v && x && x && S && s._bucketRemoveBody(h, S, T), (T.region === R || v && !x || f) && (S || (S = s._createBucket(b, C)), s._bucketAddBody(h, S, T));
                      }
                    T.region = R, I = !0;
                  }
                }
              }
              I && (h.pairsList = s._createActivePairsList(h));
            }, l(s, "update", "Grid.update ➤ replaced by Matter.Detector"), s.clear = function(h) {
              h.buckets = {}, h.pairs = {}, h.pairsList = [];
            }, l(s, "clear", "Grid.clear ➤ replaced by Matter.Detector"), s._regionUnion = function(h, c) {
              var p = Math.min(h.startCol, c.startCol), f = Math.max(h.endCol, c.endCol), d = Math.min(h.startRow, c.startRow), m = Math.max(h.endRow, c.endRow);
              return s._createRegion(p, f, d, m);
            }, s._getRegion = function(h, c) {
              var p = c.bounds, f = Math.floor(p.min.x / h.bucketWidth), d = Math.floor(p.max.x / h.bucketWidth), m = Math.floor(p.min.y / h.bucketHeight), g = Math.floor(p.max.y / h.bucketHeight);
              return s._createRegion(f, d, m, g);
            }, s._createRegion = function(h, c, p, f) {
              return {
                id: h + "," + c + "," + p + "," + f,
                startCol: h,
                endCol: c,
                startRow: p,
                endRow: f
              };
            }, s._getBucketId = function(h, c) {
              return "C" + h + "R" + c;
            }, s._createBucket = function(h, c) {
              var p = h[c] = [];
              return p;
            }, s._bucketAddBody = function(h, c, p) {
              var f = h.pairs, d = o.id, m = c.length, g;
              for (g = 0; g < m; g++) {
                var y = c[g];
                if (!(p.id === y.id || p.isStatic && y.isStatic)) {
                  var b = d(p, y), S = f[b];
                  S ? S[2] += 1 : f[b] = [p, y, 1];
                }
              }
              c.push(p);
            }, s._bucketRemoveBody = function(h, c, p) {
              var f = h.pairs, d = o.id, m;
              c.splice(a.indexOf(c, p), 1);
              var g = c.length;
              for (m = 0; m < g; m++) {
                var y = f[d(p, c[m])];
                y && (y[2] -= 1);
              }
            }, s._createActivePairsList = function(h) {
              var c, p = h.pairs, f = a.keys(p), d = f.length, m = [], g;
              for (g = 0; g < d; g++)
                c = p[f[g]], c[2] > 0 ? m.push(c) : delete p[f[g]];
              return m;
            };
          })();
        },
        /* 24 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(3), a = r(7), l = r(14), h = r(5), c = r(13), p = r(10), f = r(6), d = r(0), m = r(1);
          (function() {
            s.create = function(g, y) {
              var b = (g ? g.mouse : null) || (y ? y.mouse : null);
              b || (g && g.render && g.render.canvas ? b = l.create(g.render.canvas) : y && y.element ? b = l.create(y.element) : (b = l.create(), d.warn("MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected")));
              var S = p.create({
                label: "Mouse Constraint",
                pointA: b.position,
                pointB: { x: 0, y: 0 },
                length: 0.01,
                stiffness: 0.1,
                angularStiffness: 1,
                render: {
                  strokeStyle: "#90EE90",
                  lineWidth: 3
                }
              }), C = {
                type: "mouseConstraint",
                mouse: b,
                element: null,
                body: null,
                constraint: S,
                collisionFilter: {
                  category: 1,
                  mask: 4294967295,
                  group: 0
                }
              }, I = d.extend(C, y);
              return h.on(g, "beforeUpdate", function() {
                var T = f.allBodies(g.world);
                s.update(I, T), s._triggerEvents(I);
              }), I;
            }, s.update = function(g, y) {
              var b = g.mouse, S = g.constraint, C = g.body;
              if (b.button === 0) {
                if (S.bodyB)
                  a.set(S.bodyB, !1), S.pointA = b.position;
                else
                  for (var I = 0; I < y.length; I++)
                    if (C = y[I], m.contains(C.bounds, b.position) && c.canCollide(C.collisionFilter, g.collisionFilter))
                      for (var T = C.parts.length > 1 ? 1 : 0; T < C.parts.length; T++) {
                        var R = C.parts[T];
                        if (o.contains(R.vertices, b.position)) {
                          S.pointA = b.position, S.bodyB = g.body = C, S.pointB = { x: b.position.x - C.position.x, y: b.position.y - C.position.y }, S.angleB = C.angle, a.set(C, !1), h.trigger(g, "startdrag", { mouse: b, body: C });
                          break;
                        }
                      }
              } else
                S.bodyB = g.body = null, S.pointB = null, C && h.trigger(g, "enddrag", { mouse: b, body: C });
            }, s._triggerEvents = function(g) {
              var y = g.mouse, b = y.sourceEvents;
              b.mousemove && h.trigger(g, "mousemove", { mouse: y }), b.mousedown && h.trigger(g, "mousedown", { mouse: y }), b.mouseup && h.trigger(g, "mouseup", { mouse: y }), l.clearSourceEvents(y);
            };
          })();
        },
        /* 25 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(2), a = r(8), l = r(1), h = r(12), c = r(3);
          (function() {
            s.collides = function(p, f) {
              for (var d = [], m = f.length, g = p.bounds, y = a.collides, b = l.overlaps, S = 0; S < m; S++) {
                var C = f[S], I = C.parts.length, T = I === 1 ? 0 : 1;
                if (b(C.bounds, g))
                  for (var R = T; R < I; R++) {
                    var w = C.parts[R];
                    if (b(w.bounds, g)) {
                      var v = y(w, p);
                      if (v) {
                        d.push(v);
                        break;
                      }
                    }
                  }
              }
              return d;
            }, s.ray = function(p, f, d, m) {
              m = m || 1e-100;
              for (var g = o.angle(f, d), y = o.magnitude(o.sub(f, d)), b = (d.x + f.x) * 0.5, S = (d.y + f.y) * 0.5, C = h.rectangle(b, S, y, m, { angle: g }), I = s.collides(C, p), T = 0; T < I.length; T += 1) {
                var R = I[T];
                R.body = R.bodyB = R.bodyA;
              }
              return I;
            }, s.region = function(p, f, d) {
              for (var m = [], g = 0; g < p.length; g++) {
                var y = p[g], b = l.overlaps(y.bounds, f);
                (b && !d || !b && d) && m.push(y);
              }
              return m;
            }, s.point = function(p, f) {
              for (var d = [], m = 0; m < p.length; m++) {
                var g = p[m];
                if (l.contains(g.bounds, f))
                  for (var y = g.parts.length === 1 ? 0 : 1; y < g.parts.length; y++) {
                    var b = g.parts[y];
                    if (l.contains(b.bounds, f) && c.contains(b.vertices, f)) {
                      d.push(g);
                      break;
                    }
                  }
              }
              return d;
            };
          })();
        },
        /* 26 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(4), a = r(0), l = r(6), h = r(1), c = r(5), p = r(2), f = r(14);
          (function() {
            var d, m;
            typeof window < "u" && (d = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(T) {
              window.setTimeout(function() {
                T(a.now());
              }, 1e3 / 60);
            }, m = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), s._goodFps = 30, s._goodDelta = 1e3 / 60, s.create = function(T) {
              var R = {
                engine: null,
                element: null,
                canvas: null,
                mouse: null,
                frameRequestId: null,
                timing: {
                  historySize: 60,
                  delta: 0,
                  deltaHistory: [],
                  lastTime: 0,
                  lastTimestamp: 0,
                  lastElapsed: 0,
                  timestampElapsed: 0,
                  timestampElapsedHistory: [],
                  engineDeltaHistory: [],
                  engineElapsedHistory: [],
                  engineUpdatesHistory: [],
                  elapsedHistory: []
                },
                options: {
                  width: 800,
                  height: 600,
                  pixelRatio: 1,
                  background: "#14151f",
                  wireframeBackground: "#14151f",
                  wireframeStrokeStyle: "#bbb",
                  hasBounds: !!T.bounds,
                  enabled: !0,
                  wireframes: !0,
                  showSleeping: !0,
                  showDebug: !1,
                  showStats: !1,
                  showPerformance: !1,
                  showBounds: !1,
                  showVelocity: !1,
                  showCollisions: !1,
                  showSeparations: !1,
                  showAxes: !1,
                  showPositions: !1,
                  showAngleIndicator: !1,
                  showIds: !1,
                  showVertexNumbers: !1,
                  showConvexHulls: !1,
                  showInternalEdges: !1,
                  showMousePosition: !1
                }
              }, w = a.extend(R, T);
              return w.canvas && (w.canvas.width = w.options.width || w.canvas.width, w.canvas.height = w.options.height || w.canvas.height), w.mouse = T.mouse, w.engine = T.engine, w.canvas = w.canvas || b(w.options.width, w.options.height), w.context = w.canvas.getContext("2d"), w.textures = {}, w.bounds = w.bounds || {
                min: {
                  x: 0,
                  y: 0
                },
                max: {
                  x: w.canvas.width,
                  y: w.canvas.height
                }
              }, w.controller = s, w.options.showBroadphase = !1, w.options.pixelRatio !== 1 && s.setPixelRatio(w, w.options.pixelRatio), a.isElement(w.element) && w.element.appendChild(w.canvas), w;
            }, s.run = function(T) {
              (function R(w) {
                T.frameRequestId = d(R), g(T, w), s.world(T, w), T.context.setTransform(T.options.pixelRatio, 0, 0, T.options.pixelRatio, 0, 0), (T.options.showStats || T.options.showDebug) && s.stats(T, T.context, w), (T.options.showPerformance || T.options.showDebug) && s.performance(T, T.context, w), T.context.setTransform(1, 0, 0, 1, 0, 0);
              })();
            }, s.stop = function(T) {
              m(T.frameRequestId);
            }, s.setPixelRatio = function(T, R) {
              var w = T.options, v = T.canvas;
              R === "auto" && (R = S(v)), w.pixelRatio = R, v.setAttribute("data-pixel-ratio", R), v.width = w.width * R, v.height = w.height * R, v.style.width = w.width + "px", v.style.height = w.height + "px";
            }, s.setSize = function(T, R, w) {
              T.options.width = R, T.options.height = w, T.bounds.max.x = T.bounds.min.x + R, T.bounds.max.y = T.bounds.min.y + w, T.options.pixelRatio !== 1 ? s.setPixelRatio(T, T.options.pixelRatio) : (T.canvas.width = R, T.canvas.height = w);
            }, s.lookAt = function(T, R, w, v) {
              v = typeof v < "u" ? v : !0, R = a.isArray(R) ? R : [R], w = w || {
                x: 0,
                y: 0
              };
              for (var x = {
                min: { x: 1 / 0, y: 1 / 0 },
                max: { x: -1 / 0, y: -1 / 0 }
              }, A = 0; A < R.length; A += 1) {
                var P = R[A], M = P.bounds ? P.bounds.min : P.min || P.position || P, k = P.bounds ? P.bounds.max : P.max || P.position || P;
                M && k && (M.x < x.min.x && (x.min.x = M.x), k.x > x.max.x && (x.max.x = k.x), M.y < x.min.y && (x.min.y = M.y), k.y > x.max.y && (x.max.y = k.y));
              }
              var B = x.max.x - x.min.x + 2 * w.x, V = x.max.y - x.min.y + 2 * w.y, N = T.canvas.height, U = T.canvas.width, K = U / N, j = B / V, H = 1, pt = 1;
              j > K ? pt = j / K : H = K / j, T.options.hasBounds = !0, T.bounds.min.x = x.min.x, T.bounds.max.x = x.min.x + B * H, T.bounds.min.y = x.min.y, T.bounds.max.y = x.min.y + V * pt, v && (T.bounds.min.x += B * 0.5 - B * H * 0.5, T.bounds.max.x += B * 0.5 - B * H * 0.5, T.bounds.min.y += V * 0.5 - V * pt * 0.5, T.bounds.max.y += V * 0.5 - V * pt * 0.5), T.bounds.min.x -= w.x, T.bounds.max.x -= w.x, T.bounds.min.y -= w.y, T.bounds.max.y -= w.y, T.mouse && (f.setScale(T.mouse, {
                x: (T.bounds.max.x - T.bounds.min.x) / T.canvas.width,
                y: (T.bounds.max.y - T.bounds.min.y) / T.canvas.height
              }), f.setOffset(T.mouse, T.bounds.min));
            }, s.startViewTransform = function(T) {
              var R = T.bounds.max.x - T.bounds.min.x, w = T.bounds.max.y - T.bounds.min.y, v = R / T.options.width, x = w / T.options.height;
              T.context.setTransform(
                T.options.pixelRatio / v,
                0,
                0,
                T.options.pixelRatio / x,
                0,
                0
              ), T.context.translate(-T.bounds.min.x, -T.bounds.min.y);
            }, s.endViewTransform = function(T) {
              T.context.setTransform(T.options.pixelRatio, 0, 0, T.options.pixelRatio, 0, 0);
            }, s.world = function(T, R) {
              var w = a.now(), v = T.engine, x = v.world, A = T.canvas, P = T.context, M = T.options, k = T.timing, B = l.allBodies(x), V = l.allConstraints(x), N = M.wireframes ? M.wireframeBackground : M.background, U = [], K = [], j, H = {
                timestamp: v.timing.timestamp
              };
              if (c.trigger(T, "beforeRender", H), T.currentBackground !== N && I(T, N), P.globalCompositeOperation = "source-in", P.fillStyle = "transparent", P.fillRect(0, 0, A.width, A.height), P.globalCompositeOperation = "source-over", M.hasBounds) {
                for (j = 0; j < B.length; j++) {
                  var pt = B[j];
                  h.overlaps(pt.bounds, T.bounds) && U.push(pt);
                }
                for (j = 0; j < V.length; j++) {
                  var Q = V[j], J = Q.bodyA, bt = Q.bodyB, St = Q.pointA, $ = Q.pointB;
                  J && (St = p.add(J.position, Q.pointA)), bt && ($ = p.add(bt.position, Q.pointB)), !(!St || !$) && (h.contains(T.bounds, St) || h.contains(T.bounds, $)) && K.push(Q);
                }
                s.startViewTransform(T), T.mouse && (f.setScale(T.mouse, {
                  x: (T.bounds.max.x - T.bounds.min.x) / T.options.width,
                  y: (T.bounds.max.y - T.bounds.min.y) / T.options.height
                }), f.setOffset(T.mouse, T.bounds.min));
              } else
                K = V, U = B, T.options.pixelRatio !== 1 && T.context.setTransform(T.options.pixelRatio, 0, 0, T.options.pixelRatio, 0, 0);
              !M.wireframes || v.enableSleeping && M.showSleeping ? s.bodies(T, U, P) : (M.showConvexHulls && s.bodyConvexHulls(T, U, P), s.bodyWireframes(T, U, P)), M.showBounds && s.bodyBounds(T, U, P), (M.showAxes || M.showAngleIndicator) && s.bodyAxes(T, U, P), M.showPositions && s.bodyPositions(T, U, P), M.showVelocity && s.bodyVelocity(T, U, P), M.showIds && s.bodyIds(T, U, P), M.showSeparations && s.separations(T, v.pairs.list, P), M.showCollisions && s.collisions(T, v.pairs.list, P), M.showVertexNumbers && s.vertexNumbers(T, U, P), M.showMousePosition && s.mousePosition(T, T.mouse, P), s.constraints(K, P), M.hasBounds && s.endViewTransform(T), c.trigger(T, "afterRender", H), k.lastElapsed = a.now() - w;
            }, s.stats = function(T, R, w) {
              for (var v = T.engine, x = v.world, A = l.allBodies(x), P = 0, M = 55, k = 44, B = 0, V = 0, N = 0; N < A.length; N += 1)
                P += A[N].parts.length;
              var U = {
                Part: P,
                Body: A.length,
                Cons: l.allConstraints(x).length,
                Comp: l.allComposites(x).length,
                Pair: v.pairs.list.length
              };
              R.fillStyle = "#0e0f19", R.fillRect(B, V, M * 5.5, k), R.font = "12px Arial", R.textBaseline = "top", R.textAlign = "right";
              for (var K in U) {
                var j = U[K];
                R.fillStyle = "#aaa", R.fillText(K, B + M, V + 8), R.fillStyle = "#eee", R.fillText(j, B + M, V + 26), B += M;
              }
            }, s.performance = function(T, R) {
              var w = T.engine, v = T.timing, x = v.deltaHistory, A = v.elapsedHistory, P = v.timestampElapsedHistory, M = v.engineDeltaHistory, k = v.engineUpdatesHistory, B = v.engineElapsedHistory, V = w.timing.lastUpdatesPerFrame, N = w.timing.lastDelta, U = y(x), K = y(A), j = y(M), H = y(k), pt = y(B), Q = y(P), J = Q / U || 0, bt = Math.round(U / N), St = 1e3 / U || 0, $ = 4, Ht = 12, Tt = 60, Fe = 34, Yt = 10, Xt = 69;
              R.fillStyle = "#0e0f19", R.fillRect(0, 50, Ht * 5 + Tt * 6 + 22, Fe), s.status(
                R,
                Yt,
                Xt,
                Tt,
                $,
                x.length,
                Math.round(St) + " fps",
                St / s._goodFps,
                function(Et) {
                  return x[Et] / U - 1;
                }
              ), s.status(
                R,
                Yt + Ht + Tt,
                Xt,
                Tt,
                $,
                M.length,
                N.toFixed(2) + " dt",
                s._goodDelta / N,
                function(Et) {
                  return M[Et] / j - 1;
                }
              ), s.status(
                R,
                Yt + (Ht + Tt) * 2,
                Xt,
                Tt,
                $,
                k.length,
                V + " upf",
                Math.pow(a.clamp(H / bt || 1, 0, 1), 4),
                function(Et) {
                  return k[Et] / H - 1;
                }
              ), s.status(
                R,
                Yt + (Ht + Tt) * 3,
                Xt,
                Tt,
                $,
                B.length,
                pt.toFixed(2) + " ut",
                1 - V * pt / s._goodFps,
                function(Et) {
                  return B[Et] / pt - 1;
                }
              ), s.status(
                R,
                Yt + (Ht + Tt) * 4,
                Xt,
                Tt,
                $,
                A.length,
                K.toFixed(2) + " rt",
                1 - K / s._goodFps,
                function(Et) {
                  return A[Et] / K - 1;
                }
              ), s.status(
                R,
                Yt + (Ht + Tt) * 5,
                Xt,
                Tt,
                $,
                P.length,
                J.toFixed(2) + " x",
                J * J * J,
                function(Et) {
                  return (P[Et] / x[Et] / J || 0) - 1;
                }
              );
            }, s.status = function(T, R, w, v, x, A, P, M, k) {
              T.strokeStyle = "#888", T.fillStyle = "#444", T.lineWidth = 1, T.fillRect(R, w + 7, v, 1), T.beginPath(), T.moveTo(R, w + 7 - x * a.clamp(0.4 * k(0), -2, 2));
              for (var B = 0; B < v; B += 1)
                T.lineTo(R + B, w + 7 - (B < A ? x * a.clamp(0.4 * k(B), -2, 2) : 0));
              T.stroke(), T.fillStyle = "hsl(" + a.clamp(25 + 95 * M, 0, 120) + ",100%,60%)", T.fillRect(R, w - 7, 4, 4), T.font = "12px Arial", T.textBaseline = "middle", T.textAlign = "right", T.fillStyle = "#eee", T.fillText(P, R + v, w - 5);
            }, s.constraints = function(T, R) {
              for (var w = R, v = 0; v < T.length; v++) {
                var x = T[v];
                if (!(!x.render.visible || !x.pointA || !x.pointB)) {
                  var A = x.bodyA, P = x.bodyB, M, k;
                  if (A ? M = p.add(A.position, x.pointA) : M = x.pointA, x.render.type === "pin")
                    w.beginPath(), w.arc(M.x, M.y, 3, 0, 2 * Math.PI), w.closePath();
                  else {
                    if (P ? k = p.add(P.position, x.pointB) : k = x.pointB, w.beginPath(), w.moveTo(M.x, M.y), x.render.type === "spring")
                      for (var B = p.sub(k, M), V = p.perp(p.normalise(B)), N = Math.ceil(a.clamp(x.length / 5, 12, 20)), U, K = 1; K < N; K += 1)
                        U = K % 2 === 0 ? 1 : -1, w.lineTo(
                          M.x + B.x * (K / N) + V.x * U * 4,
                          M.y + B.y * (K / N) + V.y * U * 4
                        );
                    w.lineTo(k.x, k.y);
                  }
                  x.render.lineWidth && (w.lineWidth = x.render.lineWidth, w.strokeStyle = x.render.strokeStyle, w.stroke()), x.render.anchors && (w.fillStyle = x.render.strokeStyle, w.beginPath(), w.arc(M.x, M.y, 3, 0, 2 * Math.PI), w.arc(k.x, k.y, 3, 0, 2 * Math.PI), w.closePath(), w.fill());
                }
              }
            }, s.bodies = function(T, R, w) {
              var v = w;
              T.engine;
              var x = T.options, A = x.showInternalEdges || !x.wireframes, P, M, k, B;
              for (k = 0; k < R.length; k++)
                if (P = R[k], !!P.render.visible) {
                  for (B = P.parts.length > 1 ? 1 : 0; B < P.parts.length; B++)
                    if (M = P.parts[B], !!M.render.visible) {
                      if (x.showSleeping && P.isSleeping ? v.globalAlpha = 0.5 * M.render.opacity : M.render.opacity !== 1 && (v.globalAlpha = M.render.opacity), M.render.sprite && M.render.sprite.texture && !x.wireframes) {
                        var V = M.render.sprite, N = C(T, V.texture);
                        v.translate(M.position.x, M.position.y), v.rotate(M.angle), v.drawImage(
                          N,
                          N.width * -V.xOffset * V.xScale,
                          N.height * -V.yOffset * V.yScale,
                          N.width * V.xScale,
                          N.height * V.yScale
                        ), v.rotate(-M.angle), v.translate(-M.position.x, -M.position.y);
                      } else {
                        if (M.circleRadius)
                          v.beginPath(), v.arc(M.position.x, M.position.y, M.circleRadius, 0, 2 * Math.PI);
                        else {
                          v.beginPath(), v.moveTo(M.vertices[0].x, M.vertices[0].y);
                          for (var U = 1; U < M.vertices.length; U++)
                            !M.vertices[U - 1].isInternal || A ? v.lineTo(M.vertices[U].x, M.vertices[U].y) : v.moveTo(M.vertices[U].x, M.vertices[U].y), M.vertices[U].isInternal && !A && v.moveTo(M.vertices[(U + 1) % M.vertices.length].x, M.vertices[(U + 1) % M.vertices.length].y);
                          v.lineTo(M.vertices[0].x, M.vertices[0].y), v.closePath();
                        }
                        x.wireframes ? (v.lineWidth = 1, v.strokeStyle = T.options.wireframeStrokeStyle, v.stroke()) : (v.fillStyle = M.render.fillStyle, M.render.lineWidth && (v.lineWidth = M.render.lineWidth, v.strokeStyle = M.render.strokeStyle, v.stroke()), v.fill());
                      }
                      v.globalAlpha = 1;
                    }
                }
            }, s.bodyWireframes = function(T, R, w) {
              var v = w, x = T.options.showInternalEdges, A, P, M, k, B;
              for (v.beginPath(), M = 0; M < R.length; M++)
                if (A = R[M], !!A.render.visible)
                  for (B = A.parts.length > 1 ? 1 : 0; B < A.parts.length; B++) {
                    for (P = A.parts[B], v.moveTo(P.vertices[0].x, P.vertices[0].y), k = 1; k < P.vertices.length; k++)
                      !P.vertices[k - 1].isInternal || x ? v.lineTo(P.vertices[k].x, P.vertices[k].y) : v.moveTo(P.vertices[k].x, P.vertices[k].y), P.vertices[k].isInternal && !x && v.moveTo(P.vertices[(k + 1) % P.vertices.length].x, P.vertices[(k + 1) % P.vertices.length].y);
                    v.lineTo(P.vertices[0].x, P.vertices[0].y);
                  }
              v.lineWidth = 1, v.strokeStyle = T.options.wireframeStrokeStyle, v.stroke();
            }, s.bodyConvexHulls = function(T, R, w) {
              var v = w, x, A, P;
              for (v.beginPath(), A = 0; A < R.length; A++)
                if (x = R[A], !(!x.render.visible || x.parts.length === 1)) {
                  for (v.moveTo(x.vertices[0].x, x.vertices[0].y), P = 1; P < x.vertices.length; P++)
                    v.lineTo(x.vertices[P].x, x.vertices[P].y);
                  v.lineTo(x.vertices[0].x, x.vertices[0].y);
                }
              v.lineWidth = 1, v.strokeStyle = "rgba(255,255,255,0.2)", v.stroke();
            }, s.vertexNumbers = function(T, R, w) {
              var v = w, x, A, P;
              for (x = 0; x < R.length; x++) {
                var M = R[x].parts;
                for (P = M.length > 1 ? 1 : 0; P < M.length; P++) {
                  var k = M[P];
                  for (A = 0; A < k.vertices.length; A++)
                    v.fillStyle = "rgba(255,255,255,0.2)", v.fillText(x + "_" + A, k.position.x + (k.vertices[A].x - k.position.x) * 0.8, k.position.y + (k.vertices[A].y - k.position.y) * 0.8);
                }
              }
            }, s.mousePosition = function(T, R, w) {
              var v = w;
              v.fillStyle = "rgba(255,255,255,0.8)", v.fillText(R.position.x + "  " + R.position.y, R.position.x + 5, R.position.y - 5);
            }, s.bodyBounds = function(T, R, w) {
              var v = w;
              T.engine;
              var x = T.options;
              v.beginPath();
              for (var A = 0; A < R.length; A++) {
                var P = R[A];
                if (P.render.visible)
                  for (var M = R[A].parts, k = M.length > 1 ? 1 : 0; k < M.length; k++) {
                    var B = M[k];
                    v.rect(B.bounds.min.x, B.bounds.min.y, B.bounds.max.x - B.bounds.min.x, B.bounds.max.y - B.bounds.min.y);
                  }
              }
              x.wireframes ? v.strokeStyle = "rgba(255,255,255,0.08)" : v.strokeStyle = "rgba(0,0,0,0.1)", v.lineWidth = 1, v.stroke();
            }, s.bodyAxes = function(T, R, w) {
              var v = w;
              T.engine;
              var x = T.options, A, P, M, k;
              for (v.beginPath(), P = 0; P < R.length; P++) {
                var B = R[P], V = B.parts;
                if (B.render.visible)
                  if (x.showAxes)
                    for (M = V.length > 1 ? 1 : 0; M < V.length; M++)
                      for (A = V[M], k = 0; k < A.axes.length; k++) {
                        var N = A.axes[k];
                        v.moveTo(A.position.x, A.position.y), v.lineTo(A.position.x + N.x * 20, A.position.y + N.y * 20);
                      }
                  else
                    for (M = V.length > 1 ? 1 : 0; M < V.length; M++)
                      for (A = V[M], k = 0; k < A.axes.length; k++)
                        v.moveTo(A.position.x, A.position.y), v.lineTo(
                          (A.vertices[0].x + A.vertices[A.vertices.length - 1].x) / 2,
                          (A.vertices[0].y + A.vertices[A.vertices.length - 1].y) / 2
                        );
              }
              x.wireframes ? (v.strokeStyle = "indianred", v.lineWidth = 1) : (v.strokeStyle = "rgba(255, 255, 255, 0.4)", v.globalCompositeOperation = "overlay", v.lineWidth = 2), v.stroke(), v.globalCompositeOperation = "source-over";
            }, s.bodyPositions = function(T, R, w) {
              var v = w;
              T.engine;
              var x = T.options, A, P, M, k;
              for (v.beginPath(), M = 0; M < R.length; M++)
                if (A = R[M], !!A.render.visible)
                  for (k = 0; k < A.parts.length; k++)
                    P = A.parts[k], v.arc(P.position.x, P.position.y, 3, 0, 2 * Math.PI, !1), v.closePath();
              for (x.wireframes ? v.fillStyle = "indianred" : v.fillStyle = "rgba(0,0,0,0.5)", v.fill(), v.beginPath(), M = 0; M < R.length; M++)
                A = R[M], A.render.visible && (v.arc(A.positionPrev.x, A.positionPrev.y, 2, 0, 2 * Math.PI, !1), v.closePath());
              v.fillStyle = "rgba(255,165,0,0.8)", v.fill();
            }, s.bodyVelocity = function(T, R, w) {
              var v = w;
              v.beginPath();
              for (var x = 0; x < R.length; x++) {
                var A = R[x];
                if (A.render.visible) {
                  var P = o.getVelocity(A);
                  v.moveTo(A.position.x, A.position.y), v.lineTo(A.position.x + P.x, A.position.y + P.y);
                }
              }
              v.lineWidth = 3, v.strokeStyle = "cornflowerblue", v.stroke();
            }, s.bodyIds = function(T, R, w) {
              var v = w, x, A;
              for (x = 0; x < R.length; x++)
                if (R[x].render.visible) {
                  var P = R[x].parts;
                  for (A = P.length > 1 ? 1 : 0; A < P.length; A++) {
                    var M = P[A];
                    v.font = "12px Arial", v.fillStyle = "rgba(255,255,255,0.5)", v.fillText(M.id, M.position.x + 10, M.position.y - 10);
                  }
                }
            }, s.collisions = function(T, R, w) {
              var v = w, x = T.options, A, P, M, k;
              for (v.beginPath(), M = 0; M < R.length; M++)
                if (A = R[M], !!A.isActive)
                  for (P = A.collision, k = 0; k < A.contactCount; k++) {
                    var B = A.contacts[k], V = B.vertex;
                    v.rect(V.x - 1.5, V.y - 1.5, 3.5, 3.5);
                  }
              for (x.wireframes ? v.fillStyle = "rgba(255,255,255,0.7)" : v.fillStyle = "orange", v.fill(), v.beginPath(), M = 0; M < R.length; M++)
                if (A = R[M], !!A.isActive && (P = A.collision, A.contactCount > 0)) {
                  var N = A.contacts[0].vertex.x, U = A.contacts[0].vertex.y;
                  A.contactCount === 2 && (N = (A.contacts[0].vertex.x + A.contacts[1].vertex.x) / 2, U = (A.contacts[0].vertex.y + A.contacts[1].vertex.y) / 2), P.bodyB === P.supports[0].body || P.bodyA.isStatic === !0 ? v.moveTo(N - P.normal.x * 8, U - P.normal.y * 8) : v.moveTo(N + P.normal.x * 8, U + P.normal.y * 8), v.lineTo(N, U);
                }
              x.wireframes ? v.strokeStyle = "rgba(255,165,0,0.7)" : v.strokeStyle = "orange", v.lineWidth = 1, v.stroke();
            }, s.separations = function(T, R, w) {
              var v = w, x = T.options, A, P, M, k, B;
              for (v.beginPath(), B = 0; B < R.length; B++)
                if (A = R[B], !!A.isActive) {
                  P = A.collision, M = P.bodyA, k = P.bodyB;
                  var V = 1;
                  !k.isStatic && !M.isStatic && (V = 0.5), k.isStatic && (V = 0), v.moveTo(k.position.x, k.position.y), v.lineTo(k.position.x - P.penetration.x * V, k.position.y - P.penetration.y * V), V = 1, !k.isStatic && !M.isStatic && (V = 0.5), M.isStatic && (V = 0), v.moveTo(M.position.x, M.position.y), v.lineTo(M.position.x + P.penetration.x * V, M.position.y + P.penetration.y * V);
                }
              x.wireframes ? v.strokeStyle = "rgba(255,165,0,0.5)" : v.strokeStyle = "orange", v.stroke();
            }, s.inspector = function(T, R) {
              T.engine;
              var w = T.selected, v = T.render, x = v.options, A;
              if (x.hasBounds) {
                var P = v.bounds.max.x - v.bounds.min.x, M = v.bounds.max.y - v.bounds.min.y, k = P / v.options.width, B = M / v.options.height;
                R.scale(1 / k, 1 / B), R.translate(-v.bounds.min.x, -v.bounds.min.y);
              }
              for (var V = 0; V < w.length; V++) {
                var N = w[V].data;
                switch (R.translate(0.5, 0.5), R.lineWidth = 1, R.strokeStyle = "rgba(255,165,0,0.9)", R.setLineDash([1, 2]), N.type) {
                  case "body":
                    A = N.bounds, R.beginPath(), R.rect(
                      Math.floor(A.min.x - 3),
                      Math.floor(A.min.y - 3),
                      Math.floor(A.max.x - A.min.x + 6),
                      Math.floor(A.max.y - A.min.y + 6)
                    ), R.closePath(), R.stroke();
                    break;
                  case "constraint":
                    var U = N.pointA;
                    N.bodyA && (U = N.pointB), R.beginPath(), R.arc(U.x, U.y, 10, 0, 2 * Math.PI), R.closePath(), R.stroke();
                    break;
                }
                R.setLineDash([]), R.translate(-0.5, -0.5);
              }
              T.selectStart !== null && (R.translate(0.5, 0.5), R.lineWidth = 1, R.strokeStyle = "rgba(255,165,0,0.6)", R.fillStyle = "rgba(255,165,0,0.1)", A = T.selectBounds, R.beginPath(), R.rect(
                Math.floor(A.min.x),
                Math.floor(A.min.y),
                Math.floor(A.max.x - A.min.x),
                Math.floor(A.max.y - A.min.y)
              ), R.closePath(), R.stroke(), R.fill(), R.translate(-0.5, -0.5)), x.hasBounds && R.setTransform(1, 0, 0, 1, 0, 0);
            };
            var g = function(T, R) {
              var w = T.engine, v = T.timing, x = v.historySize, A = w.timing.timestamp;
              v.delta = R - v.lastTime || s._goodDelta, v.lastTime = R, v.timestampElapsed = A - v.lastTimestamp || 0, v.lastTimestamp = A, v.deltaHistory.unshift(v.delta), v.deltaHistory.length = Math.min(v.deltaHistory.length, x), v.engineDeltaHistory.unshift(w.timing.lastDelta), v.engineDeltaHistory.length = Math.min(v.engineDeltaHistory.length, x), v.timestampElapsedHistory.unshift(v.timestampElapsed), v.timestampElapsedHistory.length = Math.min(v.timestampElapsedHistory.length, x), v.engineUpdatesHistory.unshift(w.timing.lastUpdatesPerFrame), v.engineUpdatesHistory.length = Math.min(v.engineUpdatesHistory.length, x), v.engineElapsedHistory.unshift(w.timing.lastElapsed), v.engineElapsedHistory.length = Math.min(v.engineElapsedHistory.length, x), v.elapsedHistory.unshift(v.lastElapsed), v.elapsedHistory.length = Math.min(v.elapsedHistory.length, x);
            }, y = function(T) {
              for (var R = 0, w = 0; w < T.length; w += 1)
                R += T[w];
              return R / T.length || 0;
            }, b = function(T, R) {
              var w = document.createElement("canvas");
              return w.width = T, w.height = R, w.oncontextmenu = function() {
                return !1;
              }, w.onselectstart = function() {
                return !1;
              }, w;
            }, S = function(T) {
              var R = T.getContext("2d"), w = window.devicePixelRatio || 1, v = R.webkitBackingStorePixelRatio || R.mozBackingStorePixelRatio || R.msBackingStorePixelRatio || R.oBackingStorePixelRatio || R.backingStorePixelRatio || 1;
              return w / v;
            }, C = function(T, R) {
              var w = T.textures[R];
              return w || (w = T.textures[R] = new Image(), w.src = R, w);
            }, I = function(T, R) {
              var w = R;
              /(jpg|gif|png)$/.test(R) && (w = "url(" + R + ")"), T.canvas.style.background = w, T.canvas.style.backgroundSize = "contain", T.currentBackground = R;
            };
          })();
        },
        /* 27 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(5), a = r(17), l = r(0);
          (function() {
            s._maxFrameDelta = 1e3 / 15, s._frameDeltaFallback = 1e3 / 60, s._timeBufferMargin = 1.5, s._elapsedNextEstimate = 1, s._smoothingLowerBound = 0.1, s._smoothingUpperBound = 0.9, s.create = function(c) {
              var p = {
                delta: 16.666666666666668,
                frameDelta: null,
                frameDeltaSmoothing: !0,
                frameDeltaSnapping: !0,
                frameDeltaHistory: [],
                frameDeltaHistorySize: 100,
                frameRequestId: null,
                timeBuffer: 0,
                timeLastTick: null,
                maxUpdates: null,
                maxFrameTime: 33.333333333333336,
                lastUpdatesDeferred: 0,
                enabled: !0
              }, f = l.extend(p, c);
              return f.fps = 0, f;
            }, s.run = function(c, p) {
              return c.timeBuffer = s._frameDeltaFallback, function f(d) {
                c.frameRequestId = s._onNextFrame(c, f), d && c.enabled && s.tick(c, p, d);
              }(), c;
            }, s.tick = function(c, p, f) {
              var d = l.now(), m = c.delta, g = 0, y = f - c.timeLastTick;
              if ((!y || !c.timeLastTick || y > Math.max(s._maxFrameDelta, c.maxFrameTime)) && (y = c.frameDelta || s._frameDeltaFallback), c.frameDeltaSmoothing) {
                c.frameDeltaHistory.push(y), c.frameDeltaHistory = c.frameDeltaHistory.slice(-c.frameDeltaHistorySize);
                var b = c.frameDeltaHistory.slice(0).sort(), S = c.frameDeltaHistory.slice(
                  b.length * s._smoothingLowerBound,
                  b.length * s._smoothingUpperBound
                ), C = h(S);
                y = C || y;
              }
              c.frameDeltaSnapping && (y = 1e3 / Math.round(1e3 / y)), c.frameDelta = y, c.timeLastTick = f, c.timeBuffer += c.frameDelta, c.timeBuffer = l.clamp(
                c.timeBuffer,
                0,
                c.frameDelta + m * s._timeBufferMargin
              ), c.lastUpdatesDeferred = 0;
              var I = c.maxUpdates || Math.ceil(c.maxFrameTime / m), T = {
                timestamp: p.timing.timestamp
              };
              o.trigger(c, "beforeTick", T), o.trigger(c, "tick", T);
              for (var R = l.now(); m > 0 && c.timeBuffer >= m * s._timeBufferMargin; ) {
                o.trigger(c, "beforeUpdate", T), a.update(p, m), o.trigger(c, "afterUpdate", T), c.timeBuffer -= m, g += 1;
                var w = l.now() - d, v = l.now() - R, x = w + s._elapsedNextEstimate * v / g;
                if (g >= I || x > c.maxFrameTime) {
                  c.lastUpdatesDeferred = Math.round(Math.max(0, c.timeBuffer / m - s._timeBufferMargin));
                  break;
                }
              }
              p.timing.lastUpdatesPerFrame = g, o.trigger(c, "afterTick", T), c.frameDeltaHistory.length >= 100 && (c.lastUpdatesDeferred && Math.round(c.frameDelta / m) > I ? l.warnOnce("Matter.Runner: runner reached runner.maxUpdates, see docs.") : c.lastUpdatesDeferred && l.warnOnce("Matter.Runner: runner reached runner.maxFrameTime, see docs."), typeof c.isFixed < "u" && l.warnOnce("Matter.Runner: runner.isFixed is now redundant, see docs."), (c.deltaMin || c.deltaMax) && l.warnOnce("Matter.Runner: runner.deltaMin and runner.deltaMax were removed, see docs."), c.fps !== 0 && l.warnOnce("Matter.Runner: runner.fps was replaced by runner.delta, see docs."));
            }, s.stop = function(c) {
              s._cancelNextFrame(c);
            }, s._onNextFrame = function(c, p) {
              if (typeof window < "u" && window.requestAnimationFrame)
                c.frameRequestId = window.requestAnimationFrame(p);
              else
                throw new Error("Matter.Runner: missing required global window.requestAnimationFrame.");
              return c.frameRequestId;
            }, s._cancelNextFrame = function(c) {
              if (typeof window < "u" && window.cancelAnimationFrame)
                window.cancelAnimationFrame(c.frameRequestId);
              else
                throw new Error("Matter.Runner: missing required global window.cancelAnimationFrame.");
            };
            var h = function(c) {
              for (var p = 0, f = c.length, d = 0; d < f; d += 1)
                p += c[d];
              return p / f || 0;
            };
          })();
        },
        /* 28 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(8), a = r(0), l = a.deprecated;
          (function() {
            s.collides = function(h, c) {
              return o.collides(h, c);
            }, l(s, "collides", "SAT.collides ➤ replaced by Collision.collides");
          })();
        },
        /* 29 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s, r(1);
          var o = r(0);
          (function() {
            s.pathToVertices = function(a, l) {
              typeof window < "u" && !("SVGPathSeg" in window) && o.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");
              var h, c, p, f, d, m, g, y, b, S, C = [], I, T, R = 0, w = 0, v = 0;
              l = l || 15;
              var x = function(P, M, k) {
                var B = k % 2 === 1 && k > 1;
                if (!b || P != b.x || M != b.y) {
                  b && B ? (I = b.x, T = b.y) : (I = 0, T = 0);
                  var V = {
                    x: I + P,
                    y: T + M
                  };
                  (B || !b) && (b = V), C.push(V), w = I + P, v = T + M;
                }
              }, A = function(P) {
                var M = P.pathSegTypeAsLetter.toUpperCase();
                if (M !== "Z") {
                  switch (M) {
                    case "M":
                    case "L":
                    case "T":
                    case "C":
                    case "S":
                    case "Q":
                      w = P.x, v = P.y;
                      break;
                    case "H":
                      w = P.x;
                      break;
                    case "V":
                      v = P.y;
                      break;
                  }
                  x(w, v, P.pathSegType);
                }
              };
              for (s._svgPathToAbsolute(a), p = a.getTotalLength(), m = [], h = 0; h < a.pathSegList.numberOfItems; h += 1)
                m.push(a.pathSegList.getItem(h));
              for (g = m.concat(); R < p; ) {
                if (S = a.getPathSegAtLength(R), d = m[S], d != y) {
                  for (; g.length && g[0] != d; )
                    A(g.shift());
                  y = d;
                }
                switch (d.pathSegTypeAsLetter.toUpperCase()) {
                  case "C":
                  case "T":
                  case "S":
                  case "Q":
                  case "A":
                    f = a.getPointAtLength(R), x(f.x, f.y, 0);
                    break;
                }
                R += l;
              }
              for (h = 0, c = g.length; h < c; ++h)
                A(g[h]);
              return C;
            }, s._svgPathToAbsolute = function(a) {
              for (var l, h, c, p, f, d, m = a.pathSegList, g = 0, y = 0, b = m.numberOfItems, S = 0; S < b; ++S) {
                var C = m.getItem(S), I = C.pathSegTypeAsLetter;
                if (/[MLHVCSQTA]/.test(I))
                  "x" in C && (g = C.x), "y" in C && (y = C.y);
                else
                  switch ("x1" in C && (c = g + C.x1), "x2" in C && (f = g + C.x2), "y1" in C && (p = y + C.y1), "y2" in C && (d = y + C.y2), "x" in C && (g += C.x), "y" in C && (y += C.y), I) {
                    case "m":
                      m.replaceItem(a.createSVGPathSegMovetoAbs(g, y), S);
                      break;
                    case "l":
                      m.replaceItem(a.createSVGPathSegLinetoAbs(g, y), S);
                      break;
                    case "h":
                      m.replaceItem(a.createSVGPathSegLinetoHorizontalAbs(g), S);
                      break;
                    case "v":
                      m.replaceItem(a.createSVGPathSegLinetoVerticalAbs(y), S);
                      break;
                    case "c":
                      m.replaceItem(a.createSVGPathSegCurvetoCubicAbs(g, y, c, p, f, d), S);
                      break;
                    case "s":
                      m.replaceItem(a.createSVGPathSegCurvetoCubicSmoothAbs(g, y, f, d), S);
                      break;
                    case "q":
                      m.replaceItem(a.createSVGPathSegCurvetoQuadraticAbs(g, y, c, p), S);
                      break;
                    case "t":
                      m.replaceItem(a.createSVGPathSegCurvetoQuadraticSmoothAbs(g, y), S);
                      break;
                    case "a":
                      m.replaceItem(a.createSVGPathSegArcAbs(g, y, C.r1, C.r2, C.angle, C.largeArcFlag, C.sweepFlag), S);
                      break;
                    case "z":
                    case "Z":
                      g = l, y = h;
                      break;
                  }
                (I == "M" || I == "m") && (l = g, h = y);
              }
            };
          })();
        },
        /* 30 */
        /***/
        function(e, n, r) {
          var s = {};
          e.exports = s;
          var o = r(6);
          r(0), function() {
            s.create = o.create, s.add = o.add, s.remove = o.remove, s.clear = o.clear, s.addComposite = o.addComposite, s.addBody = o.addBody, s.addConstraint = o.addConstraint;
          }();
        }
        /******/
      ])
    );
  });
})(Hg);
var ai = Hg.exports;
let Tn;
const ar = /* @__PURE__ */ new Map(), Go = /* @__PURE__ */ new Map(), zc = /* @__PURE__ */ new Map();
let Ro = 0;
const Uw = () => {
  Tn = ai.Engine.create(), ai.Events.on(Tn, "collisionStart", (i) => {
    i.pairs.forEach((t) => {
      var e, n;
      const { bodyA: r, bodyB: s } = t, o = ar.get(r.label), a = ar.get(s.label);
      if (!o || !a) return;
      const l = [o, a].find((c) => c.surface), h = [o, a].find((c) => !c.surface);
      h && (l ? Go.set(
        h.target.matterBody.label,
        Math.floor(Ep(l).y1)
      ) : ((e = o.onCollision) == null || e.call(o, a.target), (n = a.onCollision) == null || n.call(a, o.target)));
    });
  }), ai.Events.on(Tn, "collisionEnd", (i) => {
    i.pairs.forEach((t) => {
      const { bodyA: e, bodyB: n } = t, r = ar.get(e.label), s = ar.get(n.label);
      if (!r || !s) return;
      const o = [r, s].find((l) => l.surface), a = [r, s].find((l) => !l.surface);
      a && o && Go.delete(a.target.matterBody.label);
    });
  }), ai.Events.on(Tn, "afterUpdate", () => {
    zc.forEach((i) => {
      var t;
      if (!i.target.matterBody) return;
      const e = Ep(i), n = (Go.get(i.target.matterBody.label) ?? -1 / 0) >= Math.floor(e.y2);
      (t = i.onUpdatePosition) == null || t.call(i, e.x1, e.y1, n);
    });
  });
}, zw = (i) => {
  ai.Engine.update(Tn, i);
}, Na = (i) => {
  if (i.rectangle)
    i.target.matterBody = ai.Bodies.rectangle(
      i.rectangle.x + i.rectangle.width / 2,
      i.rectangle.y + i.rectangle.height / 2,
      i.rectangle.width,
      i.rectangle.height,
      Tp(i)
    );
  else if (i.circle)
    i.target.matterBody = ai.Bodies.circle(
      i.circle.x,
      i.circle.y,
      i.circle.radius,
      Tp(i)
    );
  else
    throw new Error("No body specification provided");
  ar.set(i.target.matterBody.label, i), i.onUpdatePosition && zc.set(i.target.matterBody.label, i), ai.Composite.add(Tn.world, i.target.matterBody), i.movement && jc(i.target, i.movement);
}, jw = (i) => {
  i.matterBody && (ai.Composite.remove(Tn.world, i.matterBody), ar.delete(i.matterBody.label), Go.delete(i.matterBody.label), zc.delete(i.matterBody.label));
}, jc = (i, t) => {
  i.matterBody && t.linearMovement && ai.Body.setVelocity(i.matterBody, t.linearMovement.velocity);
}, Sp = (i, t, e) => {
  i.matterBody && ai.Body.setPosition(i.matterBody, {
    x: i.matterBody.position.x + t,
    y: i.matterBody.position.y + e
  });
}, Tp = (i) => {
  var t;
  return Ro++, i.surface ? {
    isStatic: !0,
    label: Ro.toString(),
    inertia: 1 / 0,
    inverseInertia: 0,
    restitution: 0
  } : (t = i.movement) != null && t.linearMovement ? {
    friction: 0,
    frictionAir: 0,
    frictionStatic: 0,
    inertia: 1 / 0,
    inverseInertia: 0,
    restitution: 0,
    label: Ro.toString()
  } : {
    isStatic: !0,
    friction: 0,
    frictionAir: 0,
    frictionStatic: 0,
    restitution: 0,
    isSensor: !0,
    label: Ro.toString()
  };
}, Ep = (i) => i.target.matterBody ? i.rectangle ? {
  x1: i.target.matterBody.position.x - i.rectangle.width / 2,
  y1: i.target.matterBody.position.y - i.rectangle.height / 2,
  x2: i.target.matterBody.position.x + i.rectangle.width / 2,
  y2: i.target.matterBody.position.y + i.rectangle.height / 2
} : i.circle ? {
  x1: i.target.matterBody.position.x - i.circle.radius,
  y1: i.target.matterBody.position.y - i.circle.radius,
  x2: i.target.matterBody.position.x + i.circle.radius,
  y2: i.target.matterBody.position.y + i.circle.radius
} : { x1: 0, y1: 0, x2: 0, y2: 0 } : { x1: 0, y1: 0, x2: 0, y2: 0 };
class Ua {
  constructor(t, e) {
    Ae(this, "_props"), Ae(this, "_object"), Ae(this, "_parent", null), Ae(this, "_bindings", []), Ae(this, "_animations", []), this._props = e, this._object = t, this.hitArea = this.props.hitArea, this._createEvents(), this._setOrientationProperties(), this._positionToScreen(), (this.props.animations ?? []).forEach((n) => this.animate(n));
  }
  _registerToSignal(t, e) {
    this._bindings.push(hs(t, e.bind(this)));
  }
  _unregisterFromSignal(t) {
    for (let e = 0; e < this._bindings.length; e++)
      this._bindings[e].name === t && (Zo(t, this._bindings[e].binding), this._bindings.splice(e, 1), e--);
  }
  get props() {
    return this._props;
  }
  get object() {
    return this._object;
  }
  get x() {
    return this.object.x;
  }
  set x(t) {
    this.object.x = t;
  }
  get y() {
    return this.object.y;
  }
  set y(t) {
    this.object.y = t;
  }
  get position() {
    return this.object.position;
  }
  set position(t) {
    this.object.position = t;
  }
  get globalPosition() {
    return this.object.toGlobal({ x: 0, y: 0 });
  }
  set scale(t) {
    this.object.scale = t;
  }
  get scale() {
    return this.object.scale;
  }
  get scaleX() {
    return this.object.scale.x;
  }
  set scaleX(t) {
    this.object.scale.x = t;
  }
  get scaleY() {
    return this.object.scale.y;
  }
  set scaleY(t) {
    this.object.scale.y = t;
  }
  get width() {
    return this.object.width;
  }
  set width(t) {
    this.object.width = t;
  }
  get height() {
    return this.object.height;
  }
  set height(t) {
    this.object.height = t;
  }
  get alpha() {
    return this.object.alpha;
  }
  set alpha(t) {
    this.object.alpha = t;
  }
  get visible() {
    return this.object.visible;
  }
  set visible(t) {
    this.object.visible = t;
  }
  get label() {
    return this.object.label;
  }
  get parent() {
    return this._parent;
  }
  set parent(t) {
    this._parent = t;
  }
  get interactive() {
    return this.object.interactive ?? !1;
  }
  set interactive(t) {
    this.object.interactive = t;
  }
  get rotation() {
    return this.object.rotation;
  }
  set rotation(t) {
    this.object.rotation = t;
  }
  get tint() {
    return this.object.tint;
  }
  set tint(t) {
    this.object.tint = t;
  }
  get zIndex() {
    return this.object.zIndex;
  }
  set zIndex(t) {
    this.object.zIndex = t;
  }
  set hitArea(t) {
    t != null && t.circle ? this.object.hitArea = new Ma(
      t.circle.x,
      t.circle.y,
      t.circle.radius
    ) : t != null && t.roundedRectangle ? this.object.hitArea = new Oa(
      t.roundedRectangle.x,
      t.roundedRectangle.y,
      t.roundedRectangle.width,
      t.roundedRectangle.height,
      t.roundedRectangle.borderRadius
    ) : t != null && t.rectangle ? this.object.hitArea = new jt(
      t.rectangle.x,
      t.rectangle.y,
      t.rectangle.width,
      t.rectangle.height
    ) : t != null && t.polygon ? this.object.hitArea = new lr(t.polygon.points) : this.object.hitArea = null;
  }
  animate(t) {
    return this._createAnimation(this, t);
  }
  getAnimation(t) {
    return this._animations.find((e) => e.name === t);
  }
  stopAnimations() {
    this._animations.forEach((t) => t.stop()), this._animations = [];
  }
  finishAnimations() {
    this._animations.forEach((t) => t.finish());
  }
  delay(t) {
    return this._createAnimation(
      { x: 0 },
      {
        from: { x: 0 },
        to: { x: 1 },
        duration: t
      }
    );
  }
  destroy() {
    if (this.parent) {
      this.parent.removeComponent(this);
      return;
    }
    jw(this), this._bindings.forEach(
      ({ name: t, binding: e }) => Zo(t, e)
    ), this._bindings = [], this.stopAnimations(), this.parent = null, this.object.destroy();
  }
  _positionToScreen() {
    var t, e, n, r;
    this.props.horizontalAlignment === "center" ? this.x = tt.screen.width / 2 + (((t = this.props.margin) == null ? void 0 : t.x) ?? 0) : this.props.horizontalAlignment === "right" && (this.x = tt.screen.width + (((e = this.props.margin) == null ? void 0 : e.x) ?? 0)), this.props.verticalAlignment === "center" ? this.y = tt.screen.height / 2 + (((n = this.props.margin) == null ? void 0 : n.y) ?? 0) : this.props.verticalAlignment === "bottom" && (this.y = tt.screen.height + (((r = this.props.margin) == null ? void 0 : r.y) ?? 0));
  }
  _setOrientationProperties() {
    if (!this.props.landscape && !this.props.portrait) return;
    const t = this.props[tt.screen.orientation];
    for (const e in t)
      this[e] = t[e];
  }
  async _createAnimation(t, e) {
    const n = new Dr(e);
    this._animations.push(n), await n.start(t);
    const r = this._animations.indexOf(n);
    this._animations.splice(r, 1);
  }
  _createEvents() {
    var t, e, n;
    const r = [
      this.props.horizontalAlignment || this.props.verticalAlignment ? this._positionToScreen.bind(this) : null,
      this.props.onResize,
      (t = this._onResize) == null ? void 0 : t.bind(this)
    ].filter(Boolean);
    r.length > 0 && this._registerToSignal(W.signals.onResize, () => {
      r.forEach((a) => a(this));
    });
    const s = [
      this.props.landscape || this.props.portrait ? this._setOrientationProperties.bind(this) : null,
      this.props.onOrientationChange,
      (e = this._onOrientationChange) == null ? void 0 : e.bind(this)
    ].filter(Boolean);
    s.length > 0 && this._registerToSignal(W.signals.onOrientationChange, () => {
      s.forEach((a) => a(this));
    });
    const o = [
      this.props.onTick,
      (n = this._onTick) == null ? void 0 : n.bind(this)
    ].filter(Boolean);
    o.length > 0 && this._registerToSignal(W.signals.onTick, () => {
      o.forEach((a) => a(this));
    }), (this._onClick || this.props.onClick) && this.object.on("pointerdown", (a) => {
      var l, h, c;
      a.stopImmediatePropagation(), (h = (l = this.props).onClick) == null || h.call(l, this), (c = this._onClick) == null || c.call(this);
    }), (this._onPointerUp || this.props.onPointerUp) && this.object.on("pointerup", (a) => {
      var l, h, c;
      a.stopImmediatePropagation(), (h = (l = this.props).onPointerUp) == null || h.call(l, this), (c = this._onPointerUp) == null || c.call(this);
    }), (this._onPointerEnter || this.props.onPointerEnter) && this.object.on("pointerenter", (a) => {
      var l, h, c;
      a.stopImmediatePropagation(), (h = (l = this.props).onPointerEnter) == null || h.call(l, this), (c = this._onPointerEnter) == null || c.call(this);
    }), (this._onPointerOut || this.props.onPointerOut) && this.object.on("pointerout", (a) => {
      var l, h, c;
      a.stopImmediatePropagation(), (h = (l = this.props).onPointerOut) == null || h.call(l, this), (c = this._onPointerOut) == null || c.call(this);
    });
  }
}
let bs;
const Mi = /* @__PURE__ */ new Map(), Gw = () => {
  bs = mi.get("audio/sounds.mp3");
  const i = mi.get("audio/sounds.json");
  bs.muted = tt.muted, bs.addSprites(i);
}, jn = async (i, t = {}) => {
  const { loop: e = !1, volume: n = 1 } = t, r = await bs.play({
    sprite: i,
    loop: e,
    volume: n,
    complete: () => Mi.delete(i)
  });
  Mi.set(i, r);
}, Gc = async (i, t) => {
  const {
    fromVolume: e = 0.1,
    toVolume: n = 1,
    fadeDuration: r,
    loop: s = !1
  } = t;
  await jn(i, { loop: s, volume: n }), await new Dr({
    duration: r,
    from: { volume: e },
    to: { volume: n }
  }).start(Mi.get(i));
}, Hw = (i) => {
  var t, e;
  (t = Mi.get(i)) == null || t.stop(), (e = Mi.get(i)) == null || e.destroy(), Mi.delete(i);
}, Hc = async (i, t) => {
  const e = Mi.get(i);
  if (!e) return;
  const { fadeDuration: n } = t;
  await new Dr({
    duration: n,
    from: { volume: e.volume },
    to: { volume: 0 }
  }).start(e), Hw(i);
}, Ww = (i) => {
  bs.muted = i;
}, qw = () => {
  for (const [i, t] of Mi)
    t.paused = !0;
}, Yw = () => {
  for (const [i, t] of Mi)
    t.paused = !1;
}, za = (i) => ({
  label: i.label,
  position: i.position,
  anchor: i.anchor,
  scale: i.scale,
  rotation: i.rotation,
  width: i.width,
  height: i.height,
  alpha: i.alpha,
  interactive: i.interactive,
  cursor: i.cursor,
  visible: i.visible,
  tint: i.tint,
  zIndex: i.zIndex
});
let Wg;
const Cp = /* @__PURE__ */ new Map(), Xw = (i) => {
  Wg = i;
}, Kw = (i) => {
  let t;
  if (i.rectangle)
    t = new An().rect(
      i.rectangle.x,
      i.rectangle.y,
      i.rectangle.width,
      i.rectangle.height
    );
  else if (i.roundedRectangle)
    t = new An().roundRect(
      i.roundedRectangle.x,
      i.roundedRectangle.y,
      i.roundedRectangle.width,
      i.roundedRectangle.height,
      i.roundedRectangle.borderRadius
    );
  else if (i.circle)
    t = new An().circle(
      i.circle.x,
      i.circle.y,
      i.circle.radius
    );
  else if (i.polygon)
    t = new An().poly(i.polygon.points);
  else
    throw new Error("Invalid shape type");
  return t = t.fill(i.fillColor), i.strokeColor != null && (t = t.stroke({
    color: i.strokeColor,
    width: i.strokeWidth ?? 0
  })), t;
}, oa = (i) => {
  const t = JSON.stringify(i);
  let e = Cp.get(t);
  if (e) return e;
  if (typeof i == "string") return nt.from(i);
  const n = Kw(i);
  return e = Ac.create({
    width: n.width,
    height: n.height
  }), Wg.render({ container: n, target: e }), Cp.set(t, e), e;
};
class Be extends Ua {
  constructor(t) {
    super(
      new vr({
        ...za(t),
        texture: oa(t.resource)
      }),
      t
    );
  }
  get anchor() {
    return this.object.anchor;
  }
  set anchor(t) {
    this.object.anchor = t;
  }
  get originalWidth() {
    return this.object.texture.width;
  }
  get originalHeight() {
    return this.object.texture.height;
  }
  set texture(t) {
    this.object.texture = oa(t);
  }
}
class ja extends Be {
  constructor(t) {
    super(t), Ae(this, "_pointerOver", !1), Ae(this, "_enabled", !0);
  }
  get props() {
    return super.props;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(t) {
    this._enabled !== t && (this._enabled = t, this._setCurrentTexture());
  }
  get pointerOver() {
    return this._pointerOver;
  }
  _onPointerEnter() {
    this._pointerOver = !0, this._setCurrentTexture();
  }
  _onPointerOut() {
    this._pointerOver = !1, this._setCurrentTexture();
  }
  async _onClick() {
    jn(W.sounds.click), this.texture = this.enabled ? this.props.resource : this.props.disabledResource, await this.delay(0.1), this._setCurrentTexture();
  }
  _setCurrentTexture() {
    this.enabled ? this.pointerOver ? this.texture = this.props.hoverResource : this.texture = this.props.resource : this.texture = this.props.disabledResource;
  }
}
class ei extends Ua {
  constructor(t) {
    super(
      new Te({
        ...za(t),
        sortableChildren: t.sortableChildren
      }),
      t
    ), Ae(this, "_components", []), this.addComponents(t.components ?? []);
  }
  get components() {
    return this._components;
  }
  get sortableChildren() {
    return this.object.sortableChildren;
  }
  set sortableChildren(t) {
    this.object.sortableChildren = t;
  }
  addComponent(t) {
    return this.components.push(t), this.object.addChild(t.object), t.parent = this, t;
  }
  addComponents(t) {
    t.forEach((e) => this.addComponent(e));
  }
  getComponent(t) {
    return this.components.find((e) => e.label === t);
  }
  removeComponent(t) {
    const e = this.components.indexOf(t);
    e >= 0 && (this.components[e].parent = null, this.components[e].destroy(), this.components.splice(e, 1));
  }
  removeComponents() {
    this.components.forEach((t) => {
      t.parent = null, t.destroy();
    }), this._components = [];
  }
  destroy() {
    this.removeComponents(), super.destroy();
  }
  _positionToScreen() {
    var t, e, n, r;
    this.props.horizontalAlignment === "center" ? this.x = (tt.screen.width - (this.props.width ?? 0)) / 2 + (((t = this.props.margin) == null ? void 0 : t.x) ?? 0) : this.props.horizontalAlignment === "right" && (this.x = tt.screen.width - (this.props.width ?? 0) + (((e = this.props.margin) == null ? void 0 : e.x) ?? 0)), this.props.verticalAlignment === "center" ? this.y = (tt.screen.height - (this.props.height ?? 0)) / 2 + (((n = this.props.margin) == null ? void 0 : n.y) ?? 0) : this.props.verticalAlignment === "bottom" && (this.y = tt.screen.height - (this.props.height ?? 0) + (((r = this.props.margin) == null ? void 0 : r.y) ?? 0));
  }
}
class qg extends ja {
  constructor(t) {
    super(t);
  }
  get props() {
    return super.props;
  }
  async _onClick() {
    super._onClick(), window.location.href = this.props.url;
  }
}
class Us extends Ua {
  constructor(t) {
    super(
      new b1({
        ...za(t),
        texture: oa(t.resource),
        anchor: typeof t.anchor == "number" ? { x: t.anchor, y: t.anchor } : t.anchor
      }),
      t
    );
  }
  get anchor() {
    return this.object.anchor;
  }
  set anchor(t) {
    this.object.anchor = t;
  }
  get originalWidth() {
    return this.object.texture.width;
  }
  get originalHeight() {
    return this.object.texture.height;
  }
  get tileScale() {
    return this.object.tileScale;
  }
  set tileScale(t) {
    this.object.tileScale = t;
  }
  get tilePosition() {
    return this.object.tilePosition;
  }
  set tilePosition(t) {
    this.object.tilePosition = t;
  }
  set texture(t) {
    this.object.texture = oa(t);
  }
}
class Yg extends Us {
  constructor(t) {
    super(t), this._onResize();
  }
  _onResize() {
    this.width = tt.screen.width, this.height = tt.screen.height;
    const t = tt.screen.height / this.originalHeight;
    this.tileScale = { x: t, y: t };
  }
}
class Xg extends Yg {
  _onTick() {
    this.tilePosition.x--;
  }
}
class _e extends Ua {
  constructor(t) {
    const e = {
      ...za(t),
      text: t.text,
      style: {
        fontFamily: t.fontFamily,
        fontSize: t.fontSize,
        fill: t.textColor,
        lineHeight: t.lineHeight,
        wordWrap: t.wordWrap,
        wordWrapWidth: t.wordWrapWidth,
        align: t.align,
        fontWeight: t.fontWeight ?? "normal",
        fontStyle: t.fontStyle ?? "normal",
        letterSpacing: t.letterSpacing ?? 0,
        stroke: t.strokeColor && {
          color: t.strokeColor,
          width: t.strokeWidth
        }
      }
    };
    super(t.bitmap ? new A1(e) : new w1(e), t);
  }
  get anchor() {
    return this.object.anchor;
  }
  set anchor(t) {
    this.object.anchor = t;
  }
  get fontSize() {
    return this.object.style.fontSize;
  }
  set fontSize(t) {
    this.object.style.fontSize = t;
  }
  get wordWrapWidth() {
    return this.object.style.wordWrapWidth;
  }
  set wordWrapWidth(t) {
    this.object.style.wordWrapWidth = t;
  }
  get fontWeight() {
    return this.object.style.fontWeight;
  }
  set fontWeight(t) {
    this.object.style.fontWeight = t;
  }
  get fontStyle() {
    return this.object.style.fontStyle;
  }
  set fontStyle(t) {
    this.object.style.fontStyle = t;
  }
  get align() {
    return this.object.style.align;
  }
  set align(t) {
    this.object.style.align = t;
  }
  get text() {
    return this.object.text;
  }
  set text(t) {
    this.object.text = t;
  }
}
class Qw extends ja {
  constructor(t) {
    super(t), Ae(this, "_originalProps"), this._originalProps = structuredClone(t), this._setResources();
  }
  get props() {
    return super.props;
  }
  async _onClick() {
    localStorage.setItem("muted", tt.muted ? "false" : "true"), tt.muted = !tt.muted, Ww(tt.muted), this._setResources(), super._onClick();
  }
  _setResources() {
    tt.muted ? (this.props.resource = this._originalProps.mutedResource, this.props.hoverResource = this._originalProps.mutedHoverResource, this.props.disabledResource = this._originalProps.mutedDisabledResource) : (this.props.resource = this._originalProps.resource, this.props.hoverResource = this._originalProps.hoverResource, this.props.disabledResource = this._originalProps.disabledResource), this._setCurrentTexture();
  }
}
class Jw extends ei {
  constructor(t) {
    super({
      ...t,
      interactive: !0,
      cursor: "text"
    }), Ae(this, "_input", null), Ae(this, "_inputEventAbort", null), Ae(this, "_text", "");
    const { height: e } = this.addComponent(
      new Be({
        label: "bg",
        resource: this.props.background
      })
    ), n = this.addComponent(
      new _e({
        label: "text",
        position: { x: this.props.padding ?? 0, y: e / 2 },
        anchor: { x: 0, y: 0.5 },
        text: this.props.text ?? "",
        fontFamily: this.props.fontFamily,
        fontSize: this.props.fontSize,
        fontWeight: this.props.fontWeight,
        textColor: this.props.textColor,
        strokeColor: this.props.strokeColor,
        strokeWidth: this.props.strokeWidth,
        letterSpacing: this.props.letterSpacing
      })
    );
    this.addComponent(
      new Be({
        label: "caret",
        position: { x: n.x + n.width + 2, y: e / 2 },
        anchor: { x: 0, y: 0.5 },
        visible: !1,
        resource: {
          rectangle: {
            x: 0,
            y: 0,
            width: 2,
            height: e - (this.props.padding ?? 0) * 2
          },
          fillColor: this.props.textColor
        },
        animations: [
          {
            from: { alpha: 1 },
            to: { alpha: 0 },
            duration: 0.4,
            repeat: -1,
            revert: !0
          }
        ]
      })
    ), this._text = this.props.text ?? "";
  }
  get props() {
    return super.props;
  }
  get text() {
    return this._text;
  }
  set text(t) {
    var e, n;
    if (this._text === t) return;
    this._text = t;
    const r = this.getComponent("text");
    r.text = this._text;
    const s = this.getComponent("caret");
    s.x = r.x + r.width + 2, (n = (e = this.props).onChange) == null || n.call(e, this._text), this._onChange && this._onChange(this._text);
  }
  destroy() {
    this._removeInput(), super.destroy();
  }
  _onClick() {
    this._createInput(), setTimeout(() => {
      this._input && (this._input.focus(), this.getComponent("caret").visible = !0, setTimeout(() => {
        this._input && (this._input.style.left = "-9999px");
      }, 100));
    }, 100);
  }
  _createInput() {
    if (this._input) return;
    const t = W.gameContainer.querySelector("canvas");
    if (!t) return;
    const { x: e, y: n } = this.globalPosition, { width: r, height: s } = this.getComponent("bg"), o = parseFloat(t.style.top), a = parseFloat(t.style.left), l = t.width, h = t.height, c = parseFloat(t.style.width), p = parseFloat(t.style.height), f = c / l, d = p / h, m = o + n * d, g = a + e * f, y = s * d, b = r * f;
    this._input = document.createElement("input"), this._input.type = "text", this._input.value = this.text, this._input.style.position = "fixed", this._input.style.top = `${m}px`, this._input.style.left = `${g}px`, this._input.style.width = `${b}px`, this._input.style.height = `${y}px`, this._input.style.opacity = "0", W.gameContainer.appendChild(this._input), this._inputEventAbort = new AbortController(), this._input.addEventListener("change", this._updateText.bind(this), {
      signal: this._inputEventAbort.signal
    }), this._input.addEventListener("keyup", this._updateText.bind(this), {
      signal: this._inputEventAbort.signal
    }), this._input.addEventListener("input", this._updateText.bind(this), {
      signal: this._inputEventAbort.signal
    }), this._input.addEventListener("blur", this._blur.bind(this), {
      signal: this._inputEventAbort.signal
    });
  }
  _blur() {
    this._removeInput(), this.getComponent("caret").visible = !1;
  }
  _updateText() {
    if (!this._input) return;
    const t = this._input.value.substring(
      0,
      this.props.maxLength ?? this._input.value.length
    );
    this._input.value = t, this.text = t;
  }
  _removeInput() {
    var t;
    this._input && ((t = this._inputEventAbort) == null || t.abort(), this._input.remove(), this._input = null, this._inputEventAbort = null);
  }
}
class Br extends ei {
  constructor(t = "Scene") {
    super({ label: t });
  }
  async init() {
  }
}
class Zw extends Br {
  async init() {
    this.addComponent(
      new _e({
        label: "loading-text",
        text: W.loadingScene.text,
        anchor: { x: 0.5, y: 0.5 },
        fontFamily: W.loadingScene.fontFamily,
        fontSize: W.loadingScene.fontSize,
        textColor: W.loadingScene.textColor,
        horizontalAlignment: "center",
        verticalAlignment: "center"
      })
    );
  }
}
const Wc = (i, t, e = 500, n = 1e3) => {
  let r = null, s = !1;
  return { start: () => {
    r != null && clearTimeout(r), r = setTimeout(() => {
      s = !0, r = null, i();
    }, e);
  }, cancel: () => {
    r != null && (clearTimeout(r), r = null), s ? r = setTimeout(() => {
      s = !1, r = null, t();
    }, n) : t();
  } };
}, $w = (i, t, e, n) => {
  const r = i.clientWidth, s = i.clientHeight;
  if (r < s) {
    const f = e;
    e = n, n = f;
  }
  const o = Math.min(
    r / e,
    s / n
  ), a = Math.floor(o * e), l = Math.floor(o * n), h = (r - a) / 2, c = (s - l) / 2;
  t.style.width = `${a}px`, t.style.height = `${l}px`, t.style.left = `${h}px`, t.style.top = `${c}px`, t.width = e, t.height = n;
  const p = e < n ? "portrait" : "landscape";
  return {
    width: e,
    height: n,
    orientation: p
  };
};
let Kg;
function tA(i) {
  return Kg = i, i;
}
function zs() {
  return Kg;
}
class Wh {
  /**
   * Dezippering is removed in the future Web Audio API, instead
   * we use the `setValueAtTime` method, however, this is not available
   * in all environments (e.g., Android webview), so we fallback to the `value` setter.
   * @param param - AudioNode parameter object
   * @param value - Value to set
   * @return The value set
   */
  static setParamValue(t, e) {
    if (t.setValueAtTime) {
      const n = zs().context;
      t.setValueAtTime(e, n.audioContext.currentTime);
    } else
      t.value = e;
    return e;
  }
}
class eA extends xe {
  constructor() {
    super(...arguments), this.speed = 1, this.muted = !1, this.volume = 1, this.paused = !1;
  }
  /** Internal trigger when volume, mute or speed changes */
  refresh() {
    this.emit("refresh");
  }
  /** Internal trigger paused changes */
  refreshPaused() {
    this.emit("refreshPaused");
  }
  /**
   * HTML Audio does not support filters, this is non-functional API.
   */
  get filters() {
    return console.warn("HTML Audio does not support filters"), null;
  }
  set filters(t) {
    console.warn("HTML Audio does not support filters");
  }
  /**
   * HTML Audio does not support `audioContext`
   * @readonly
   * @type {AudioContext}
   */
  get audioContext() {
    return console.warn("HTML Audio does not support audioContext"), null;
  }
  /**
   * Toggles the muted state.
   * @return The current muted state.
   */
  toggleMute() {
    return this.muted = !this.muted, this.refresh(), this.muted;
  }
  /**
   * Toggles the paused state.
   * @return The current paused state.
   */
  togglePause() {
    return this.paused = !this.paused, this.refreshPaused(), this.paused;
  }
  /** Destroy and don't use after this */
  destroy() {
    this.removeAllListeners();
  }
}
let iA = 0;
const qh = class extends xe {
  /** @param parent - Parent element */
  constructor(i) {
    super(), this.id = iA++, this.init(i);
  }
  /**
   * Set a property by name, this makes it easy to chain values
   * @param name - Name of the property to set
   * @param value - Value to set property to
   */
  set(i, t) {
    if (this[i] === void 0)
      throw new Error(`Property with name ${i} does not exist.`);
    switch (i) {
      case "speed":
        this.speed = t;
        break;
      case "volume":
        this.volume = t;
        break;
      case "paused":
        this.paused = t;
        break;
      case "loop":
        this.loop = t;
        break;
      case "muted":
        this.muted = t;
        break;
    }
    return this;
  }
  /** The current playback progress from 0 to 1. */
  get progress() {
    const { currentTime: i } = this._source;
    return i / this._duration;
  }
  /** Pauses the sound. */
  get paused() {
    return this._paused;
  }
  set paused(i) {
    this._paused = i, this.refreshPaused();
  }
  /**
   * Reference: http://stackoverflow.com/a/40370077
   * @private
   */
  _onPlay() {
    this._playing = !0;
  }
  /**
   * Reference: http://stackoverflow.com/a/40370077
   * @private
   */
  _onPause() {
    this._playing = !1;
  }
  /**
   * Initialize the instance.
   * @param {htmlaudio.HTMLAudioMedia} media - Same as constructor
   */
  init(i) {
    this._playing = !1, this._duration = i.source.duration;
    const t = this._source = i.source.cloneNode(!1);
    t.src = i.parent.url, t.onplay = this._onPlay.bind(this), t.onpause = this._onPause.bind(this), i.context.on("refresh", this.refresh, this), i.context.on("refreshPaused", this.refreshPaused, this), this._media = i;
  }
  /**
   * Stop the sound playing
   * @private
   */
  _internalStop() {
    this._source && this._playing && (this._source.onended = null, this._source.pause());
  }
  /** Stop the sound playing */
  stop() {
    this._internalStop(), this._source && this.emit("stop");
  }
  /** Set the instance speed from 0 to 1 */
  get speed() {
    return this._speed;
  }
  set speed(i) {
    this._speed = i, this.refresh();
  }
  /** Get the set the volume for this instance from 0 to 1 */
  get volume() {
    return this._volume;
  }
  set volume(i) {
    this._volume = i, this.refresh();
  }
  /** If the sound instance should loop playback */
  get loop() {
    return this._loop;
  }
  set loop(i) {
    this._loop = i, this.refresh();
  }
  /** `true` if the sound is muted */
  get muted() {
    return this._muted;
  }
  set muted(i) {
    this._muted = i, this.refresh();
  }
  /**
   * HTML Audio does not support filters, this is non-functional API.
   */
  get filters() {
    return console.warn("HTML Audio does not support filters"), null;
  }
  set filters(i) {
    console.warn("HTML Audio does not support filters");
  }
  /** Call whenever the loop, speed or volume changes */
  refresh() {
    const i = this._media.context, t = this._media.parent;
    this._source.loop = this._loop || t.loop;
    const e = i.volume * (i.muted ? 0 : 1), n = t.volume * (t.muted ? 0 : 1), r = this._volume * (this._muted ? 0 : 1);
    this._source.volume = r * e * n, this._source.playbackRate = this._speed * i.speed * t.speed;
  }
  /** Handle changes in paused state, either globally or sound or instance */
  refreshPaused() {
    const i = this._media.context, t = this._media.parent, e = this._paused || t.paused || i.paused;
    e !== this._pausedReal && (this._pausedReal = e, e ? (this._internalStop(), this.emit("paused")) : (this.emit("resumed"), this.play({
      start: this._source.currentTime,
      end: this._end,
      volume: this._volume,
      speed: this._speed,
      loop: this._loop
    })), this.emit("pause", e));
  }
  /** Start playing the sound/ */
  play(i) {
    const { start: t, end: e, speed: n, loop: r, volume: s, muted: o } = i;
    e && console.assert(e > t, "End time is before start time"), this._speed = n, this._volume = s, this._loop = !!r, this._muted = o, this.refresh(), this.loop && e !== null && (console.warn('Looping not support when specifying an "end" time'), this.loop = !1), this._start = t, this._end = e || this._duration, this._start = Math.max(0, this._start - qh.PADDING), this._end = Math.min(this._end + qh.PADDING, this._duration), this._source.onloadedmetadata = () => {
      this._source && (this._source.currentTime = t, this._source.onloadedmetadata = null, this.emit("progress", t / this._duration, this._duration), Ii.shared.add(this._onUpdate, this));
    }, this._source.onended = this._onComplete.bind(this), this._source.play(), this.emit("start");
  }
  /**
   * Handle time update on sound.
   * @private
   */
  _onUpdate() {
    this.emit("progress", this.progress, this._duration), this._source.currentTime >= this._end && !this._source.loop && this._onComplete();
  }
  /**
   * Callback when completed.
   * @private
   */
  _onComplete() {
    Ii.shared.remove(this._onUpdate, this), this._internalStop(), this.emit("progress", 1, this._duration), this.emit("end", this);
  }
  /** Don't use after this. */
  destroy() {
    Ii.shared.remove(this._onUpdate, this), this.removeAllListeners();
    const i = this._source;
    i && (i.onended = null, i.onplay = null, i.onpause = null, this._internalStop()), this._source = null, this._speed = 1, this._volume = 1, this._loop = !1, this._end = null, this._start = 0, this._duration = 0, this._playing = !1, this._pausedReal = !1, this._paused = !1, this._muted = !1, this._media && (this._media.context.off("refresh", this.refresh, this), this._media.context.off("refreshPaused", this.refreshPaused, this), this._media = null);
  }
  /**
   * To string method for instance.
   * @return The string representation of instance.
   */
  toString() {
    return `[HTMLAudioInstance id=${this.id}]`;
  }
};
let Qg = qh;
Qg.PADDING = 0.1;
class nA extends xe {
  init(t) {
    this.parent = t, this._source = t.options.source || new Audio(), t.url && (this._source.src = t.url);
  }
  // Implement create
  create() {
    return new Qg(this);
  }
  /**
   * If the audio media is playable (ready).
   * @readonly
   */
  get isPlayable() {
    return !!this._source && this._source.readyState === 4;
  }
  /**
   * THe duration of the media in seconds.
   * @readonly
   */
  get duration() {
    return this._source.duration;
  }
  /**
   * Reference to the context.
   * @readonly
   */
  get context() {
    return this.parent.context;
  }
  /** The collection of filters, does not apply to HTML Audio. */
  get filters() {
    return null;
  }
  set filters(t) {
    console.warn("HTML Audio does not support filters");
  }
  // Override the destroy
  destroy() {
    this.removeAllListeners(), this.parent = null, this._source && (this._source.src = "", this._source.load(), this._source = null);
  }
  /**
   * Get the audio source element.
   * @type {HTMLAudioElement}
   * @readonly
   */
  get source() {
    return this._source;
  }
  // Implement the method to being preloading
  load(t) {
    const e = this._source, n = this.parent;
    if (e.readyState === 4) {
      n.isLoaded = !0;
      const l = n.autoPlayStart();
      t && setTimeout(() => {
        t(null, n, l);
      }, 0);
      return;
    }
    if (!n.url) {
      t(new Error("sound.url or sound.source must be set"));
      return;
    }
    e.src = n.url;
    const r = () => {
      a(), n.isLoaded = !0;
      const l = n.autoPlayStart();
      t && t(null, n, l);
    }, s = () => {
      a(), t && t(new Error("Sound loading has been aborted"));
    }, o = () => {
      a();
      const l = `Failed to load audio element (code: ${e.error.code})`;
      t ? t(new Error(l)) : console.error(l);
    }, a = () => {
      e.removeEventListener("canplaythrough", r), e.removeEventListener("load", r), e.removeEventListener("abort", s), e.removeEventListener("error", o);
    };
    e.addEventListener("canplaythrough", r, !1), e.addEventListener("load", r, !1), e.addEventListener("abort", s, !1), e.addEventListener("error", o, !1), e.load();
  }
}
class rA {
  /**
   * @param parent - The parent sound
   * @param options - Data associated with object.
   */
  constructor(t, e) {
    this.parent = t, Object.assign(this, e), this.duration = this.end - this.start, console.assert(this.duration > 0, "End time must be after start time");
  }
  /**
   * Play the sound sprite.
   * @param {Function} [complete] - Function call when complete
   * @return Sound instance being played.
   */
  play(t) {
    return this.parent.play({
      complete: t,
      speed: this.speed || this.parent.speed,
      end: this.end,
      start: this.start,
      loop: this.loop
    });
  }
  /** Destroy and don't use after this */
  destroy() {
    this.parent = null;
  }
}
const aa = [
  "ogg",
  "oga",
  "opus",
  "m4a",
  "mp3",
  "mpeg",
  "wav",
  "aiff",
  "wma",
  "mid",
  "caf"
], sA = [
  "audio/mpeg",
  "audio/ogg"
], la = {};
function oA(i) {
  const t = {
    m4a: "audio/mp4",
    oga: "audio/ogg",
    opus: 'audio/ogg; codecs="opus"',
    caf: 'audio/x-caf; codecs="opus"'
  }, e = document.createElement("audio"), n = {}, r = /^no$/;
  aa.forEach((s) => {
    const o = e.canPlayType(`audio/${s}`).replace(r, ""), a = t[s] ? e.canPlayType(t[s]).replace(r, "") : "";
    n[s] = !!o || !!a;
  }), Object.assign(la, n);
}
oA();
let aA = 0;
class lA extends xe {
  constructor(t) {
    super(), this.id = aA++, this._media = null, this._paused = !1, this._muted = !1, this._elapsed = 0, this.init(t);
  }
  /**
   * Set a property by name, this makes it easy to chain values
   * @param name - Name of the property to set.
   * @param value - Value to set property to.
   */
  set(t, e) {
    if (this[t] === void 0)
      throw new Error(`Property with name ${t} does not exist.`);
    switch (t) {
      case "speed":
        this.speed = e;
        break;
      case "volume":
        this.volume = e;
        break;
      case "muted":
        this.muted = e;
        break;
      case "loop":
        this.loop = e;
        break;
      case "paused":
        this.paused = e;
        break;
    }
    return this;
  }
  /** Stops the instance, don't use after this. */
  stop() {
    this._source && (this._internalStop(), this.emit("stop"));
  }
  /** Set the instance speed from 0 to 1 */
  get speed() {
    return this._speed;
  }
  set speed(t) {
    this._speed = t, this.refresh(), this._update(!0);
  }
  /** Get the set the volume for this instance from 0 to 1 */
  get volume() {
    return this._volume;
  }
  set volume(t) {
    this._volume = t, this.refresh();
  }
  /** `true` if the sound is muted */
  get muted() {
    return this._muted;
  }
  set muted(t) {
    this._muted = t, this.refresh();
  }
  /** If the sound instance should loop playback */
  get loop() {
    return this._loop;
  }
  set loop(t) {
    this._loop = t, this.refresh();
  }
  /** The collection of filters. */
  get filters() {
    return this._filters;
  }
  set filters(t) {
    var e;
    this._filters && ((e = this._filters) == null || e.filter((n) => n).forEach((n) => n.disconnect()), this._filters = null, this._source.connect(this._gain)), this._filters = t != null && t.length ? t.slice(0) : null, this.refresh();
  }
  /** Refresh loop, volume and speed based on changes to parent */
  refresh() {
    if (!this._source)
      return;
    const t = this._media.context, e = this._media.parent;
    this._source.loop = this._loop || e.loop;
    const n = t.volume * (t.muted ? 0 : 1), r = e.volume * (e.muted ? 0 : 1), s = this._volume * (this._muted ? 0 : 1);
    Wh.setParamValue(this._gain.gain, s * r * n), Wh.setParamValue(this._source.playbackRate, this._speed * e.speed * t.speed), this.applyFilters();
  }
  /** Connect filters nodes to audio context */
  applyFilters() {
    var t;
    if ((t = this._filters) != null && t.length) {
      this._source.disconnect();
      let e = this._source;
      this._filters.forEach((n) => {
        e.connect(n.destination), e = n;
      }), e.connect(this._gain);
    }
  }
  /** Handle changes in paused state, either globally or sound or instance */
  refreshPaused() {
    const t = this._media.context, e = this._media.parent, n = this._paused || e.paused || t.paused;
    n !== this._pausedReal && (this._pausedReal = n, n ? (this._internalStop(), this.emit("paused")) : (this.emit("resumed"), this.play({
      start: this._elapsed % this._duration,
      end: this._end,
      speed: this._speed,
      loop: this._loop,
      volume: this._volume
    })), this.emit("pause", n));
  }
  /**
   * Plays the sound.
   * @param options - Play options.
   */
  play(t) {
    const { start: e, end: n, speed: r, loop: s, volume: o, muted: a, filters: l } = t;
    n && console.assert(n > e, "End time is before start time"), this._paused = !1;
    const { source: h, gain: c } = this._media.nodes.cloneBufferSource();
    this._source = h, this._gain = c, this._speed = r, this._volume = o, this._loop = !!s, this._muted = a, this._filters = l, this.refresh();
    const p = this._source.buffer.duration;
    this._duration = p, this._end = n, this._lastUpdate = this._now(), this._elapsed = e, this._source.onended = this._onComplete.bind(this), this._loop ? (this._source.loopEnd = n, this._source.loopStart = e, this._source.start(0, e)) : n ? this._source.start(0, e, n - e) : this._source.start(0, e), this.emit("start"), this._update(!0), this.enableTicker(!0);
  }
  /** Start the update progress. */
  enableTicker(t) {
    Ii.shared.remove(this._updateListener, this), t && Ii.shared.add(this._updateListener, this);
  }
  /** The current playback progress from 0 to 1. */
  get progress() {
    return this._progress;
  }
  /** Pauses the sound. */
  get paused() {
    return this._paused;
  }
  set paused(t) {
    this._paused = t, this.refreshPaused();
  }
  /** Don't use after this. */
  destroy() {
    var t;
    this.removeAllListeners(), this._internalStop(), this._gain && (this._gain.disconnect(), this._gain = null), this._media && (this._media.context.events.off("refresh", this.refresh, this), this._media.context.events.off("refreshPaused", this.refreshPaused, this), this._media = null), (t = this._filters) == null || t.forEach((e) => e.disconnect()), this._filters = null, this._end = null, this._speed = 1, this._volume = 1, this._loop = !1, this._elapsed = 0, this._duration = 0, this._paused = !1, this._muted = !1, this._pausedReal = !1;
  }
  /**
   * To string method for instance.
   * @return The string representation of instance.
   */
  toString() {
    return `[WebAudioInstance id=${this.id}]`;
  }
  /**
   * Get the current time in seconds.
   * @return Seconds since start of context
   */
  _now() {
    return this._media.context.audioContext.currentTime;
  }
  /** Callback for update listener */
  _updateListener() {
    this._update();
  }
  /** Internal update the progress. */
  _update(t = !1) {
    if (this._source) {
      const e = this._now(), n = e - this._lastUpdate;
      if (n > 0 || t) {
        const r = this._source.playbackRate.value;
        this._elapsed += n * r, this._lastUpdate = e;
        const s = this._duration;
        let o;
        if (this._source.loopStart) {
          const a = this._source.loopEnd - this._source.loopStart;
          o = (this._source.loopStart + this._elapsed % a) / s;
        } else
          o = this._elapsed % s / s;
        this._progress = o, this.emit("progress", this._progress, s);
      }
    }
  }
  /** Initializes the instance. */
  init(t) {
    this._media = t, t.context.events.on("refresh", this.refresh, this), t.context.events.on("refreshPaused", this.refreshPaused, this);
  }
  /** Stops the instance. */
  _internalStop() {
    if (this._source) {
      this.enableTicker(!1), this._source.onended = null, this._source.stop(0), this._source.disconnect();
      try {
        this._source.buffer = null;
      } catch (t) {
        console.warn("Failed to set AudioBufferSourceNode.buffer to null:", t);
      }
      this._source = null;
    }
  }
  /** Callback when completed. */
  _onComplete() {
    if (this._source) {
      this.enableTicker(!1), this._source.onended = null, this._source.disconnect();
      try {
        this._source.buffer = null;
      } catch (t) {
        console.warn("Failed to set AudioBufferSourceNode.buffer to null:", t);
      }
    }
    this._source = null, this._progress = 1, this.emit("progress", 1, this._duration), this.emit("end", this);
  }
}
class Jg {
  /**
   * @param input - The source audio node
   * @param output - The output audio node
   */
  constructor(t, e) {
    this._output = e, this._input = t;
  }
  /** The destination output audio node */
  get destination() {
    return this._input;
  }
  /** The collection of filters. */
  get filters() {
    return this._filters;
  }
  set filters(t) {
    if (this._filters && (this._filters.forEach((e) => {
      e && e.disconnect();
    }), this._filters = null, this._input.connect(this._output)), t && t.length) {
      this._filters = t.slice(0), this._input.disconnect();
      let e = null;
      t.forEach((n) => {
        e === null ? this._input.connect(n.destination) : e.connect(n.destination), e = n;
      }), e.connect(this._output);
    }
  }
  /** Cleans up. */
  destroy() {
    this.filters = null, this._input = null, this._output = null;
  }
}
const Zg = class extends Jg {
  /**
   * @param context - The audio context.
   */
  constructor(i) {
    const t = i.audioContext, e = t.createBufferSource(), n = t.createGain(), r = t.createAnalyser();
    e.connect(r), r.connect(n), n.connect(i.destination), super(r, n), this.context = i, this.bufferSource = e, this.gain = n, this.analyser = r;
  }
  /**
   * Get the script processor node.
   * @readonly
   */
  get script() {
    return this._script || (this._script = this.context.audioContext.createScriptProcessor(Zg.BUFFER_SIZE), this._script.connect(this.context.destination)), this._script;
  }
  /** Cleans up. */
  destroy() {
    super.destroy(), this.bufferSource.disconnect(), this._script && this._script.disconnect(), this.gain.disconnect(), this.analyser.disconnect(), this.bufferSource = null, this._script = null, this.gain = null, this.analyser = null, this.context = null;
  }
  /**
   * Clones the bufferSource. Used just before playing a sound.
   * @returns {SourceClone} The clone AudioBufferSourceNode.
   */
  cloneBufferSource() {
    const i = this.bufferSource, t = this.context.audioContext.createBufferSource();
    t.buffer = i.buffer, Wh.setParamValue(t.playbackRate, i.playbackRate.value), t.loop = i.loop;
    const e = this.context.audioContext.createGain();
    return t.connect(e), e.connect(this.destination), { source: t, gain: e };
  }
  /**
   * Get buffer size of `ScriptProcessorNode`.
   * @readonly
   */
  get bufferSize() {
    return this.script.bufferSize;
  }
};
let $g = Zg;
$g.BUFFER_SIZE = 0;
class hA {
  /**
   * Re-initialize without constructing.
   * @param parent - - Instance of parent Sound container
   */
  init(t) {
    this.parent = t, this._nodes = new $g(this.context), this._source = this._nodes.bufferSource, this.source = t.options.source;
  }
  /** Destructor, safer to use `SoundLibrary.remove(alias)` to remove this sound. */
  destroy() {
    this.parent = null, this._nodes.destroy(), this._nodes = null;
    try {
      this._source.buffer = null;
    } catch (t) {
      console.warn("Failed to set AudioBufferSourceNode.buffer to null:", t);
    }
    this._source = null, this.source = null;
  }
  // Implement create
  create() {
    return new lA(this);
  }
  // Implement context
  get context() {
    return this.parent.context;
  }
  // Implement isPlayable
  get isPlayable() {
    return !!this._source && !!this._source.buffer;
  }
  // Implement filters
  get filters() {
    return this._nodes.filters;
  }
  set filters(t) {
    this._nodes.filters = t;
  }
  // Implements duration
  get duration() {
    return console.assert(this.isPlayable, "Sound not yet playable, no duration"), this._source.buffer.duration;
  }
  /** Gets and sets the buffer. */
  get buffer() {
    return this._source.buffer;
  }
  set buffer(t) {
    this._source.buffer = t;
  }
  /** Get the current chained nodes object */
  get nodes() {
    return this._nodes;
  }
  // Implements load
  load(t) {
    this.source ? this._decode(this.source, t) : this.parent.url ? this._loadUrl(t) : t ? t(new Error("sound.url or sound.source must be set")) : console.error("sound.url or sound.source must be set");
  }
  /** Loads a sound using XHMLHttpRequest object. */
  async _loadUrl(t) {
    const e = this.parent.url, n = await Mt.get().fetch(e);
    this._decode(await n.arrayBuffer(), t);
  }
  /**
   * Decodes the array buffer.
   * @param arrayBuffer - From load.
   * @param {Function} callback - Callback optional
   */
  _decode(t, e) {
    const n = (r, s) => {
      if (r)
        e && e(r);
      else {
        this.parent.isLoaded = !0, this.buffer = s;
        const o = this.parent.autoPlayStart();
        e && e(null, this.parent, o);
      }
    };
    t instanceof AudioBuffer ? n(null, t) : this.parent.context.decode(t, n);
  }
}
const er = class {
  /**
   * Create a new sound instance from source.
   * @param source - Either the path or url to the source file.
   *        or the object of options to use.
   * @return Created sound instance.
   */
  static from(i) {
    let t = {};
    typeof i == "string" ? t.url = i : i instanceof ArrayBuffer || i instanceof AudioBuffer || i instanceof HTMLAudioElement ? t.source = i : Array.isArray(i) ? t.url = i : t = i, t = {
      autoPlay: !1,
      singleInstance: !1,
      url: null,
      source: null,
      preload: !1,
      volume: 1,
      speed: 1,
      complete: null,
      loaded: null,
      loop: !1,
      ...t
    }, Object.freeze(t);
    const e = zs().useLegacy ? new nA() : new hA();
    return new er(e, t);
  }
  /**
   * Use `Sound.from`
   * @ignore
   */
  constructor(i, t) {
    this.media = i, this.options = t, this._instances = [], this._sprites = {}, this.media.init(this);
    const e = t.complete;
    this._autoPlayOptions = e ? { complete: e } : null, this.isLoaded = !1, this._preloadQueue = null, this.isPlaying = !1, this.autoPlay = t.autoPlay, this.singleInstance = t.singleInstance, this.preload = t.preload || this.autoPlay, this.url = Array.isArray(t.url) ? this.preferUrl(t.url) : t.url, this.speed = t.speed, this.volume = t.volume, this.loop = t.loop, t.sprites && this.addSprites(t.sprites), this.preload && this._preload(t.loaded);
  }
  /**
   * Internal help for resolving which file to use if there are multiple provide
   * this is especially helpful for working with bundlers (non Assets loading).
   */
  preferUrl(i) {
    const [t] = i.map((e) => ({ url: e, ext: ae.extname(e).slice(1) })).filter(({ ext: e }) => la[e]).sort((e, n) => aa.indexOf(e.ext) - aa.indexOf(n.ext));
    if (!t)
      throw new Error("No supported file type found");
    return t.url;
  }
  /** Instance of the media context. */
  get context() {
    return zs().context;
  }
  /** Stops all the instances of this sound from playing. */
  pause() {
    return this.isPlaying = !1, this.paused = !0, this;
  }
  /** Resuming all the instances of this sound from playing */
  resume() {
    return this.isPlaying = this._instances.length > 0, this.paused = !1, this;
  }
  /** Stops all the instances of this sound from playing. */
  get paused() {
    return this._paused;
  }
  set paused(i) {
    this._paused = i, this.refreshPaused();
  }
  /** The playback rate. */
  get speed() {
    return this._speed;
  }
  set speed(i) {
    this._speed = i, this.refresh();
  }
  /** Set the filters. Only supported with WebAudio. */
  get filters() {
    return this.media.filters;
  }
  set filters(i) {
    this.media.filters = i;
  }
  /**
   * @ignore
   */
  addSprites(i, t) {
    if (typeof i == "object") {
      const n = {};
      for (const r in i)
        n[r] = this.addSprites(r, i[r]);
      return n;
    }
    console.assert(!this._sprites[i], `Alias ${i} is already taken`);
    const e = new rA(this, t);
    return this._sprites[i] = e, e;
  }
  /** Destructor, safer to use `SoundLibrary.remove(alias)` to remove this sound. */
  destroy() {
    this._removeInstances(), this.removeSprites(), this.media.destroy(), this.media = null, this._sprites = null, this._instances = null;
  }
  /**
   * Remove a sound sprite.
   * @param alias - The unique name of the sound sprite, if alias is omitted, removes all sprites.
   */
  removeSprites(i) {
    if (i) {
      const t = this._sprites[i];
      t !== void 0 && (t.destroy(), delete this._sprites[i]);
    } else
      for (const t in this._sprites)
        this.removeSprites(t);
    return this;
  }
  /** If the current sound is playable (loaded). */
  get isPlayable() {
    return this.isLoaded && this.media && this.media.isPlayable;
  }
  /** Stops all the instances of this sound from playing. */
  stop() {
    if (!this.isPlayable)
      return this.autoPlay = !1, this._autoPlayOptions = null, this;
    this.isPlaying = !1;
    for (let i = this._instances.length - 1; i >= 0; i--)
      this._instances[i].stop();
    return this;
  }
  // Overloaded function
  play(i, t) {
    let e;
    if (typeof i == "string" ? e = { sprite: i, loop: this.loop, complete: t } : typeof i == "function" ? (e = {}, e.complete = i) : e = i, e = {
      complete: null,
      loaded: null,
      sprite: null,
      end: null,
      start: 0,
      volume: 1,
      speed: 1,
      muted: !1,
      loop: !1,
      ...e || {}
    }, e.sprite) {
      const r = e.sprite;
      console.assert(!!this._sprites[r], `Alias ${r} is not available`);
      const s = this._sprites[r];
      e.start = s.start + (e.start || 0), e.end = s.end, e.speed = s.speed || 1, e.loop = s.loop || e.loop, delete e.sprite;
    }
    if (e.offset && (e.start = e.offset), !this.isLoaded)
      return this._preloadQueue ? new Promise((r) => {
        this._preloadQueue.push(() => {
          r(this.play(e));
        });
      }) : (this._preloadQueue = [], this.autoPlay = !0, this._autoPlayOptions = e, new Promise((r, s) => {
        this._preload((o, a, l) => {
          this._preloadQueue.forEach((h) => h()), this._preloadQueue = null, o ? s(o) : (e.loaded && e.loaded(o, a, l), r(l));
        });
      }));
    (this.singleInstance || e.singleInstance) && this._removeInstances();
    const n = this._createInstance();
    return this._instances.push(n), this.isPlaying = !0, n.once("end", () => {
      e.complete && e.complete(this), this._onComplete(n);
    }), n.once("stop", () => {
      this._onComplete(n);
    }), n.play(e), n;
  }
  /** Internal only, speed, loop, volume change occured. */
  refresh() {
    const i = this._instances.length;
    for (let t = 0; t < i; t++)
      this._instances[t].refresh();
  }
  /** Handle changes in paused state. Internal only. */
  refreshPaused() {
    const i = this._instances.length;
    for (let t = 0; t < i; t++)
      this._instances[t].refreshPaused();
  }
  /** Gets and sets the volume. */
  get volume() {
    return this._volume;
  }
  set volume(i) {
    this._volume = i, this.refresh();
  }
  /** Gets and sets the muted flag. */
  get muted() {
    return this._muted;
  }
  set muted(i) {
    this._muted = i, this.refresh();
  }
  /** Gets and sets the looping. */
  get loop() {
    return this._loop;
  }
  set loop(i) {
    this._loop = i, this.refresh();
  }
  /** Starts the preloading of sound. */
  _preload(i) {
    this.media.load(i);
  }
  /** Gets the list of instances that are currently being played of this sound. */
  get instances() {
    return this._instances;
  }
  /** Get the map of sprites. */
  get sprites() {
    return this._sprites;
  }
  /** Get the duration of the audio in seconds. */
  get duration() {
    return this.media.duration;
  }
  /** Auto play the first instance. */
  autoPlayStart() {
    let i;
    return this.autoPlay && (i = this.play(this._autoPlayOptions)), i;
  }
  /** Removes all instances. */
  _removeInstances() {
    for (let i = this._instances.length - 1; i >= 0; i--)
      this._poolInstance(this._instances[i]);
    this._instances.length = 0;
  }
  /**
   * Sound instance completed.
   * @param instance
   */
  _onComplete(i) {
    if (this._instances) {
      const t = this._instances.indexOf(i);
      t > -1 && this._instances.splice(t, 1), this.isPlaying = this._instances.length > 0;
    }
    this._poolInstance(i);
  }
  /** Create a new instance. */
  _createInstance() {
    if (er._pool.length > 0) {
      const i = er._pool.pop();
      return i.init(this.media), i;
    }
    return this.media.create();
  }
  /**
   * Destroy/recycling the instance object.
   * @param instance - Instance to recycle
   */
  _poolInstance(i) {
    i.destroy(), er._pool.indexOf(i) < 0 && er._pool.push(i);
  }
};
let ha = er;
ha._pool = [];
class js extends Jg {
  constructor() {
    const t = window, e = new js.AudioContext(), n = e.createDynamicsCompressor(), r = e.createAnalyser();
    r.connect(n), n.connect(e.destination), super(r, n), this.autoPause = !0, this._ctx = e, this._offlineCtx = new js.OfflineAudioContext(
      1,
      2,
      t.OfflineAudioContext ? Math.max(8e3, Math.min(96e3, e.sampleRate)) : 44100
    ), this.compressor = n, this.analyser = r, this.events = new xe(), this.volume = 1, this.speed = 1, this.muted = !1, this.paused = !1, this._locked = e.state === "suspended" && ("ontouchstart" in globalThis || "onclick" in globalThis), this._locked && (this._unlock(), this._unlock = this._unlock.bind(this), document.addEventListener("mousedown", this._unlock, !0), document.addEventListener("touchstart", this._unlock, !0), document.addEventListener("touchend", this._unlock, !0)), this.onFocus = this.onFocus.bind(this), this.onBlur = this.onBlur.bind(this), globalThis.addEventListener("focus", this.onFocus), globalThis.addEventListener("blur", this.onBlur);
  }
  /** Handle mobile WebAudio context resume */
  onFocus() {
    if (!this.autoPause)
      return;
    const t = this._ctx.state;
    (t === "suspended" || t === "interrupted" || !this._locked) && (this.paused = this._pausedOnBlur, this.refreshPaused());
  }
  /** Handle mobile WebAudio context suspend */
  onBlur() {
    this.autoPause && (this._locked || (this._pausedOnBlur = this._paused, this.paused = !0, this.refreshPaused()));
  }
  /**
   * Try to unlock audio on iOS. This is triggered from either WebAudio plugin setup (which will work if inside of
   * a `mousedown` or `touchend` event stack), or the first document touchend/mousedown event. If it fails (touchend
   * will fail if the user presses for too long, indicating a scroll event instead of a click event.
   *
   * Note that earlier versions of iOS supported `touchstart` for this, but iOS9 removed this functionality. Adding
   * a `touchstart` event to support older platforms may preclude a `mousedown` even from getting fired on iOS9, so we
   * stick with `mousedown` and `touchend`.
   */
  _unlock() {
    this._locked && (this.playEmptySound(), this._ctx.state === "running" && (document.removeEventListener("mousedown", this._unlock, !0), document.removeEventListener("touchend", this._unlock, !0), document.removeEventListener("touchstart", this._unlock, !0), this._locked = !1));
  }
  /**
   * Plays an empty sound in the web audio context.  This is used to enable web audio on iOS devices, as they
   * require the first sound to be played inside of a user initiated event (touch/click).
   */
  playEmptySound() {
    const t = this._ctx.createBufferSource();
    t.buffer = this._ctx.createBuffer(1, 1, 22050), t.connect(this._ctx.destination), t.start(0, 0, 0), t.context.state === "suspended" && t.context.resume();
  }
  /**
   * Get AudioContext class, if not supported returns `null`
   * @type {AudioContext}
   * @readonly
   */
  static get AudioContext() {
    const t = window;
    return t.AudioContext || t.webkitAudioContext || null;
  }
  /**
   * Get OfflineAudioContext class, if not supported returns `null`
   * @type {OfflineAudioContext}
   * @readonly
   */
  static get OfflineAudioContext() {
    const t = window;
    return t.OfflineAudioContext || t.webkitOfflineAudioContext || null;
  }
  /** Destroy this context. */
  destroy() {
    super.destroy();
    const t = this._ctx;
    typeof t.close < "u" && t.close(), globalThis.removeEventListener("focus", this.onFocus), globalThis.removeEventListener("blur", this.onBlur), this.events.removeAllListeners(), this.analyser.disconnect(), this.compressor.disconnect(), this.analyser = null, this.compressor = null, this.events = null, this._offlineCtx = null, this._ctx = null;
  }
  /**
   * The WebAudio API AudioContext object.
   * @readonly
   * @type {AudioContext}
   */
  get audioContext() {
    return this._ctx;
  }
  /**
   * The WebAudio API OfflineAudioContext object.
   * @readonly
   * @type {OfflineAudioContext}
   */
  get offlineContext() {
    return this._offlineCtx;
  }
  /**
   * Pauses all sounds, even though we handle this at the instance
   * level, we'll also pause the audioContext so that the
   * time used to compute progress isn't messed up.
   * @default false
   */
  set paused(t) {
    t && this._ctx.state === "running" ? this._ctx.suspend() : !t && this._ctx.state === "suspended" && this._ctx.resume(), this._paused = t;
  }
  get paused() {
    return this._paused;
  }
  /** Emit event when muted, volume or speed changes */
  refresh() {
    this.events.emit("refresh");
  }
  /** Emit event when muted, volume or speed changes */
  refreshPaused() {
    this.events.emit("refreshPaused");
  }
  /**
   * Toggles the muted state.
   * @return The current muted state.
   */
  toggleMute() {
    return this.muted = !this.muted, this.refresh(), this.muted;
  }
  /**
   * Toggles the paused state.
   * @return The current muted state.
   */
  togglePause() {
    return this.paused = !this.paused, this.refreshPaused(), this._paused;
  }
  /**
   * Decode the audio data
   * @param arrayBuffer - Buffer from loader
   * @param callback - When completed, error and audioBuffer are parameters.
   */
  decode(t, e) {
    const n = (s) => {
      e(new Error((s == null ? void 0 : s.message) || "Unable to decode file"));
    }, r = this._offlineCtx.decodeAudioData(
      t,
      (s) => {
        e(null, s);
      },
      n
    );
    r && r.catch(n);
  }
}
class cA {
  constructor() {
    this.init();
  }
  /**
   * Re-initialize the sound library, this will
   * recreate the AudioContext. If there's a hardware-failure
   * call `close` and then `init`.
   * @return Sound instance
   */
  init() {
    return this.supported && (this._webAudioContext = new js()), this._htmlAudioContext = new eA(), this._sounds = {}, this.useLegacy = !this.supported, this;
  }
  /**
   * The global context to use.
   * @readonly
   */
  get context() {
    return this._context;
  }
  /**
   * Apply filters to all sounds. Can be useful
   * for setting global planning or global effects.
   * **Only supported with WebAudio.**
   * @example
   * import { sound, filters } from '@pixi/sound';
   * // Adds a filter to pan all output left
   * sound.filtersAll = [
   *     new filters.StereoFilter(-1)
   * ];
   */
  get filtersAll() {
    return this.useLegacy ? [] : this._context.filters;
  }
  set filtersAll(t) {
    this.useLegacy || (this._context.filters = t);
  }
  /**
   * `true` if WebAudio is supported on the current browser.
   */
  get supported() {
    return js.AudioContext !== null;
  }
  /**
   * @ignore
   */
  add(t, e) {
    if (typeof t == "object") {
      const s = {};
      for (const o in t) {
        const a = this._getOptions(
          t[o],
          e
        );
        s[o] = this.add(o, a);
      }
      return s;
    }
    if (console.assert(!this._sounds[t], `Sound with alias ${t} already exists.`), e instanceof ha)
      return this._sounds[t] = e, e;
    const n = this._getOptions(e), r = ha.from(n);
    return this._sounds[t] = r, r;
  }
  /**
   * Internal methods for getting the options object
   * @private
   * @param source - The source options
   * @param overrides - Override default options
   * @return The construction options
   */
  _getOptions(t, e) {
    let n;
    return typeof t == "string" ? n = { url: t } : Array.isArray(t) ? n = { url: t } : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? n = { source: t } : n = t, n = { ...n, ...e || {} }, n;
  }
  /**
   * Do not use WebAudio, force the use of legacy. This **must** be called before loading any files.
   */
  get useLegacy() {
    return this._useLegacy;
  }
  set useLegacy(t) {
    this._useLegacy = t, this._context = !t && this.supported ? this._webAudioContext : this._htmlAudioContext;
  }
  /**
   * This disables auto-pause all playback when the window blurs (WebAudio only).
   * This is helpful to keep from playing sounds when the user switches tabs.
   * However, if you're running content within an iframe, this may be undesirable
   * and you should disable (set to `true`) this behavior.
   * @default false
   */
  get disableAutoPause() {
    return !this._webAudioContext.autoPause;
  }
  set disableAutoPause(t) {
    this._webAudioContext.autoPause = !t;
  }
  /**
   * Removes a sound by alias.
   * @param alias - The sound alias reference.
   * @return Instance for chaining.
   */
  remove(t) {
    return this.exists(t, !0), this._sounds[t].destroy(), delete this._sounds[t], this;
  }
  /**
   * Set the global volume for all sounds. To set per-sound volume see {@link SoundLibrary#volume}.
   */
  get volumeAll() {
    return this._context.volume;
  }
  set volumeAll(t) {
    this._context.volume = t, this._context.refresh();
  }
  /**
   * Set the global speed for all sounds. To set per-sound speed see {@link SoundLibrary#speed}.
   */
  get speedAll() {
    return this._context.speed;
  }
  set speedAll(t) {
    this._context.speed = t, this._context.refresh();
  }
  /**
   * Toggle paused property for all sounds.
   * @return `true` if all sounds are paused.
   */
  togglePauseAll() {
    return this._context.togglePause();
  }
  /**
   * Pauses any playing sounds.
   * @return Instance for chaining.
   */
  pauseAll() {
    return this._context.paused = !0, this._context.refreshPaused(), this;
  }
  /**
   * Resumes any sounds.
   * @return Instance for chaining.
   */
  resumeAll() {
    return this._context.paused = !1, this._context.refreshPaused(), this;
  }
  /**
   * Toggle muted property for all sounds.
   * @return `true` if all sounds are muted.
   */
  toggleMuteAll() {
    return this._context.toggleMute();
  }
  /**
   * Mutes all playing sounds.
   * @return Instance for chaining.
   */
  muteAll() {
    return this._context.muted = !0, this._context.refresh(), this;
  }
  /**
   * Unmutes all playing sounds.
   * @return Instance for chaining.
   */
  unmuteAll() {
    return this._context.muted = !1, this._context.refresh(), this;
  }
  /**
   * Stops and removes all sounds. They cannot be used after this.
   * @return Instance for chaining.
   */
  removeAll() {
    for (const t in this._sounds)
      this._sounds[t].destroy(), delete this._sounds[t];
    return this;
  }
  /**
   * Stops all sounds.
   * @return Instance for chaining.
   */
  stopAll() {
    for (const t in this._sounds)
      this._sounds[t].stop();
    return this;
  }
  /**
   * Checks if a sound by alias exists.
   * @param alias - Check for alias.
   * @param assert - Whether enable console.assert.
   * @return true if the sound exists.
   */
  exists(t, e = !1) {
    const n = !!this._sounds[t];
    return e && console.assert(n, `No sound matching alias '${t}'.`), n;
  }
  /**
   * Convenience function to check to see if any sound is playing.
   * @returns `true` if any sound is currently playing.
   */
  isPlaying() {
    for (const t in this._sounds)
      if (this._sounds[t].isPlaying)
        return !0;
    return !1;
  }
  /**
   * Find a sound by alias.
   * @param alias - The sound alias reference.
   * @return Sound object.
   */
  find(t) {
    return this.exists(t, !0), this._sounds[t];
  }
  /**
   * Plays a sound.
   * @method play
   * @instance
   * @param {string} alias - The sound alias reference.
   * @param {string} sprite - The alias of the sprite to play.
   * @return {IMediaInstance|null} The sound instance, this cannot be reused
   *         after it is done playing. Returns `null` if the sound has not yet loaded.
   */
  /**
   * Plays a sound.
   * @param alias - The sound alias reference.
   * @param {PlayOptions|Function} options - The options or callback when done.
   * @return The sound instance,
   *        this cannot be reused after it is done playing. Returns a Promise if the sound
   *        has not yet loaded.
   */
  play(t, e) {
    return this.find(t).play(e);
  }
  /**
   * Stops a sound.
   * @param alias - The sound alias reference.
   * @return Sound object.
   */
  stop(t) {
    return this.find(t).stop();
  }
  /**
   * Pauses a sound.
   * @param alias - The sound alias reference.
   * @return Sound object.
   */
  pause(t) {
    return this.find(t).pause();
  }
  /**
   * Resumes a sound.
   * @param alias - The sound alias reference.
   * @return Instance for chaining.
   */
  resume(t) {
    return this.find(t).resume();
  }
  /**
   * Get or set the volume for a sound.
   * @param alias - The sound alias reference.
   * @param volume - Optional current volume to set.
   * @return The current volume.
   */
  volume(t, e) {
    const n = this.find(t);
    return e !== void 0 && (n.volume = e), n.volume;
  }
  /**
   * Get or set the speed for a sound.
   * @param alias - The sound alias reference.
   * @param speed - Optional current speed to set.
   * @return The current speed.
   */
  speed(t, e) {
    const n = this.find(t);
    return e !== void 0 && (n.speed = e), n.speed;
  }
  /**
   * Get the length of a sound in seconds.
   * @param alias - The sound alias reference.
   * @return The current duration in seconds.
   */
  duration(t) {
    return this.find(t).duration;
  }
  /**
   * Closes the sound library. This will release/destroy
   * the AudioContext(s). Can be used safely if you want to
   * initialize the sound library later. Use `init` method.
   */
  close() {
    return this.removeAll(), this._sounds = null, this._webAudioContext && (this._webAudioContext.destroy(), this._webAudioContext = null), this._htmlAudioContext && (this._htmlAudioContext.destroy(), this._htmlAudioContext = null), this._context = null, this;
  }
}
const Pp = (i) => {
  var t;
  const e = i.src;
  let n = (t = i == null ? void 0 : i.alias) == null ? void 0 : t[0];
  return (!n || i.src === n) && (n = ae.basename(e, ae.extname(e))), n;
}, uA = {
  extension: X.Asset,
  detection: {
    test: async () => !0,
    add: async (i) => [...i, ...aa.filter((t) => la[t])],
    remove: async (i) => i.filter((t) => i.includes(t))
  },
  loader: {
    name: "sound",
    extension: {
      type: [X.LoadParser],
      priority: Li.High
    },
    /** Should we attempt to load this file? */
    test(i) {
      const t = ae.extname(i).slice(1);
      return !!la[t] || sA.some((e) => i.startsWith(`data:${e}`));
    },
    /** Load the sound file, this is mostly handled by Sound.from() */
    async load(i, t) {
      const e = await new Promise((n, r) => ha.from({
        ...t.data,
        url: i,
        preload: !0,
        loaded(s, o) {
          var a, l;
          s ? r(s) : n(o), (l = (a = t.data) == null ? void 0 : a.loaded) == null || l.call(a, s, o);
        }
      }));
      return zs().add(Pp(t), e), e;
    },
    /** Remove the sound from the library */
    async unload(i, t) {
      zs().remove(Pp(t));
    }
  }
};
ge.add(uA);
tA(new cA());
class dA extends Br {
  constructor() {
    super("Pause"), this.visible = !1, this.zIndex = 1e3;
  }
  async init() {
    this.addComponent(
      new Be({
        label: "overlay",
        resource: {
          fillColor: W.pauseScene.overlayColor,
          rectangle: {
            x: 0,
            y: 0,
            width: W.screen.width,
            height: W.screen.width
          }
        },
        alpha: W.pauseScene.overlayAlpha
      })
    ), this.addComponent(
      new _e({
        label: "title",
        text: W.pauseScene.title,
        fontFamily: W.pauseScene.fontFamily,
        fontSize: W.pauseScene.titleFontSize,
        textColor: W.pauseScene.textColor,
        anchor: { x: 0.5, y: 0.5 },
        horizontalAlignment: "center",
        verticalAlignment: "center",
        margin: { x: 0, y: -50 }
      })
    ), this.addComponent(
      new _e({
        label: "subtitle",
        text: W.pauseScene.subTitle,
        fontFamily: W.pauseScene.fontFamily,
        fontSize: W.pauseScene.subTitleFontSize,
        textColor: W.pauseScene.textColor,
        anchor: { x: 0.5, y: 0.5 },
        horizontalAlignment: "center",
        verticalAlignment: "center",
        margin: { x: 0, y: 50 }
      })
    );
  }
}
let we, ps = !1, ws;
const ty = () => W.screen.width * 1 / W.screen.aspectRatio, Ip = () => {
  const { width: i, height: t, orientation: e } = $w(
    W.gameContainer,
    we.canvas,
    W.screen.width,
    ty()
  );
  (i !== tt.screen.width || t !== tt.screen.height) && (tt.screen.width = i, tt.screen.height = t, we.renderer.resize(i, t), Ie(W.signals.onResize));
  const n = tt.screen.orientation !== e;
  tt.screen.orientation = e, n && Ie(W.signals.onOrientationChange);
}, pA = () => {
  const { start: i } = Wc(
    () => {
      Ip();
    },
    () => {
    },
    100
  );
  new ResizeObserver(() => {
    i();
  }).observe(W.gameContainer), Ip();
}, fA = () => {
  let i = 0, t = 0, e = 0;
  W.debug && setInterval(() => {
    console.log(
      t === 0 ? 0 : Math.floor(e / t)
    ), t = 0, e = 0;
  }, 1e3), we.ticker.maxFPS = W.maxFPS, we.ticker.add((n) => {
    if (W.debug && (e += Math.floor(n.FPS), t++), !ps)
      for (i += n.deltaMS; i >= W.tickIntervalMillis; )
        Ie(W.signals.onTick), Dr.updateEngine(W.tickIntervalMillis), zw(W.tickIntervalMillis), i -= W.tickIntervalMillis;
  });
}, mA = () => {
  let i = !1;
  const { start: t, cancel: e } = Wc(
    () => {
      we.stage.eventMode = "passive";
    },
    () => {
    },
    100,
    0
  ), n = () => {
    ps && (ps = !1, ws.visible = !1, Yw(), t());
  }, r = () => {
    ps || !i || (ps = !0, ws.visible = !0, we.stage.eventMode = "none", qw(), e());
  };
  window.addEventListener(
    "focus",
    () => {
      i = !0;
    },
    { once: !0 }
  ), document.addEventListener("click", () => {
    i = !0, n();
  }), window.addEventListener("blur", () => {
    r();
  }), document.addEventListener("visibilitychange", () => {
    document.hidden && r();
  });
}, fs = async (i) => {
  tt.scene && (tt.scene.destroy(), we.stage.removeChild(tt.scene.object)), tt.scene = i, we.stage.addChild(tt.scene.object), await i.init();
}, gA = async () => {
  W.gameContainer.style.backgroundColor = W.colors.backgroundColor, we = new dm(), await we.init({
    backgroundColor: W.colors.backgroundColor,
    width: W.screen.width,
    height: ty()
  }), W.debug && (globalThis.__PIXI_APP__ = we), W.gameContainer.appendChild(we.canvas), we.canvas.style.position = "absolute", Xw(we.renderer), ws = new dA(), await ws.init(), we.stage.addChild(ws.object), fs(new Zw()), pA(), Uw(), Dr.initEngine(), fA(), mA(), await Promise.all([
    new Promise(
      (i) => setTimeout(i, W.loadingScene.keepAliveTimeMS)
    ),
    (async () => {
      await mi.init({
        basePath: W.assets.basePath,
        manifest: W.assets.manifest
      }), mi.addBundle("extra", W.assets.extra), await Promise.all([
        mi.loadBundle("default"),
        mi.loadBundle("extra")
      ]), Gw();
    })()
  ]), Ie(W.signals.destroyLoadingScene);
}, Gi = (i, t) => Math.floor(Math.random() * (t - i) + i), it = {
  sounds: {
    mainLoop: "main-loop",
    menuLoop: "menu-loop",
    gameOver: "game-over",
    coin: "coin",
    playerHit: "player-hit"
  },
  signals: {
    goToIntro: "goToIntro",
    goToGame: "goToGame",
    chooseCharacter: "chooseCharacter",
    loseLifePoints: "loseLifePoints",
    gameOver: "gameOver",
    moveScreen: "moveScreen",
    updateScore: "updateScore"
  },
  lifePoints: 3,
  creditsUrl: "",
  privacyPolicyUrl: ""
};
class yA extends _e {
  constructor() {
    super({
      label: "cta",
      text: "Click to play",
      fontFamily: "PressStart2P",
      fontSize: 24,
      textColor: 13421772,
      anchor: { x: 0.5, y: 0.5 },
      alpha: 0,
      horizontalAlignment: "center",
      verticalAlignment: "center",
      animations: [
        {
          from: { alpha: 0 },
          to: { alpha: 1 },
          duration: 0.5,
          repeat: -1,
          revert: !0,
          delay: 1.5
        }
      ]
    });
  }
}
class vA extends _e {
  constructor() {
    super({
      label: "logo",
      text: "COUPLES RUN",
      textColor: 16763904,
      fontSize: 128,
      fontFamily: "Lobster",
      anchor: { x: 0.5, y: 0 },
      position: { x: 0, y: 50 },
      strokeColor: 16711680,
      strokeWidth: 7,
      alpha: 0,
      horizontalAlignment: "center",
      landscape: {
        fontSize: 128
      },
      portrait: {
        fontSize: 86
      },
      animations: [
        {
          duration: 1,
          from: { alpha: 0, y: 0 },
          to: { alpha: 1, y: 50 },
          ease: "back.out(2)"
        }
      ]
    });
  }
  _onOrientationChange() {
    this.finishAnimations();
  }
}
const _A = 8, xA = 5;
class bA extends Be {
  constructor() {
    super({
      label: "moving-boy",
      resource: "boy/run/boy-run-1.png",
      anchor: { x: 0, y: 1 },
      position: { x: 130, y: 0 },
      scale: 2,
      verticalAlignment: "bottom",
      margin: { x: 0, y: -55 }
    });
    mt(this, "_runSprite", 0);
    mt(this, "_moveFrame", 0);
  }
  _onTick() {
    this._moveFrame++, this._moveFrame % xA === 0 && (this._moveFrame = 0, this._runSprite = (this._runSprite + 1) % _A, this.texture = `boy/run/boy-run-${this._runSprite + 1}.png`);
  }
}
const wA = 8, AA = 5;
class SA extends Be {
  constructor() {
    super({
      label: "moving-girl",
      resource: "girl/run/girl-run-1.png",
      anchor: { x: 0, y: 1 },
      position: { x: 200, y: 0 },
      scale: 2,
      verticalAlignment: "bottom",
      margin: { x: 0, y: -55 }
    });
    mt(this, "_runSprite", 0);
    mt(this, "_moveFrame", 0);
  }
  _onTick() {
    this._moveFrame++, this._moveFrame % AA === 0 && (this._moveFrame = 0, this._runSprite = (this._runSprite + 1) % wA, this.texture = `girl/run/girl-run-${this._runSprite + 1}.png`);
  }
}
const TA = 2;
class EA extends ei {
  constructor() {
    super({
      label: "moving-platform",
      components: [
        new Us({
          label: "moving-platform-top",
          resource: "platform-top.png",
          onTick: (t) => (t.tilePosition.x--, 1)
        }),
        new Us({
          label: "moving-platform-middle",
          resource: "platform-middle.png",
          onTick: (t) => {
            t.tilePosition.x--;
          }
        })
      ]
    }), this._onResize();
  }
  _onResize() {
    const t = this.getComponent(
      "moving-platform-top"
    ), e = this.getComponent(
      "moving-platform-middle"
    );
    e.width = tt.screen.width, e.height = e.originalHeight * TA, e.position.y = tt.screen.height - e.height, t.width = tt.screen.width, t.position.y = tt.screen.height - e.height - t.height;
  }
}
class CA extends qg {
  constructor() {
    super({
      label: "credits-button",
      url: it.creditsUrl,
      resource: "credits-button.png",
      hoverResource: "credits-button-hover.png",
      disabledResource: "credits-button.png",
      interactive: !0,
      cursor: "pointer",
      position: { x: 155, y: 24 },
      alpha: 0,
      anchor: 0.5,
      scale: 0,
      animations: [
        {
          from: { alpha: 0, scaleX: 0, scaleY: 0 },
          to: { alpha: 1, scaleX: 1, scaleY: 1 },
          duration: 0.5,
          delay: 1.7
        }
      ]
    });
  }
}
class PA extends Qw {
  constructor() {
    super({
      label: "volume-button",
      resource: "volume-on.png",
      hoverResource: "volume-on-hover.png",
      disabledResource: "volume-on.png",
      mutedResource: "volume-off.png",
      mutedHoverResource: "volume-off-hover.png",
      mutedDisabledResource: "volume-off.png",
      interactive: !0,
      cursor: "pointer",
      alpha: 0,
      position: { x: 24, y: 24 },
      scale: 0,
      anchor: 0.5,
      animations: [
        {
          from: { alpha: 0, scaleX: 0, scaleY: 0 },
          to: { alpha: 1, scaleX: 1, scaleY: 1 },
          duration: 0.5,
          delay: 1.5
        }
      ]
    });
  }
}
class IA extends ei {
  constructor() {
    super({
      label: "settings",
      horizontalAlignment: "center",
      verticalAlignment: "bottom",
      width: 230,
      height: 48,
      margin: { x: 0, y: -200 },
      components: [new PA(), new CA()]
    });
  }
}
class RA extends Br {
  constructor() {
    super(...arguments);
    mt(this, "_canContinue", !1);
  }
  async init() {
    this.interactive = !0, this.addComponent(
      new Xg({
        label: "city-bg",
        resource: "city-bg.png"
      })
    ), this.addComponent(new EA()), this.addComponent(new SA()), this.addComponent(new bA()), this.addComponent(new vA()), this.addComponent(new yA()), this.addComponent(new IA()), Gc(it.sounds.mainLoop, {
      loop: !0,
      toVolume: 0.3,
      fadeDuration: 0.5
    }), this.delay(2).then(() => {
      this._canContinue = !0;
    });
  }
  async _onClick() {
    this._canContinue && (this.interactive = !1, await Promise.all([
      jn(W.sounds.click),
      Hc(it.sounds.mainLoop, { fadeDuration: 2 }),
      this.animate({
        from: { alpha: 1 },
        to: { alpha: 0 },
        duration: 2
      })
    ]), Ie(it.signals.goToIntro));
  }
}
const kA = "data:font/woff2;base64,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", MA = "data:font/woff2;base64,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", OA = `The night has fallen deep and the young(?) couple is ready to get married, but a tragedy happens. They're out of drinks in the party. They go out to get more drinks for the guests and they engage into a zombie apocalypse.

Collect as many drinks as you can to increase your score. You lose a life point each time an enemy touches you. It's game over if you lose 3 life points or you fall into a pit. Jump to avoid enemies and pits.`;
class DA extends ei {
  constructor() {
    super({
      label: "introduction-screen",
      alpha: 0
    });
    const t = this.addComponent(
      new _e({
        label: "text",
        text: OA,
        fontFamily: "PressStart2P",
        fontSize: 24,
        textColor: 13421772,
        position: { x: 20, y: 20 },
        wordWrap: !0,
        wordWrapWidth: tt.screen.width - 40,
        align: "justify",
        lineHeight: 40
      })
    ), e = this.addComponent(
      new ja({
        label: "continue-button",
        resource: "continue-button.png",
        hoverResource: "continue-button-hover.png",
        disabledResource: "continue-button.png",
        position: { x: 0, y: t.y + t.height + 40 },
        horizontalAlignment: "center",
        interactive: !1,
        cursor: "pointer",
        anchor: { x: 0.5, y: 0 },
        onClick: async () => {
          e.interactive = !1, await this.animate({
            from: { alpha: 1 },
            to: { alpha: 0 },
            duration: 1
          }), this.parent.showCharacterSelectionScreen();
        }
      })
    );
    this.animate({
      from: { alpha: 0 },
      to: { alpha: 1 },
      duration: 1
    }).then(() => {
      e.interactive = !0;
    });
  }
  _onResize() {
    const t = this.components[0];
    t.wordWrapWidth = tt.screen.width - 40;
    const e = this.components[1];
    e.y = t.y + t.height + 40;
  }
}
const ht = {
  selectedCharacter: "girl",
  started: !1,
  speed: 3,
  originalSpeed: 3,
  score: 0
};
let BA = class extends Be {
  constructor() {
    super({
      label: "boy",
      resource: "boy/boy-selection.png",
      position: { x: 224, y: 79.5 },
      anchor: { x: 0.5, y: 0.5 },
      interactive: !0,
      cursor: "pointer"
    }), this._registerToSignal(
      it.signals.chooseCharacter,
      this._onCharacterSelection
    );
  }
  _onClick() {
    this.interactive = !1, ht.selectedCharacter = "boy", Ie(it.signals.chooseCharacter);
  }
  _onCharacterSelection() {
    ht.selectedCharacter !== "boy" ? this.animate({
      from: { scaleX: 1, scaleY: 1 },
      to: { scaleX: 0, scaleY: 0 },
      duration: 0.2
    }) : this.animate({
      from: { scaleX: 1, scaleY: 1 },
      to: { scaleX: 1.1, scaleY: 1.1 },
      duration: 0.2,
      revert: !0,
      repeat: 1
    });
  }
}, VA = class extends Be {
  constructor() {
    super({
      label: "girl",
      resource: "girl/girl-selection.png",
      position: { x: 64, y: 79.5 },
      anchor: { x: 0.5, y: 0.5 },
      interactive: !0,
      cursor: "pointer"
    }), this._registerToSignal(
      it.signals.chooseCharacter,
      this._onCharacterSelection
    );
  }
  _onClick() {
    this.interactive = !1, ht.selectedCharacter = "girl", Ie(it.signals.chooseCharacter);
  }
  _onCharacterSelection() {
    ht.selectedCharacter !== "girl" ? this.animate({
      from: { scaleX: 1, scaleY: 1 },
      to: { scaleX: 0, scaleY: 0 },
      duration: 0.2
    }) : this.animate({
      from: { scaleX: 1, scaleY: 1 },
      to: { scaleX: 1.1, scaleY: 1.1 },
      duration: 0.2,
      revert: !0,
      repeat: 1
    });
  }
};
class FA extends ei {
  constructor() {
    super({
      label: "character-selection",
      horizontalAlignment: "center",
      width: 288,
      height: 159,
      anchor: { x: 0.5, y: 0 }
    }), this.addComponent(new VA()), this.addComponent(new BA());
  }
}
const LA = "You can make both characters jump by clicking/tapping on the screen. Anastasia can reduce her speed if you click/tap on the screen and hold it for a while. She then jumps higher when you release it. Nikos can perform a double jump if you click/tap on the screen again while jumping.";
class NA extends ei {
  constructor() {
    super({
      label: "character-selection-screen",
      alpha: 0
    });
    const t = this.addComponent(
      new _e({
        label: "text",
        text: LA,
        fontFamily: "PressStart2P",
        fontSize: 24,
        textColor: 13421772,
        position: { x: 20, y: 20 },
        wordWrap: !0,
        wordWrapWidth: tt.screen.width - 40,
        align: "justify",
        lineHeight: 40
      })
    ), e = this.addComponent(
      new _e({
        label: "choose-character",
        text: "Choose Character",
        fontFamily: "PressStart2P",
        fontSize: 24,
        textColor: 16763904,
        anchor: { x: 0.5, y: 0 },
        position: {
          x: 0,
          y: t.y + t.height + 40
        },
        horizontalAlignment: "center"
      })
    ), n = this.addComponent(new FA());
    n.y = e.y + e.height + 40, this.animate({
      from: { alpha: 0 },
      to: { alpha: 1 },
      duration: 1
    }), this._registerToSignal(
      it.signals.chooseCharacter,
      this._onCharacterSelection
    );
  }
  _onResize() {
    const t = this.components[0], e = this.components[1], n = this.components[2];
    t.wordWrapWidth = tt.screen.width - 40, e.y = t.y + t.height + 40, n.y = e.y + e.height + 40;
  }
  async _onCharacterSelection() {
    await Promise.all([
      jn(W.sounds.click),
      this.animate({
        from: { alpha: 1 },
        to: { alpha: 0 },
        duration: 1,
        delay: 0.3
      })
    ]), this.parent.showFormScreen();
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ey = function(i) {
  const t = [];
  let e = 0;
  for (let n = 0; n < i.length; n++) {
    let r = i.charCodeAt(n);
    r < 128 ? t[e++] = r : r < 2048 ? (t[e++] = r >> 6 | 192, t[e++] = r & 63 | 128) : (r & 64512) === 55296 && n + 1 < i.length && (i.charCodeAt(n + 1) & 64512) === 56320 ? (r = 65536 + ((r & 1023) << 10) + (i.charCodeAt(++n) & 1023), t[e++] = r >> 18 | 240, t[e++] = r >> 12 & 63 | 128, t[e++] = r >> 6 & 63 | 128, t[e++] = r & 63 | 128) : (t[e++] = r >> 12 | 224, t[e++] = r >> 6 & 63 | 128, t[e++] = r & 63 | 128);
  }
  return t;
}, UA = function(i) {
  const t = [];
  let e = 0, n = 0;
  for (; e < i.length; ) {
    const r = i[e++];
    if (r < 128)
      t[n++] = String.fromCharCode(r);
    else if (r > 191 && r < 224) {
      const s = i[e++];
      t[n++] = String.fromCharCode((r & 31) << 6 | s & 63);
    } else if (r > 239 && r < 365) {
      const s = i[e++], o = i[e++], a = i[e++], l = ((r & 7) << 18 | (s & 63) << 12 | (o & 63) << 6 | a & 63) - 65536;
      t[n++] = String.fromCharCode(55296 + (l >> 10)), t[n++] = String.fromCharCode(56320 + (l & 1023));
    } else {
      const s = i[e++], o = i[e++];
      t[n++] = String.fromCharCode((r & 15) << 12 | (s & 63) << 6 | o & 63);
    }
  }
  return t.join("");
}, iy = {
  /**
   * Maps bytes to characters.
   */
  byteToCharMap_: null,
  /**
   * Maps characters to bytes.
   */
  charToByteMap_: null,
  /**
   * Maps bytes to websafe characters.
   * @private
   */
  byteToCharMapWebSafe_: null,
  /**
   * Maps websafe characters to bytes.
   * @private
   */
  charToByteMapWebSafe_: null,
  /**
   * Our default alphabet, shared between
   * ENCODED_VALS and ENCODED_VALS_WEBSAFE
   */
  ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
  /**
   * Our default alphabet. Value 64 (=) is special; it means "nothing."
   */
  get ENCODED_VALS() {
    return this.ENCODED_VALS_BASE + "+/=";
  },
  /**
   * Our websafe alphabet.
   */
  get ENCODED_VALS_WEBSAFE() {
    return this.ENCODED_VALS_BASE + "-_.";
  },
  /**
   * Whether this browser supports the atob and btoa functions. This extension
   * started at Mozilla but is now implemented by many browsers. We use the
   * ASSUME_* variables to avoid pulling in the full useragent detection library
   * but still allowing the standard per-browser compilations.
   *
   */
  HAS_NATIVE_SUPPORT: typeof atob == "function",
  /**
   * Base64-encode an array of bytes.
   *
   * @param input An array of bytes (numbers with
   *     value in [0, 255]) to encode.
   * @param webSafe Boolean indicating we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeByteArray(i, t) {
    if (!Array.isArray(i))
      throw Error("encodeByteArray takes an array as a parameter");
    this.init_();
    const e = t ? this.byteToCharMapWebSafe_ : this.byteToCharMap_, n = [];
    for (let r = 0; r < i.length; r += 3) {
      const s = i[r], o = r + 1 < i.length, a = o ? i[r + 1] : 0, l = r + 2 < i.length, h = l ? i[r + 2] : 0, c = s >> 2, p = (s & 3) << 4 | a >> 4;
      let f = (a & 15) << 2 | h >> 6, d = h & 63;
      l || (d = 64, o || (f = 64)), n.push(e[c], e[p], e[f], e[d]);
    }
    return n.join("");
  },
  /**
   * Base64-encode a string.
   *
   * @param input A string to encode.
   * @param webSafe If true, we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeString(i, t) {
    return this.HAS_NATIVE_SUPPORT && !t ? btoa(i) : this.encodeByteArray(ey(i), t);
  },
  /**
   * Base64-decode a string.
   *
   * @param input to decode.
   * @param webSafe True if we should use the
   *     alternative alphabet.
   * @return string representing the decoded value.
   */
  decodeString(i, t) {
    return this.HAS_NATIVE_SUPPORT && !t ? atob(i) : UA(this.decodeStringToByteArray(i, t));
  },
  /**
   * Base64-decode a string.
   *
   * In base-64 decoding, groups of four characters are converted into three
   * bytes.  If the encoder did not apply padding, the input length may not
   * be a multiple of 4.
   *
   * In this case, the last group will have fewer than 4 characters, and
   * padding will be inferred.  If the group has one or two characters, it decodes
   * to one byte.  If the group has three characters, it decodes to two bytes.
   *
   * @param input Input to decode.
   * @param webSafe True if we should use the web-safe alphabet.
   * @return bytes representing the decoded value.
   */
  decodeStringToByteArray(i, t) {
    this.init_();
    const e = t ? this.charToByteMapWebSafe_ : this.charToByteMap_, n = [];
    for (let r = 0; r < i.length; ) {
      const s = e[i.charAt(r++)], a = r < i.length ? e[i.charAt(r)] : 0;
      ++r;
      const h = r < i.length ? e[i.charAt(r)] : 64;
      ++r;
      const p = r < i.length ? e[i.charAt(r)] : 64;
      if (++r, s == null || a == null || h == null || p == null)
        throw new zA();
      const f = s << 2 | a >> 4;
      if (n.push(f), h !== 64) {
        const d = a << 4 & 240 | h >> 2;
        if (n.push(d), p !== 64) {
          const m = h << 6 & 192 | p;
          n.push(m);
        }
      }
    }
    return n;
  },
  /**
   * Lazy static initialization function. Called before
   * accessing any of the static map variables.
   * @private
   */
  init_() {
    if (!this.byteToCharMap_) {
      this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {};
      for (let i = 0; i < this.ENCODED_VALS.length; i++)
        this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i), this.charToByteMap_[this.byteToCharMap_[i]] = i, this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i, i >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i);
    }
  }
};
class zA extends Error {
  constructor() {
    super(...arguments), this.name = "DecodeBase64StringError";
  }
}
const jA = function(i) {
  const t = ey(i);
  return iy.encodeByteArray(t, !0);
}, ca = function(i) {
  return jA(i).replace(/\./g, "");
}, GA = function(i) {
  try {
    return iy.decodeString(i, !0);
  } catch (t) {
    console.error("base64Decode failed: ", t);
  }
  return null;
};
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function HA() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw new Error("Unable to locate global object.");
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const WA = () => HA().__FIREBASE_DEFAULTS__, qA = () => {
  if (typeof process > "u" || typeof process.env > "u")
    return;
  const i = process.env.__FIREBASE_DEFAULTS__;
  if (i)
    return JSON.parse(i);
}, YA = () => {
  if (typeof document > "u")
    return;
  let i;
  try {
    i = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
  } catch {
    return;
  }
  const t = i && GA(i[1]);
  return t && JSON.parse(t);
}, qc = () => {
  try {
    return WA() || qA() || YA();
  } catch (i) {
    console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${i}`);
    return;
  }
}, XA = (i) => {
  var t, e;
  return (e = (t = qc()) === null || t === void 0 ? void 0 : t.emulatorHosts) === null || e === void 0 ? void 0 : e[i];
}, KA = (i) => {
  const t = XA(i);
  if (!t)
    return;
  const e = t.lastIndexOf(":");
  if (e <= 0 || e + 1 === t.length)
    throw new Error(`Invalid host ${t} with no separate hostname and port!`);
  const n = parseInt(t.substring(e + 1), 10);
  return t[0] === "[" ? [t.substring(1, e - 1), n] : [t.substring(0, e), n];
}, ny = () => {
  var i;
  return (i = qc()) === null || i === void 0 ? void 0 : i.config;
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class QA {
  constructor() {
    this.reject = () => {
    }, this.resolve = () => {
    }, this.promise = new Promise((t, e) => {
      this.resolve = t, this.reject = e;
    });
  }
  /**
   * Our API internals are not promisified and cannot because our callback APIs have subtle expectations around
   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
   * and returns a node-style callback which will resolve or reject the Deferred's promise.
   */
  wrapCallback(t) {
    return (e, n) => {
      e ? this.reject(e) : this.resolve(n), typeof t == "function" && (this.promise.catch(() => {
      }), t.length === 1 ? t(e) : t(e, n));
    };
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function JA(i, t) {
  if (i.uid)
    throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
  const e = {
    alg: "none",
    type: "JWT"
  }, n = t || "demo-project", r = i.iat || 0, s = i.sub || i.user_id;
  if (!s)
    throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
  const o = Object.assign({
    // Set all required fields to decent defaults
    iss: `https://securetoken.google.com/${n}`,
    aud: n,
    iat: r,
    exp: r + 3600,
    auth_time: r,
    sub: s,
    user_id: s,
    firebase: {
      sign_in_provider: "custom",
      identities: {}
    }
  }, i);
  return [
    ca(JSON.stringify(e)),
    ca(JSON.stringify(o)),
    ""
  ].join(".");
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ZA() {
  return typeof navigator < "u" && typeof navigator.userAgent == "string" ? navigator.userAgent : "";
}
function $A() {
  var i;
  const t = (i = qc()) === null || i === void 0 ? void 0 : i.forceEnvironment;
  if (t === "node")
    return !0;
  if (t === "browser")
    return !1;
  try {
    return Object.prototype.toString.call(global.process) === "[object process]";
  } catch {
    return !1;
  }
}
function tS() {
  return !$A() && !!navigator.userAgent && navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome");
}
function eS() {
  try {
    return typeof indexedDB == "object";
  } catch {
    return !1;
  }
}
function iS() {
  return new Promise((i, t) => {
    try {
      let e = !0;
      const n = "validate-browser-context-for-indexeddb-analytics-module", r = self.indexedDB.open(n);
      r.onsuccess = () => {
        r.result.close(), e || self.indexedDB.deleteDatabase(n), i(!0);
      }, r.onupgradeneeded = () => {
        e = !1;
      }, r.onerror = () => {
        var s;
        t(((s = r.error) === null || s === void 0 ? void 0 : s.message) || "");
      };
    } catch (e) {
      t(e);
    }
  });
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const nS = "FirebaseError";
class Vr extends Error {
  constructor(t, e, n) {
    super(e), this.code = t, this.customData = n, this.name = nS, Object.setPrototypeOf(this, Vr.prototype), Error.captureStackTrace && Error.captureStackTrace(this, ry.prototype.create);
  }
}
class ry {
  constructor(t, e, n) {
    this.service = t, this.serviceName = e, this.errors = n;
  }
  create(t, ...e) {
    const n = e[0] || {}, r = `${this.service}/${t}`, s = this.errors[t], o = s ? rS(s, n) : "Error", a = `${this.serviceName}: ${o} (${r}).`;
    return new Vr(r, a, n);
  }
}
function rS(i, t) {
  return i.replace(sS, (e, n) => {
    const r = t[n];
    return r != null ? String(r) : `<${n}?>`;
  });
}
const sS = /\{\$([^}]+)}/g;
function Yh(i, t) {
  if (i === t)
    return !0;
  const e = Object.keys(i), n = Object.keys(t);
  for (const r of e) {
    if (!n.includes(r))
      return !1;
    const s = i[r], o = t[r];
    if (Rp(s) && Rp(o)) {
      if (!Yh(s, o))
        return !1;
    } else if (s !== o)
      return !1;
  }
  for (const r of n)
    if (!e.includes(r))
      return !1;
  return !0;
}
function Rp(i) {
  return i !== null && typeof i == "object";
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ua(i) {
  return i && i._delegate ? i._delegate : i;
}
class Gs {
  /**
   *
   * @param name The public service name, e.g. app, auth, firestore, database
   * @param instanceFactory Service factory responsible for creating the public interface
   * @param type whether the service provided by the component is public or private
   */
  constructor(t, e, n) {
    this.name = t, this.instanceFactory = e, this.type = n, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null;
  }
  setInstantiationMode(t) {
    return this.instantiationMode = t, this;
  }
  setMultipleInstances(t) {
    return this.multipleInstances = t, this;
  }
  setServiceProps(t) {
    return this.serviceProps = t, this;
  }
  setInstanceCreatedCallback(t) {
    return this.onInstanceCreated = t, this;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _n = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class oS {
  constructor(t, e) {
    this.name = t, this.container = e, this.component = null, this.instances = /* @__PURE__ */ new Map(), this.instancesDeferred = /* @__PURE__ */ new Map(), this.instancesOptions = /* @__PURE__ */ new Map(), this.onInitCallbacks = /* @__PURE__ */ new Map();
  }
  /**
   * @param identifier A provider can provide multiple instances of a service
   * if this.component.multipleInstances is true.
   */
  get(t) {
    const e = this.normalizeInstanceIdentifier(t);
    if (!this.instancesDeferred.has(e)) {
      const n = new QA();
      if (this.instancesDeferred.set(e, n), this.isInitialized(e) || this.shouldAutoInitialize())
        try {
          const r = this.getOrInitializeService({
            instanceIdentifier: e
          });
          r && n.resolve(r);
        } catch {
        }
    }
    return this.instancesDeferred.get(e).promise;
  }
  getImmediate(t) {
    var e;
    const n = this.normalizeInstanceIdentifier(t == null ? void 0 : t.identifier), r = (e = t == null ? void 0 : t.optional) !== null && e !== void 0 ? e : !1;
    if (this.isInitialized(n) || this.shouldAutoInitialize())
      try {
        return this.getOrInitializeService({
          instanceIdentifier: n
        });
      } catch (s) {
        if (r)
          return null;
        throw s;
      }
    else {
      if (r)
        return null;
      throw Error(`Service ${this.name} is not available`);
    }
  }
  getComponent() {
    return this.component;
  }
  setComponent(t) {
    if (t.name !== this.name)
      throw Error(`Mismatching Component ${t.name} for Provider ${this.name}.`);
    if (this.component)
      throw Error(`Component for ${this.name} has already been provided`);
    if (this.component = t, !!this.shouldAutoInitialize()) {
      if (lS(t))
        try {
          this.getOrInitializeService({ instanceIdentifier: _n });
        } catch {
        }
      for (const [e, n] of this.instancesDeferred.entries()) {
        const r = this.normalizeInstanceIdentifier(e);
        try {
          const s = this.getOrInitializeService({
            instanceIdentifier: r
          });
          n.resolve(s);
        } catch {
        }
      }
    }
  }
  clearInstance(t = _n) {
    this.instancesDeferred.delete(t), this.instancesOptions.delete(t), this.instances.delete(t);
  }
  // app.delete() will call this method on every provider to delete the services
  // TODO: should we mark the provider as deleted?
  async delete() {
    const t = Array.from(this.instances.values());
    await Promise.all([
      ...t.filter((e) => "INTERNAL" in e).map((e) => e.INTERNAL.delete()),
      ...t.filter((e) => "_delete" in e).map((e) => e._delete())
    ]);
  }
  isComponentSet() {
    return this.component != null;
  }
  isInitialized(t = _n) {
    return this.instances.has(t);
  }
  getOptions(t = _n) {
    return this.instancesOptions.get(t) || {};
  }
  initialize(t = {}) {
    const { options: e = {} } = t, n = this.normalizeInstanceIdentifier(t.instanceIdentifier);
    if (this.isInitialized(n))
      throw Error(`${this.name}(${n}) has already been initialized`);
    if (!this.isComponentSet())
      throw Error(`Component ${this.name} has not been registered yet`);
    const r = this.getOrInitializeService({
      instanceIdentifier: n,
      options: e
    });
    for (const [s, o] of this.instancesDeferred.entries()) {
      const a = this.normalizeInstanceIdentifier(s);
      n === a && o.resolve(r);
    }
    return r;
  }
  /**
   *
   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
   *
   * @param identifier An optional instance identifier
   * @returns a function to unregister the callback
   */
  onInit(t, e) {
    var n;
    const r = this.normalizeInstanceIdentifier(e), s = (n = this.onInitCallbacks.get(r)) !== null && n !== void 0 ? n : /* @__PURE__ */ new Set();
    s.add(t), this.onInitCallbacks.set(r, s);
    const o = this.instances.get(r);
    return o && t(o, r), () => {
      s.delete(t);
    };
  }
  /**
   * Invoke onInit callbacks synchronously
   * @param instance the service instance`
   */
  invokeOnInitCallbacks(t, e) {
    const n = this.onInitCallbacks.get(e);
    if (n)
      for (const r of n)
        try {
          r(t, e);
        } catch {
        }
  }
  getOrInitializeService({ instanceIdentifier: t, options: e = {} }) {
    let n = this.instances.get(t);
    if (!n && this.component && (n = this.component.instanceFactory(this.container, {
      instanceIdentifier: aS(t),
      options: e
    }), this.instances.set(t, n), this.instancesOptions.set(t, e), this.invokeOnInitCallbacks(n, t), this.component.onInstanceCreated))
      try {
        this.component.onInstanceCreated(this.container, t, n);
      } catch {
      }
    return n || null;
  }
  normalizeInstanceIdentifier(t = _n) {
    return this.component ? this.component.multipleInstances ? t : _n : t;
  }
  shouldAutoInitialize() {
    return !!this.component && this.component.instantiationMode !== "EXPLICIT";
  }
}
function aS(i) {
  return i === _n ? void 0 : i;
}
function lS(i) {
  return i.instantiationMode === "EAGER";
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class hS {
  constructor(t) {
    this.name = t, this.providers = /* @__PURE__ */ new Map();
  }
  /**
   *
   * @param component Component being added
   * @param overwrite When a component with the same name has already been registered,
   * if overwrite is true: overwrite the existing component with the new component and create a new
   * provider with the new component. It can be useful in tests where you want to use different mocks
   * for different tests.
   * if overwrite is false: throw an exception
   */
  addComponent(t) {
    const e = this.getProvider(t.name);
    if (e.isComponentSet())
      throw new Error(`Component ${t.name} has already been registered with ${this.name}`);
    e.setComponent(t);
  }
  addOrOverwriteComponent(t) {
    this.getProvider(t.name).isComponentSet() && this.providers.delete(t.name), this.addComponent(t);
  }
  /**
   * getProvider provides a type safe interface where it can only be called with a field name
   * present in NameServiceMapping interface.
   *
   * Firebase SDKs providing services should extend NameServiceMapping interface to register
   * themselves.
   */
  getProvider(t) {
    if (this.providers.has(t))
      return this.providers.get(t);
    const e = new oS(t, this);
    return this.providers.set(t, e), e;
  }
  getProviders() {
    return Array.from(this.providers.values());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var at;
(function(i) {
  i[i.DEBUG = 0] = "DEBUG", i[i.VERBOSE = 1] = "VERBOSE", i[i.INFO = 2] = "INFO", i[i.WARN = 3] = "WARN", i[i.ERROR = 4] = "ERROR", i[i.SILENT = 5] = "SILENT";
})(at || (at = {}));
const cS = {
  debug: at.DEBUG,
  verbose: at.VERBOSE,
  info: at.INFO,
  warn: at.WARN,
  error: at.ERROR,
  silent: at.SILENT
}, uS = at.INFO, dS = {
  [at.DEBUG]: "log",
  [at.VERBOSE]: "log",
  [at.INFO]: "info",
  [at.WARN]: "warn",
  [at.ERROR]: "error"
}, pS = (i, t, ...e) => {
  if (t < i.logLevel)
    return;
  const n = (/* @__PURE__ */ new Date()).toISOString(), r = dS[t];
  if (r)
    console[r](`[${n}]  ${i.name}:`, ...e);
  else
    throw new Error(`Attempted to log a message with an invalid logType (value: ${t})`);
};
class sy {
  /**
   * Gives you an instance of a Logger to capture messages according to
   * Firebase's logging scheme.
   *
   * @param name The name that the logs will be associated with
   */
  constructor(t) {
    this.name = t, this._logLevel = uS, this._logHandler = pS, this._userLogHandler = null;
  }
  get logLevel() {
    return this._logLevel;
  }
  set logLevel(t) {
    if (!(t in at))
      throw new TypeError(`Invalid value "${t}" assigned to \`logLevel\``);
    this._logLevel = t;
  }
  // Workaround for setter/getter having to be the same type.
  setLogLevel(t) {
    this._logLevel = typeof t == "string" ? cS[t] : t;
  }
  get logHandler() {
    return this._logHandler;
  }
  set logHandler(t) {
    if (typeof t != "function")
      throw new TypeError("Value assigned to `logHandler` must be a function");
    this._logHandler = t;
  }
  get userLogHandler() {
    return this._userLogHandler;
  }
  set userLogHandler(t) {
    this._userLogHandler = t;
  }
  /**
   * The functions below are all based on the `console` interface
   */
  debug(...t) {
    this._userLogHandler && this._userLogHandler(this, at.DEBUG, ...t), this._logHandler(this, at.DEBUG, ...t);
  }
  log(...t) {
    this._userLogHandler && this._userLogHandler(this, at.VERBOSE, ...t), this._logHandler(this, at.VERBOSE, ...t);
  }
  info(...t) {
    this._userLogHandler && this._userLogHandler(this, at.INFO, ...t), this._logHandler(this, at.INFO, ...t);
  }
  warn(...t) {
    this._userLogHandler && this._userLogHandler(this, at.WARN, ...t), this._logHandler(this, at.WARN, ...t);
  }
  error(...t) {
    this._userLogHandler && this._userLogHandler(this, at.ERROR, ...t), this._logHandler(this, at.ERROR, ...t);
  }
}
const fS = (i, t) => t.some((e) => i instanceof e);
let kp, Mp;
function mS() {
  return kp || (kp = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function gS() {
  return Mp || (Mp = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const oy = /* @__PURE__ */ new WeakMap(), Xh = /* @__PURE__ */ new WeakMap(), ay = /* @__PURE__ */ new WeakMap(), Jl = /* @__PURE__ */ new WeakMap(), Yc = /* @__PURE__ */ new WeakMap();
function yS(i) {
  const t = new Promise((e, n) => {
    const r = () => {
      i.removeEventListener("success", s), i.removeEventListener("error", o);
    }, s = () => {
      e(Ki(i.result)), r();
    }, o = () => {
      n(i.error), r();
    };
    i.addEventListener("success", s), i.addEventListener("error", o);
  });
  return t.then((e) => {
    e instanceof IDBCursor && oy.set(e, i);
  }).catch(() => {
  }), Yc.set(t, i), t;
}
function vS(i) {
  if (Xh.has(i))
    return;
  const t = new Promise((e, n) => {
    const r = () => {
      i.removeEventListener("complete", s), i.removeEventListener("error", o), i.removeEventListener("abort", o);
    }, s = () => {
      e(), r();
    }, o = () => {
      n(i.error || new DOMException("AbortError", "AbortError")), r();
    };
    i.addEventListener("complete", s), i.addEventListener("error", o), i.addEventListener("abort", o);
  });
  Xh.set(i, t);
}
let Kh = {
  get(i, t, e) {
    if (i instanceof IDBTransaction) {
      if (t === "done")
        return Xh.get(i);
      if (t === "objectStoreNames")
        return i.objectStoreNames || ay.get(i);
      if (t === "store")
        return e.objectStoreNames[1] ? void 0 : e.objectStore(e.objectStoreNames[0]);
    }
    return Ki(i[t]);
  },
  set(i, t, e) {
    return i[t] = e, !0;
  },
  has(i, t) {
    return i instanceof IDBTransaction && (t === "done" || t === "store") ? !0 : t in i;
  }
};
function _S(i) {
  Kh = i(Kh);
}
function xS(i) {
  return i === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(t, ...e) {
    const n = i.call(Zl(this), t, ...e);
    return ay.set(n, t.sort ? t.sort() : [t]), Ki(n);
  } : gS().includes(i) ? function(...t) {
    return i.apply(Zl(this), t), Ki(oy.get(this));
  } : function(...t) {
    return Ki(i.apply(Zl(this), t));
  };
}
function bS(i) {
  return typeof i == "function" ? xS(i) : (i instanceof IDBTransaction && vS(i), fS(i, mS()) ? new Proxy(i, Kh) : i);
}
function Ki(i) {
  if (i instanceof IDBRequest)
    return yS(i);
  if (Jl.has(i))
    return Jl.get(i);
  const t = bS(i);
  return t !== i && (Jl.set(i, t), Yc.set(t, i)), t;
}
const Zl = (i) => Yc.get(i);
function wS(i, t, { blocked: e, upgrade: n, blocking: r, terminated: s } = {}) {
  const o = indexedDB.open(i, t), a = Ki(o);
  return n && o.addEventListener("upgradeneeded", (l) => {
    n(Ki(o.result), l.oldVersion, l.newVersion, Ki(o.transaction), l);
  }), e && o.addEventListener("blocked", (l) => e(
    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
    l.oldVersion,
    l.newVersion,
    l
  )), a.then((l) => {
    s && l.addEventListener("close", () => s()), r && l.addEventListener("versionchange", (h) => r(h.oldVersion, h.newVersion, h));
  }).catch(() => {
  }), a;
}
const AS = ["get", "getKey", "getAll", "getAllKeys", "count"], SS = ["put", "add", "delete", "clear"], $l = /* @__PURE__ */ new Map();
function Op(i, t) {
  if (!(i instanceof IDBDatabase && !(t in i) && typeof t == "string"))
    return;
  if ($l.get(t))
    return $l.get(t);
  const e = t.replace(/FromIndex$/, ""), n = t !== e, r = SS.includes(e);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(e in (n ? IDBIndex : IDBObjectStore).prototype) || !(r || AS.includes(e))
  )
    return;
  const s = async function(o, ...a) {
    const l = this.transaction(o, r ? "readwrite" : "readonly");
    let h = l.store;
    return n && (h = h.index(a.shift())), (await Promise.all([
      h[e](...a),
      r && l.done
    ]))[0];
  };
  return $l.set(t, s), s;
}
_S((i) => ({
  ...i,
  get: (t, e, n) => Op(t, e) || i.get(t, e, n),
  has: (t, e) => !!Op(t, e) || i.has(t, e)
}));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TS {
  constructor(t) {
    this.container = t;
  }
  // In initial implementation, this will be called by installations on
  // auth token refresh, and installations will send this string.
  getPlatformInfoString() {
    return this.container.getProviders().map((e) => {
      if (ES(e)) {
        const n = e.getImmediate();
        return `${n.library}/${n.version}`;
      } else
        return null;
    }).filter((e) => e).join(" ");
  }
}
function ES(i) {
  const t = i.getComponent();
  return (t == null ? void 0 : t.type) === "VERSION";
}
const Qh = "@firebase/app", Dp = "0.10.16";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Fi = new sy("@firebase/app"), CS = "@firebase/app-compat", PS = "@firebase/analytics-compat", IS = "@firebase/analytics", RS = "@firebase/app-check-compat", kS = "@firebase/app-check", MS = "@firebase/auth", OS = "@firebase/auth-compat", DS = "@firebase/database", BS = "@firebase/data-connect", VS = "@firebase/database-compat", FS = "@firebase/functions", LS = "@firebase/functions-compat", NS = "@firebase/installations", US = "@firebase/installations-compat", zS = "@firebase/messaging", jS = "@firebase/messaging-compat", GS = "@firebase/performance", HS = "@firebase/performance-compat", WS = "@firebase/remote-config", qS = "@firebase/remote-config-compat", YS = "@firebase/storage", XS = "@firebase/storage-compat", KS = "@firebase/firestore", QS = "@firebase/vertexai", JS = "@firebase/firestore-compat", ZS = "firebase", $S = "11.0.2";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Jh = "[DEFAULT]", tT = {
  [Qh]: "fire-core",
  [CS]: "fire-core-compat",
  [IS]: "fire-analytics",
  [PS]: "fire-analytics-compat",
  [kS]: "fire-app-check",
  [RS]: "fire-app-check-compat",
  [MS]: "fire-auth",
  [OS]: "fire-auth-compat",
  [DS]: "fire-rtdb",
  [BS]: "fire-data-connect",
  [VS]: "fire-rtdb-compat",
  [FS]: "fire-fn",
  [LS]: "fire-fn-compat",
  [NS]: "fire-iid",
  [US]: "fire-iid-compat",
  [zS]: "fire-fcm",
  [jS]: "fire-fcm-compat",
  [GS]: "fire-perf",
  [HS]: "fire-perf-compat",
  [WS]: "fire-rc",
  [qS]: "fire-rc-compat",
  [YS]: "fire-gcs",
  [XS]: "fire-gcs-compat",
  [KS]: "fire-fst",
  [JS]: "fire-fst-compat",
  [QS]: "fire-vertex",
  "fire-js": "fire-js",
  // Platform identifier for JS SDK.
  [ZS]: "fire-js-all"
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const da = /* @__PURE__ */ new Map(), eT = /* @__PURE__ */ new Map(), Zh = /* @__PURE__ */ new Map();
function Bp(i, t) {
  try {
    i.container.addComponent(t);
  } catch (e) {
    Fi.debug(`Component ${t.name} failed to register with FirebaseApp ${i.name}`, e);
  }
}
function pa(i) {
  const t = i.name;
  if (Zh.has(t))
    return Fi.debug(`There were multiple attempts to register component ${t}.`), !1;
  Zh.set(t, i);
  for (const e of da.values())
    Bp(e, i);
  for (const e of eT.values())
    Bp(e, i);
  return !0;
}
function iT(i, t) {
  const e = i.container.getProvider("heartbeat").getImmediate({ optional: !0 });
  return e && e.triggerHeartbeat(), i.container.getProvider(t);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const nT = {
  "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first",
  "bad-app-name": "Illegal App name: '{$appName}'",
  "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config",
  "app-deleted": "Firebase App named '{$appName}' already deleted",
  "server-app-deleted": "Firebase Server App has been deleted",
  "no-options": "Need to provide options, when not being deployed to hosting via source.",
  "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.",
  "invalid-log-argument": "First argument to `onLog` must be null or a function.",
  "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.",
  "finalization-registry-not-supported": "FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.",
  "invalid-server-app-environment": "FirebaseServerApp is not for use in browser environments."
}, Qi = new ry("app", "Firebase", nT);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class rT {
  constructor(t, e, n) {
    this._isDeleted = !1, this._options = Object.assign({}, t), this._config = Object.assign({}, e), this._name = e.name, this._automaticDataCollectionEnabled = e.automaticDataCollectionEnabled, this._container = n, this.container.addComponent(new Gs(
      "app",
      () => this,
      "PUBLIC"
      /* ComponentType.PUBLIC */
    ));
  }
  get automaticDataCollectionEnabled() {
    return this.checkDestroyed(), this._automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(t) {
    this.checkDestroyed(), this._automaticDataCollectionEnabled = t;
  }
  get name() {
    return this.checkDestroyed(), this._name;
  }
  get options() {
    return this.checkDestroyed(), this._options;
  }
  get config() {
    return this.checkDestroyed(), this._config;
  }
  get container() {
    return this._container;
  }
  get isDeleted() {
    return this._isDeleted;
  }
  set isDeleted(t) {
    this._isDeleted = t;
  }
  /**
   * This function will throw an Error if the App has already been deleted -
   * use before performing API actions on the App.
   */
  checkDestroyed() {
    if (this.isDeleted)
      throw Qi.create("app-deleted", { appName: this._name });
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const sT = $S;
function ly(i, t = {}) {
  let e = i;
  typeof t != "object" && (t = { name: t });
  const n = Object.assign({ name: Jh, automaticDataCollectionEnabled: !1 }, t), r = n.name;
  if (typeof r != "string" || !r)
    throw Qi.create("bad-app-name", {
      appName: String(r)
    });
  if (e || (e = ny()), !e)
    throw Qi.create(
      "no-options"
      /* AppError.NO_OPTIONS */
    );
  const s = da.get(r);
  if (s) {
    if (Yh(e, s.options) && Yh(n, s.config))
      return s;
    throw Qi.create("duplicate-app", { appName: r });
  }
  const o = new hS(r);
  for (const l of Zh.values())
    o.addComponent(l);
  const a = new rT(e, n, o);
  return da.set(r, a), a;
}
function oT(i = Jh) {
  const t = da.get(i);
  if (!t && i === Jh && ny())
    return ly();
  if (!t)
    throw Qi.create("no-app", { appName: i });
  return t;
}
function fr(i, t, e) {
  var n;
  let r = (n = tT[i]) !== null && n !== void 0 ? n : i;
  e && (r += `-${e}`);
  const s = r.match(/\s|\//), o = t.match(/\s|\//);
  if (s || o) {
    const a = [
      `Unable to register library "${r}" with version "${t}":`
    ];
    s && a.push(`library name "${r}" contains illegal characters (whitespace or "/")`), s && o && a.push("and"), o && a.push(`version name "${t}" contains illegal characters (whitespace or "/")`), Fi.warn(a.join(" "));
    return;
  }
  pa(new Gs(
    `${r}-version`,
    () => ({ library: r, version: t }),
    "VERSION"
    /* ComponentType.VERSION */
  ));
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const aT = "firebase-heartbeat-database", lT = 1, Hs = "firebase-heartbeat-store";
let th = null;
function hy() {
  return th || (th = wS(aT, lT, {
    upgrade: (i, t) => {
      switch (t) {
        case 0:
          try {
            i.createObjectStore(Hs);
          } catch (e) {
            console.warn(e);
          }
      }
    }
  }).catch((i) => {
    throw Qi.create("idb-open", {
      originalErrorMessage: i.message
    });
  })), th;
}
async function hT(i) {
  try {
    const e = (await hy()).transaction(Hs), n = await e.objectStore(Hs).get(cy(i));
    return await e.done, n;
  } catch (t) {
    if (t instanceof Vr)
      Fi.warn(t.message);
    else {
      const e = Qi.create("idb-get", {
        originalErrorMessage: t == null ? void 0 : t.message
      });
      Fi.warn(e.message);
    }
  }
}
async function Vp(i, t) {
  try {
    const n = (await hy()).transaction(Hs, "readwrite");
    await n.objectStore(Hs).put(t, cy(i)), await n.done;
  } catch (e) {
    if (e instanceof Vr)
      Fi.warn(e.message);
    else {
      const n = Qi.create("idb-set", {
        originalErrorMessage: e == null ? void 0 : e.message
      });
      Fi.warn(n.message);
    }
  }
}
function cy(i) {
  return `${i.name}!${i.options.appId}`;
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const cT = 1024, uT = 30 * 24 * 60 * 60 * 1e3;
class dT {
  constructor(t) {
    this.container = t, this._heartbeatsCache = null;
    const e = this.container.getProvider("app").getImmediate();
    this._storage = new fT(e), this._heartbeatsCachePromise = this._storage.read().then((n) => (this._heartbeatsCache = n, n));
  }
  /**
   * Called to report a heartbeat. The function will generate
   * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it
   * to IndexedDB.
   * Note that we only store one heartbeat per day. So if a heartbeat for today is
   * already logged, subsequent calls to this function in the same day will be ignored.
   */
  async triggerHeartbeat() {
    var t, e;
    try {
      const r = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(), s = Fp();
      return ((t = this._heartbeatsCache) === null || t === void 0 ? void 0 : t.heartbeats) == null && (this._heartbeatsCache = await this._heartbeatsCachePromise, ((e = this._heartbeatsCache) === null || e === void 0 ? void 0 : e.heartbeats) == null) || this._heartbeatsCache.lastSentHeartbeatDate === s || this._heartbeatsCache.heartbeats.some((o) => o.date === s) ? void 0 : (this._heartbeatsCache.heartbeats.push({ date: s, agent: r }), this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((o) => {
        const a = new Date(o.date).valueOf();
        return Date.now() - a <= uT;
      }), this._storage.overwrite(this._heartbeatsCache));
    } catch (n) {
      Fi.warn(n);
    }
  }
  /**
   * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.
   * It also clears all heartbeats from memory as well as in IndexedDB.
   *
   * NOTE: Consuming product SDKs should not send the header if this method
   * returns an empty string.
   */
  async getHeartbeatsHeader() {
    var t;
    try {
      if (this._heartbeatsCache === null && await this._heartbeatsCachePromise, ((t = this._heartbeatsCache) === null || t === void 0 ? void 0 : t.heartbeats) == null || this._heartbeatsCache.heartbeats.length === 0)
        return "";
      const e = Fp(), { heartbeatsToSend: n, unsentEntries: r } = pT(this._heartbeatsCache.heartbeats), s = ca(JSON.stringify({ version: 2, heartbeats: n }));
      return this._heartbeatsCache.lastSentHeartbeatDate = e, r.length > 0 ? (this._heartbeatsCache.heartbeats = r, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), s;
    } catch (e) {
      return Fi.warn(e), "";
    }
  }
}
function Fp() {
  return (/* @__PURE__ */ new Date()).toISOString().substring(0, 10);
}
function pT(i, t = cT) {
  const e = [];
  let n = i.slice();
  for (const r of i) {
    const s = e.find((o) => o.agent === r.agent);
    if (s) {
      if (s.dates.push(r.date), Lp(e) > t) {
        s.dates.pop();
        break;
      }
    } else if (e.push({
      agent: r.agent,
      dates: [r.date]
    }), Lp(e) > t) {
      e.pop();
      break;
    }
    n = n.slice(1);
  }
  return {
    heartbeatsToSend: e,
    unsentEntries: n
  };
}
class fT {
  constructor(t) {
    this.app = t, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
  }
  async runIndexedDBEnvironmentCheck() {
    return eS() ? iS().then(() => !0).catch(() => !1) : !1;
  }
  /**
   * Read all heartbeats.
   */
  async read() {
    if (await this._canUseIndexedDBPromise) {
      const e = await hT(this.app);
      return e != null && e.heartbeats ? e : { heartbeats: [] };
    } else
      return { heartbeats: [] };
  }
  // overwrite the storage with the provided heartbeats
  async overwrite(t) {
    var e;
    if (await this._canUseIndexedDBPromise) {
      const r = await this.read();
      return Vp(this.app, {
        lastSentHeartbeatDate: (e = t.lastSentHeartbeatDate) !== null && e !== void 0 ? e : r.lastSentHeartbeatDate,
        heartbeats: t.heartbeats
      });
    } else
      return;
  }
  // add heartbeats
  async add(t) {
    var e;
    if (await this._canUseIndexedDBPromise) {
      const r = await this.read();
      return Vp(this.app, {
        lastSentHeartbeatDate: (e = t.lastSentHeartbeatDate) !== null && e !== void 0 ? e : r.lastSentHeartbeatDate,
        heartbeats: [
          ...r.heartbeats,
          ...t.heartbeats
        ]
      });
    } else
      return;
  }
}
function Lp(i) {
  return ca(
    // heartbeatsCache wrapper properties
    JSON.stringify({ version: 2, heartbeats: i })
  ).length;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function mT(i) {
  pa(new Gs(
    "platform-logger",
    (t) => new TS(t),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), pa(new Gs(
    "heartbeat",
    (t) => new dT(t),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), fr(Qh, Dp, i), fr(Qh, Dp, "esm2017"), fr("fire-js", "");
}
mT("");
var gT = "firebase", yT = "11.0.2";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
fr(gT, yT, "app");
var Np = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
/** @license
Copyright The Closure Library Authors.
SPDX-License-Identifier: Apache-2.0
*/
var uy;
(function() {
  var i;
  /** @license
  
   Copyright The Closure Library Authors.
   SPDX-License-Identifier: Apache-2.0
  */
  function t(w, v) {
    function x() {
    }
    x.prototype = v.prototype, w.D = v.prototype, w.prototype = new x(), w.prototype.constructor = w, w.C = function(A, P, M) {
      for (var k = Array(arguments.length - 2), B = 2; B < arguments.length; B++) k[B - 2] = arguments[B];
      return v.prototype[P].apply(A, k);
    };
  }
  function e() {
    this.blockSize = -1;
  }
  function n() {
    this.blockSize = -1, this.blockSize = 64, this.g = Array(4), this.B = Array(this.blockSize), this.o = this.h = 0, this.s();
  }
  t(n, e), n.prototype.s = function() {
    this.g[0] = 1732584193, this.g[1] = 4023233417, this.g[2] = 2562383102, this.g[3] = 271733878, this.o = this.h = 0;
  };
  function r(w, v, x) {
    x || (x = 0);
    var A = Array(16);
    if (typeof v == "string") for (var P = 0; 16 > P; ++P) A[P] = v.charCodeAt(x++) | v.charCodeAt(x++) << 8 | v.charCodeAt(x++) << 16 | v.charCodeAt(x++) << 24;
    else for (P = 0; 16 > P; ++P) A[P] = v[x++] | v[x++] << 8 | v[x++] << 16 | v[x++] << 24;
    v = w.g[0], x = w.g[1], P = w.g[2];
    var M = w.g[3], k = v + (M ^ x & (P ^ M)) + A[0] + 3614090360 & 4294967295;
    v = x + (k << 7 & 4294967295 | k >>> 25), k = M + (P ^ v & (x ^ P)) + A[1] + 3905402710 & 4294967295, M = v + (k << 12 & 4294967295 | k >>> 20), k = P + (x ^ M & (v ^ x)) + A[2] + 606105819 & 4294967295, P = M + (k << 17 & 4294967295 | k >>> 15), k = x + (v ^ P & (M ^ v)) + A[3] + 3250441966 & 4294967295, x = P + (k << 22 & 4294967295 | k >>> 10), k = v + (M ^ x & (P ^ M)) + A[4] + 4118548399 & 4294967295, v = x + (k << 7 & 4294967295 | k >>> 25), k = M + (P ^ v & (x ^ P)) + A[5] + 1200080426 & 4294967295, M = v + (k << 12 & 4294967295 | k >>> 20), k = P + (x ^ M & (v ^ x)) + A[6] + 2821735955 & 4294967295, P = M + (k << 17 & 4294967295 | k >>> 15), k = x + (v ^ P & (M ^ v)) + A[7] + 4249261313 & 4294967295, x = P + (k << 22 & 4294967295 | k >>> 10), k = v + (M ^ x & (P ^ M)) + A[8] + 1770035416 & 4294967295, v = x + (k << 7 & 4294967295 | k >>> 25), k = M + (P ^ v & (x ^ P)) + A[9] + 2336552879 & 4294967295, M = v + (k << 12 & 4294967295 | k >>> 20), k = P + (x ^ M & (v ^ x)) + A[10] + 4294925233 & 4294967295, P = M + (k << 17 & 4294967295 | k >>> 15), k = x + (v ^ P & (M ^ v)) + A[11] + 2304563134 & 4294967295, x = P + (k << 22 & 4294967295 | k >>> 10), k = v + (M ^ x & (P ^ M)) + A[12] + 1804603682 & 4294967295, v = x + (k << 7 & 4294967295 | k >>> 25), k = M + (P ^ v & (x ^ P)) + A[13] + 4254626195 & 4294967295, M = v + (k << 12 & 4294967295 | k >>> 20), k = P + (x ^ M & (v ^ x)) + A[14] + 2792965006 & 4294967295, P = M + (k << 17 & 4294967295 | k >>> 15), k = x + (v ^ P & (M ^ v)) + A[15] + 1236535329 & 4294967295, x = P + (k << 22 & 4294967295 | k >>> 10), k = v + (P ^ M & (x ^ P)) + A[1] + 4129170786 & 4294967295, v = x + (k << 5 & 4294967295 | k >>> 27), k = M + (x ^ P & (v ^ x)) + A[6] + 3225465664 & 4294967295, M = v + (k << 9 & 4294967295 | k >>> 23), k = P + (v ^ x & (M ^ v)) + A[11] + 643717713 & 4294967295, P = M + (k << 14 & 4294967295 | k >>> 18), k = x + (M ^ v & (P ^ M)) + A[0] + 3921069994 & 4294967295, x = P + (k << 20 & 4294967295 | k >>> 12), k = v + (P ^ M & (x ^ P)) + A[5] + 3593408605 & 4294967295, v = x + (k << 5 & 4294967295 | k >>> 27), k = M + (x ^ P & (v ^ x)) + A[10] + 38016083 & 4294967295, M = v + (k << 9 & 4294967295 | k >>> 23), k = P + (v ^ x & (M ^ v)) + A[15] + 3634488961 & 4294967295, P = M + (k << 14 & 4294967295 | k >>> 18), k = x + (M ^ v & (P ^ M)) + A[4] + 3889429448 & 4294967295, x = P + (k << 20 & 4294967295 | k >>> 12), k = v + (P ^ M & (x ^ P)) + A[9] + 568446438 & 4294967295, v = x + (k << 5 & 4294967295 | k >>> 27), k = M + (x ^ P & (v ^ x)) + A[14] + 3275163606 & 4294967295, M = v + (k << 9 & 4294967295 | k >>> 23), k = P + (v ^ x & (M ^ v)) + A[3] + 4107603335 & 4294967295, P = M + (k << 14 & 4294967295 | k >>> 18), k = x + (M ^ v & (P ^ M)) + A[8] + 1163531501 & 4294967295, x = P + (k << 20 & 4294967295 | k >>> 12), k = v + (P ^ M & (x ^ P)) + A[13] + 2850285829 & 4294967295, v = x + (k << 5 & 4294967295 | k >>> 27), k = M + (x ^ P & (v ^ x)) + A[2] + 4243563512 & 4294967295, M = v + (k << 9 & 4294967295 | k >>> 23), k = P + (v ^ x & (M ^ v)) + A[7] + 1735328473 & 4294967295, P = M + (k << 14 & 4294967295 | k >>> 18), k = x + (M ^ v & (P ^ M)) + A[12] + 2368359562 & 4294967295, x = P + (k << 20 & 4294967295 | k >>> 12), k = v + (x ^ P ^ M) + A[5] + 4294588738 & 4294967295, v = x + (k << 4 & 4294967295 | k >>> 28), k = M + (v ^ x ^ P) + A[8] + 2272392833 & 4294967295, M = v + (k << 11 & 4294967295 | k >>> 21), k = P + (M ^ v ^ x) + A[11] + 1839030562 & 4294967295, P = M + (k << 16 & 4294967295 | k >>> 16), k = x + (P ^ M ^ v) + A[14] + 4259657740 & 4294967295, x = P + (k << 23 & 4294967295 | k >>> 9), k = v + (x ^ P ^ M) + A[1] + 2763975236 & 4294967295, v = x + (k << 4 & 4294967295 | k >>> 28), k = M + (v ^ x ^ P) + A[4] + 1272893353 & 4294967295, M = v + (k << 11 & 4294967295 | k >>> 21), k = P + (M ^ v ^ x) + A[7] + 4139469664 & 4294967295, P = M + (k << 16 & 4294967295 | k >>> 16), k = x + (P ^ M ^ v) + A[10] + 3200236656 & 4294967295, x = P + (k << 23 & 4294967295 | k >>> 9), k = v + (x ^ P ^ M) + A[13] + 681279174 & 4294967295, v = x + (k << 4 & 4294967295 | k >>> 28), k = M + (v ^ x ^ P) + A[0] + 3936430074 & 4294967295, M = v + (k << 11 & 4294967295 | k >>> 21), k = P + (M ^ v ^ x) + A[3] + 3572445317 & 4294967295, P = M + (k << 16 & 4294967295 | k >>> 16), k = x + (P ^ M ^ v) + A[6] + 76029189 & 4294967295, x = P + (k << 23 & 4294967295 | k >>> 9), k = v + (x ^ P ^ M) + A[9] + 3654602809 & 4294967295, v = x + (k << 4 & 4294967295 | k >>> 28), k = M + (v ^ x ^ P) + A[12] + 3873151461 & 4294967295, M = v + (k << 11 & 4294967295 | k >>> 21), k = P + (M ^ v ^ x) + A[15] + 530742520 & 4294967295, P = M + (k << 16 & 4294967295 | k >>> 16), k = x + (P ^ M ^ v) + A[2] + 3299628645 & 4294967295, x = P + (k << 23 & 4294967295 | k >>> 9), k = v + (P ^ (x | ~M)) + A[0] + 4096336452 & 4294967295, v = x + (k << 6 & 4294967295 | k >>> 26), k = M + (x ^ (v | ~P)) + A[7] + 1126891415 & 4294967295, M = v + (k << 10 & 4294967295 | k >>> 22), k = P + (v ^ (M | ~x)) + A[14] + 2878612391 & 4294967295, P = M + (k << 15 & 4294967295 | k >>> 17), k = x + (M ^ (P | ~v)) + A[5] + 4237533241 & 4294967295, x = P + (k << 21 & 4294967295 | k >>> 11), k = v + (P ^ (x | ~M)) + A[12] + 1700485571 & 4294967295, v = x + (k << 6 & 4294967295 | k >>> 26), k = M + (x ^ (v | ~P)) + A[3] + 2399980690 & 4294967295, M = v + (k << 10 & 4294967295 | k >>> 22), k = P + (v ^ (M | ~x)) + A[10] + 4293915773 & 4294967295, P = M + (k << 15 & 4294967295 | k >>> 17), k = x + (M ^ (P | ~v)) + A[1] + 2240044497 & 4294967295, x = P + (k << 21 & 4294967295 | k >>> 11), k = v + (P ^ (x | ~M)) + A[8] + 1873313359 & 4294967295, v = x + (k << 6 & 4294967295 | k >>> 26), k = M + (x ^ (v | ~P)) + A[15] + 4264355552 & 4294967295, M = v + (k << 10 & 4294967295 | k >>> 22), k = P + (v ^ (M | ~x)) + A[6] + 2734768916 & 4294967295, P = M + (k << 15 & 4294967295 | k >>> 17), k = x + (M ^ (P | ~v)) + A[13] + 1309151649 & 4294967295, x = P + (k << 21 & 4294967295 | k >>> 11), k = v + (P ^ (x | ~M)) + A[4] + 4149444226 & 4294967295, v = x + (k << 6 & 4294967295 | k >>> 26), k = M + (x ^ (v | ~P)) + A[11] + 3174756917 & 4294967295, M = v + (k << 10 & 4294967295 | k >>> 22), k = P + (v ^ (M | ~x)) + A[2] + 718787259 & 4294967295, P = M + (k << 15 & 4294967295 | k >>> 17), k = x + (M ^ (P | ~v)) + A[9] + 3951481745 & 4294967295, w.g[0] = w.g[0] + v & 4294967295, w.g[1] = w.g[1] + (P + (k << 21 & 4294967295 | k >>> 11)) & 4294967295, w.g[2] = w.g[2] + P & 4294967295, w.g[3] = w.g[3] + M & 4294967295;
  }
  n.prototype.u = function(w, v) {
    v === void 0 && (v = w.length);
    for (var x = v - this.blockSize, A = this.B, P = this.h, M = 0; M < v; ) {
      if (P == 0) for (; M <= x; ) r(this, w, M), M += this.blockSize;
      if (typeof w == "string") {
        for (; M < v; )
          if (A[P++] = w.charCodeAt(M++), P == this.blockSize) {
            r(this, A), P = 0;
            break;
          }
      } else for (; M < v; ) if (A[P++] = w[M++], P == this.blockSize) {
        r(this, A), P = 0;
        break;
      }
    }
    this.h = P, this.o += v;
  }, n.prototype.v = function() {
    var w = Array((56 > this.h ? this.blockSize : 2 * this.blockSize) - this.h);
    w[0] = 128;
    for (var v = 1; v < w.length - 8; ++v) w[v] = 0;
    var x = 8 * this.o;
    for (v = w.length - 8; v < w.length; ++v) w[v] = x & 255, x /= 256;
    for (this.u(w), w = Array(16), v = x = 0; 4 > v; ++v) for (var A = 0; 32 > A; A += 8) w[x++] = this.g[v] >>> A & 255;
    return w;
  };
  function s(w, v) {
    var x = a;
    return Object.prototype.hasOwnProperty.call(x, w) ? x[w] : x[w] = v(w);
  }
  function o(w, v) {
    this.h = v;
    for (var x = [], A = !0, P = w.length - 1; 0 <= P; P--) {
      var M = w[P] | 0;
      A && M == v || (x[P] = M, A = !1);
    }
    this.g = x;
  }
  var a = {};
  function l(w) {
    return -128 <= w && 128 > w ? s(w, function(v) {
      return new o([v | 0], 0 > v ? -1 : 0);
    }) : new o([w | 0], 0 > w ? -1 : 0);
  }
  function h(w) {
    if (isNaN(w) || !isFinite(w)) return p;
    if (0 > w) return y(h(-w));
    for (var v = [], x = 1, A = 0; w >= x; A++) v[A] = w / x | 0, x *= 4294967296;
    return new o(v, 0);
  }
  function c(w, v) {
    if (w.length == 0) throw Error("number format error: empty string");
    if (v = v || 10, 2 > v || 36 < v) throw Error("radix out of range: " + v);
    if (w.charAt(0) == "-") return y(c(w.substring(1), v));
    if (0 <= w.indexOf("-")) throw Error('number format error: interior "-" character');
    for (var x = h(Math.pow(v, 8)), A = p, P = 0; P < w.length; P += 8) {
      var M = Math.min(8, w.length - P), k = parseInt(w.substring(P, P + M), v);
      8 > M ? (M = h(Math.pow(v, M)), A = A.j(M).add(h(k))) : (A = A.j(x), A = A.add(h(k)));
    }
    return A;
  }
  var p = l(0), f = l(1), d = l(16777216);
  i = o.prototype, i.m = function() {
    if (g(this)) return -y(this).m();
    for (var w = 0, v = 1, x = 0; x < this.g.length; x++) {
      var A = this.i(x);
      w += (0 <= A ? A : 4294967296 + A) * v, v *= 4294967296;
    }
    return w;
  }, i.toString = function(w) {
    if (w = w || 10, 2 > w || 36 < w) throw Error("radix out of range: " + w);
    if (m(this)) return "0";
    if (g(this)) return "-" + y(this).toString(w);
    for (var v = h(Math.pow(w, 6)), x = this, A = ""; ; ) {
      var P = I(x, v).g;
      x = b(x, P.j(v));
      var M = ((0 < x.g.length ? x.g[0] : x.h) >>> 0).toString(w);
      if (x = P, m(x)) return M + A;
      for (; 6 > M.length; ) M = "0" + M;
      A = M + A;
    }
  }, i.i = function(w) {
    return 0 > w ? 0 : w < this.g.length ? this.g[w] : this.h;
  };
  function m(w) {
    if (w.h != 0) return !1;
    for (var v = 0; v < w.g.length; v++) if (w.g[v] != 0) return !1;
    return !0;
  }
  function g(w) {
    return w.h == -1;
  }
  i.l = function(w) {
    return w = b(this, w), g(w) ? -1 : m(w) ? 0 : 1;
  };
  function y(w) {
    for (var v = w.g.length, x = [], A = 0; A < v; A++) x[A] = ~w.g[A];
    return new o(x, ~w.h).add(f);
  }
  i.abs = function() {
    return g(this) ? y(this) : this;
  }, i.add = function(w) {
    for (var v = Math.max(this.g.length, w.g.length), x = [], A = 0, P = 0; P <= v; P++) {
      var M = A + (this.i(P) & 65535) + (w.i(P) & 65535), k = (M >>> 16) + (this.i(P) >>> 16) + (w.i(P) >>> 16);
      A = k >>> 16, M &= 65535, k &= 65535, x[P] = k << 16 | M;
    }
    return new o(x, x[x.length - 1] & -2147483648 ? -1 : 0);
  };
  function b(w, v) {
    return w.add(y(v));
  }
  i.j = function(w) {
    if (m(this) || m(w)) return p;
    if (g(this)) return g(w) ? y(this).j(y(w)) : y(y(this).j(w));
    if (g(w)) return y(this.j(y(w)));
    if (0 > this.l(d) && 0 > w.l(d)) return h(this.m() * w.m());
    for (var v = this.g.length + w.g.length, x = [], A = 0; A < 2 * v; A++) x[A] = 0;
    for (A = 0; A < this.g.length; A++) for (var P = 0; P < w.g.length; P++) {
      var M = this.i(A) >>> 16, k = this.i(A) & 65535, B = w.i(P) >>> 16, V = w.i(P) & 65535;
      x[2 * A + 2 * P] += k * V, S(x, 2 * A + 2 * P), x[2 * A + 2 * P + 1] += M * V, S(x, 2 * A + 2 * P + 1), x[2 * A + 2 * P + 1] += k * B, S(x, 2 * A + 2 * P + 1), x[2 * A + 2 * P + 2] += M * B, S(x, 2 * A + 2 * P + 2);
    }
    for (A = 0; A < v; A++) x[A] = x[2 * A + 1] << 16 | x[2 * A];
    for (A = v; A < 2 * v; A++) x[A] = 0;
    return new o(x, 0);
  };
  function S(w, v) {
    for (; (w[v] & 65535) != w[v]; ) w[v + 1] += w[v] >>> 16, w[v] &= 65535, v++;
  }
  function C(w, v) {
    this.g = w, this.h = v;
  }
  function I(w, v) {
    if (m(v)) throw Error("division by zero");
    if (m(w)) return new C(p, p);
    if (g(w)) return v = I(y(w), v), new C(y(v.g), y(v.h));
    if (g(v)) return v = I(w, y(v)), new C(y(v.g), v.h);
    if (30 < w.g.length) {
      if (g(w) || g(v)) throw Error("slowDivide_ only works with positive integers.");
      for (var x = f, A = v; 0 >= A.l(w); ) x = T(x), A = T(A);
      var P = R(x, 1), M = R(A, 1);
      for (A = R(A, 2), x = R(x, 2); !m(A); ) {
        var k = M.add(A);
        0 >= k.l(w) && (P = P.add(x), M = k), A = R(A, 1), x = R(x, 1);
      }
      return v = b(w, P.j(v)), new C(P, v);
    }
    for (P = p; 0 <= w.l(v); ) {
      for (x = Math.max(1, Math.floor(w.m() / v.m())), A = Math.ceil(Math.log(x) / Math.LN2), A = 48 >= A ? 1 : Math.pow(2, A - 48), M = h(x), k = M.j(v); g(k) || 0 < k.l(w); ) x -= A, M = h(x), k = M.j(v);
      m(M) && (M = f), P = P.add(M), w = b(w, k);
    }
    return new C(P, w);
  }
  i.A = function(w) {
    return I(this, w).h;
  }, i.and = function(w) {
    for (var v = Math.max(this.g.length, w.g.length), x = [], A = 0; A < v; A++) x[A] = this.i(A) & w.i(A);
    return new o(x, this.h & w.h);
  }, i.or = function(w) {
    for (var v = Math.max(this.g.length, w.g.length), x = [], A = 0; A < v; A++) x[A] = this.i(A) | w.i(A);
    return new o(x, this.h | w.h);
  }, i.xor = function(w) {
    for (var v = Math.max(this.g.length, w.g.length), x = [], A = 0; A < v; A++) x[A] = this.i(A) ^ w.i(A);
    return new o(x, this.h ^ w.h);
  };
  function T(w) {
    for (var v = w.g.length + 1, x = [], A = 0; A < v; A++) x[A] = w.i(A) << 1 | w.i(A - 1) >>> 31;
    return new o(x, w.h);
  }
  function R(w, v) {
    var x = v >> 5;
    v %= 32;
    for (var A = w.g.length - x, P = [], M = 0; M < A; M++) P[M] = 0 < v ? w.i(M + x) >>> v | w.i(M + x + 1) << 32 - v : w.i(M + x);
    return new o(P, w.h);
  }
  n.prototype.digest = n.prototype.v, n.prototype.reset = n.prototype.s, n.prototype.update = n.prototype.u, o.prototype.add = o.prototype.add, o.prototype.multiply = o.prototype.j, o.prototype.modulo = o.prototype.A, o.prototype.compare = o.prototype.l, o.prototype.toNumber = o.prototype.m, o.prototype.toString = o.prototype.toString, o.prototype.getBits = o.prototype.i, o.fromNumber = h, o.fromString = c, uy = o;
}).apply(typeof Np < "u" ? Np : typeof self < "u" ? self : typeof window < "u" ? window : {});
var ko = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
/** @license
Copyright The Closure Library Authors.
SPDX-License-Identifier: Apache-2.0
*/
var dy, ms, py, Ho, $h, fy, my, gy;
(function() {
  var i, t = typeof Object.defineProperties == "function" ? Object.defineProperty : function(u, _, E) {
    return u == Array.prototype || u == Object.prototype || (u[_] = E.value), u;
  };
  function e(u) {
    u = [typeof globalThis == "object" && globalThis, u, typeof window == "object" && window, typeof self == "object" && self, typeof ko == "object" && ko];
    for (var _ = 0; _ < u.length; ++_) {
      var E = u[_];
      if (E && E.Math == Math) return E;
    }
    throw Error("Cannot find global object");
  }
  var n = e(this);
  function r(u, _) {
    if (_) t: {
      var E = n;
      u = u.split(".");
      for (var O = 0; O < u.length - 1; O++) {
        var D = u[O];
        if (!(D in E)) break t;
        E = E[D];
      }
      u = u[u.length - 1], O = E[u], _ = _(O), _ != O && _ != null && t(E, u, { configurable: !0, writable: !0, value: _ });
    }
  }
  function s(u, _) {
    u instanceof String && (u += "");
    var E = 0, O = !1, D = { next: function() {
      if (!O && E < u.length) {
        var F = E++;
        return { value: _(F, u[F]), done: !1 };
      }
      return O = !0, { done: !0, value: void 0 };
    } };
    return D[Symbol.iterator] = function() {
      return D;
    }, D;
  }
  r("Array.prototype.values", function(u) {
    return u || function() {
      return s(this, function(_, E) {
        return E;
      });
    };
  });
  /** @license
  
   Copyright The Closure Library Authors.
   SPDX-License-Identifier: Apache-2.0
  */
  var o = o || {}, a = this || self;
  function l(u) {
    var _ = typeof u;
    return _ = _ != "object" ? _ : u ? Array.isArray(u) ? "array" : _ : "null", _ == "array" || _ == "object" && typeof u.length == "number";
  }
  function h(u) {
    var _ = typeof u;
    return _ == "object" && u != null || _ == "function";
  }
  function c(u, _, E) {
    return u.call.apply(u.bind, arguments);
  }
  function p(u, _, E) {
    if (!u) throw Error();
    if (2 < arguments.length) {
      var O = Array.prototype.slice.call(arguments, 2);
      return function() {
        var D = Array.prototype.slice.call(arguments);
        return Array.prototype.unshift.apply(D, O), u.apply(_, D);
      };
    }
    return function() {
      return u.apply(_, arguments);
    };
  }
  function f(u, _, E) {
    return f = Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? c : p, f.apply(null, arguments);
  }
  function d(u, _) {
    var E = Array.prototype.slice.call(arguments, 1);
    return function() {
      var O = E.slice();
      return O.push.apply(O, arguments), u.apply(this, O);
    };
  }
  function m(u, _) {
    function E() {
    }
    E.prototype = _.prototype, u.aa = _.prototype, u.prototype = new E(), u.prototype.constructor = u, u.Qb = function(O, D, F) {
      for (var G = Array(arguments.length - 2), gt = 2; gt < arguments.length; gt++) G[gt - 2] = arguments[gt];
      return _.prototype[D].apply(O, G);
    };
  }
  function g(u) {
    const _ = u.length;
    if (0 < _) {
      const E = Array(_);
      for (let O = 0; O < _; O++) E[O] = u[O];
      return E;
    }
    return [];
  }
  function y(u, _) {
    for (let E = 1; E < arguments.length; E++) {
      const O = arguments[E];
      if (l(O)) {
        const D = u.length || 0, F = O.length || 0;
        u.length = D + F;
        for (let G = 0; G < F; G++) u[D + G] = O[G];
      } else u.push(O);
    }
  }
  class b {
    constructor(_, E) {
      this.i = _, this.j = E, this.h = 0, this.g = null;
    }
    get() {
      let _;
      return 0 < this.h ? (this.h--, _ = this.g, this.g = _.next, _.next = null) : _ = this.i(), _;
    }
  }
  function S(u) {
    return /^[\s\xa0]*$/.test(u);
  }
  function C() {
    var u = a.navigator;
    return u && (u = u.userAgent) ? u : "";
  }
  function I(u) {
    return I[" "](u), u;
  }
  I[" "] = function() {
  };
  var T = C().indexOf("Gecko") != -1 && !(C().toLowerCase().indexOf("webkit") != -1 && C().indexOf("Edge") == -1) && !(C().indexOf("Trident") != -1 || C().indexOf("MSIE") != -1) && C().indexOf("Edge") == -1;
  function R(u, _, E) {
    for (const O in u) _.call(E, u[O], O, u);
  }
  function w(u, _) {
    for (const E in u) _.call(void 0, u[E], E, u);
  }
  function v(u) {
    const _ = {};
    for (const E in u) _[E] = u[E];
    return _;
  }
  const x = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
  function A(u, _) {
    let E, O;
    for (let D = 1; D < arguments.length; D++) {
      O = arguments[D];
      for (E in O) u[E] = O[E];
      for (let F = 0; F < x.length; F++) E = x[F], Object.prototype.hasOwnProperty.call(O, E) && (u[E] = O[E]);
    }
  }
  function P(u) {
    var _ = 1;
    u = u.split(":");
    const E = [];
    for (; 0 < _ && u.length; ) E.push(u.shift()), _--;
    return u.length && E.push(u.join(":")), E;
  }
  function M(u) {
    a.setTimeout(() => {
      throw u;
    }, 0);
  }
  function k() {
    var u = j;
    let _ = null;
    return u.g && (_ = u.g, u.g = u.g.next, u.g || (u.h = null), _.next = null), _;
  }
  class B {
    constructor() {
      this.h = this.g = null;
    }
    add(_, E) {
      const O = V.get();
      O.set(_, E), this.h ? this.h.next = O : this.g = O, this.h = O;
    }
  }
  var V = new b(() => new N(), (u) => u.reset());
  class N {
    constructor() {
      this.next = this.g = this.h = null;
    }
    set(_, E) {
      this.h = _, this.g = E, this.next = null;
    }
    reset() {
      this.next = this.g = this.h = null;
    }
  }
  let U, K = !1, j = new B(), H = () => {
    const u = a.Promise.resolve(void 0);
    U = () => {
      u.then(pt);
    };
  };
  var pt = () => {
    for (var u; u = k(); ) {
      try {
        u.h.call(u.g);
      } catch (E) {
        M(E);
      }
      var _ = V;
      _.j(u), 100 > _.h && (_.h++, u.next = _.g, _.g = u);
    }
    K = !1;
  };
  function Q() {
    this.s = this.s, this.C = this.C;
  }
  Q.prototype.s = !1, Q.prototype.ma = function() {
    this.s || (this.s = !0, this.N());
  }, Q.prototype.N = function() {
    if (this.C) for (; this.C.length; ) this.C.shift()();
  };
  function J(u, _) {
    this.type = u, this.g = this.target = _, this.defaultPrevented = !1;
  }
  J.prototype.h = function() {
    this.defaultPrevented = !0;
  };
  var bt = function() {
    if (!a.addEventListener || !Object.defineProperty) return !1;
    var u = !1, _ = Object.defineProperty({}, "passive", { get: function() {
      u = !0;
    } });
    try {
      const E = () => {
      };
      a.addEventListener("test", E, _), a.removeEventListener("test", E, _);
    } catch {
    }
    return u;
  }();
  function St(u, _) {
    if (J.call(this, u ? u.type : ""), this.relatedTarget = this.g = this.target = null, this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0, this.key = "", this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1, this.state = null, this.pointerId = 0, this.pointerType = "", this.i = null, u) {
      var E = this.type = u.type, O = u.changedTouches && u.changedTouches.length ? u.changedTouches[0] : null;
      if (this.target = u.target || u.srcElement, this.g = _, _ = u.relatedTarget) {
        if (T) {
          t: {
            try {
              I(_.nodeName);
              var D = !0;
              break t;
            } catch {
            }
            D = !1;
          }
          D || (_ = null);
        }
      } else E == "mouseover" ? _ = u.fromElement : E == "mouseout" && (_ = u.toElement);
      this.relatedTarget = _, O ? (this.clientX = O.clientX !== void 0 ? O.clientX : O.pageX, this.clientY = O.clientY !== void 0 ? O.clientY : O.pageY, this.screenX = O.screenX || 0, this.screenY = O.screenY || 0) : (this.clientX = u.clientX !== void 0 ? u.clientX : u.pageX, this.clientY = u.clientY !== void 0 ? u.clientY : u.pageY, this.screenX = u.screenX || 0, this.screenY = u.screenY || 0), this.button = u.button, this.key = u.key || "", this.ctrlKey = u.ctrlKey, this.altKey = u.altKey, this.shiftKey = u.shiftKey, this.metaKey = u.metaKey, this.pointerId = u.pointerId || 0, this.pointerType = typeof u.pointerType == "string" ? u.pointerType : $[u.pointerType] || "", this.state = u.state, this.i = u, u.defaultPrevented && St.aa.h.call(this);
    }
  }
  m(St, J);
  var $ = { 2: "touch", 3: "pen", 4: "mouse" };
  St.prototype.h = function() {
    St.aa.h.call(this);
    var u = this.i;
    u.preventDefault ? u.preventDefault() : u.returnValue = !1;
  };
  var Ht = "closure_listenable_" + (1e6 * Math.random() | 0), Tt = 0;
  function Fe(u, _, E, O, D) {
    this.listener = u, this.proxy = null, this.src = _, this.type = E, this.capture = !!O, this.ha = D, this.key = ++Tt, this.da = this.fa = !1;
  }
  function Yt(u) {
    u.da = !0, u.listener = null, u.proxy = null, u.src = null, u.ha = null;
  }
  function Xt(u) {
    this.src = u, this.g = {}, this.h = 0;
  }
  Xt.prototype.add = function(u, _, E, O, D) {
    var F = u.toString();
    u = this.g[F], u || (u = this.g[F] = [], this.h++);
    var G = ci(u, _, O, D);
    return -1 < G ? (_ = u[G], E || (_.fa = !1)) : (_ = new Fe(_, this.src, F, !!O, D), _.fa = E, u.push(_)), _;
  };
  function Et(u, _) {
    var E = _.type;
    if (E in u.g) {
      var O = u.g[E], D = Array.prototype.indexOf.call(O, _, void 0), F;
      (F = 0 <= D) && Array.prototype.splice.call(O, D, 1), F && (Yt(_), u.g[E].length == 0 && (delete u.g[E], u.h--));
    }
  }
  function ci(u, _, E, O) {
    for (var D = 0; D < u.length; ++D) {
      var F = u[D];
      if (!F.da && F.listener == _ && F.capture == !!E && F.ha == O) return D;
    }
    return -1;
  }
  var wi = "closure_lm_" + (1e6 * Math.random() | 0), Le = {};
  function Ne(u, _, E, O, D) {
    if (Array.isArray(_)) {
      for (var F = 0; F < _.length; F++) Ne(u, _[F], E, O, D);
      return null;
    }
    return E = Nr(E), u && u[Ht] ? u.K(_, E, h(O) ? !!O.capture : !!O, D) : Xe(u, _, E, !1, O, D);
  }
  function Xe(u, _, E, O, D, F) {
    if (!_) throw Error("Invalid event type");
    var G = h(D) ? !!D.capture : !!D, gt = Wn(u);
    if (gt || (u[wi] = gt = new Xt(u)), E = gt.add(_, E, O, G, F), E.proxy) return E;
    if (O = Ue(), E.proxy = O, O.src = u, O.listener = E, u.addEventListener) bt || (D = G), D === void 0 && (D = !1), u.addEventListener(_.toString(), O, D);
    else if (u.attachEvent) u.attachEvent(Ni(_.toString()), O);
    else if (u.addListener && u.removeListener) u.addListener(O);
    else throw Error("addEventListener and attachEvent are unavailable.");
    return E;
  }
  function Ue() {
    function u(E) {
      return _.call(u.src, u.listener, E);
    }
    const _ = io;
    return u;
  }
  function Ee(u, _, E, O, D) {
    if (Array.isArray(_)) for (var F = 0; F < _.length; F++) Ee(u, _[F], E, O, D);
    else O = h(O) ? !!O.capture : !!O, E = Nr(E), u && u[Ht] ? (u = u.i, _ = String(_).toString(), _ in u.g && (F = u.g[_], E = ci(F, E, O, D), -1 < E && (Yt(F[E]), Array.prototype.splice.call(F, E, 1), F.length == 0 && (delete u.g[_], u.h--)))) : u && (u = Wn(u)) && (_ = u.g[_.toString()], u = -1, _ && (u = ci(_, E, O, D)), (E = -1 < u ? _[u] : null) && Ai(E));
  }
  function Ai(u) {
    if (typeof u != "number" && u && !u.da) {
      var _ = u.src;
      if (_ && _[Ht]) Et(_.i, u);
      else {
        var E = u.type, O = u.proxy;
        _.removeEventListener ? _.removeEventListener(E, O, u.capture) : _.detachEvent ? _.detachEvent(Ni(E), O) : _.addListener && _.removeListener && _.removeListener(O), (E = Wn(_)) ? (Et(E, u), E.h == 0 && (E.src = null, _[wi] = null)) : Yt(u);
      }
    }
  }
  function Ni(u) {
    return u in Le ? Le[u] : Le[u] = "on" + u;
  }
  function io(u, _) {
    if (u.da) u = !0;
    else {
      _ = new St(_, this);
      var E = u.listener, O = u.ha || u.src;
      u.fa && Ai(u), u = E.call(O, _);
    }
    return u;
  }
  function Wn(u) {
    return u = u[wi], u instanceof Xt ? u : null;
  }
  var qn = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
  function Nr(u) {
    return typeof u == "function" ? u : (u[qn] || (u[qn] = function(_) {
      return u.handleEvent(_);
    }), u[qn]);
  }
  function Vt() {
    Q.call(this), this.i = new Xt(this), this.M = this, this.F = null;
  }
  m(Vt, Q), Vt.prototype[Ht] = !0, Vt.prototype.removeEventListener = function(u, _, E, O) {
    Ee(this, u, _, E, O);
  };
  function ie(u, _) {
    var E, O = u.F;
    if (O) for (E = []; O; O = O.F) E.push(O);
    if (u = u.M, O = _.type || _, typeof _ == "string") _ = new J(_, u);
    else if (_ instanceof J) _.target = _.target || u;
    else {
      var D = _;
      _ = new J(O, u), A(_, D);
    }
    if (D = !0, E) for (var F = E.length - 1; 0 <= F; F--) {
      var G = _.g = E[F];
      D = Yn(G, O, !0, _) && D;
    }
    if (G = _.g = u, D = Yn(G, O, !0, _) && D, D = Yn(G, O, !1, _) && D, E) for (F = 0; F < E.length; F++) G = _.g = E[F], D = Yn(G, O, !1, _) && D;
  }
  Vt.prototype.N = function() {
    if (Vt.aa.N.call(this), this.i) {
      var u = this.i, _;
      for (_ in u.g) {
        for (var E = u.g[_], O = 0; O < E.length; O++) Yt(E[O]);
        delete u.g[_], u.h--;
      }
    }
    this.F = null;
  }, Vt.prototype.K = function(u, _, E, O) {
    return this.i.add(String(u), _, !1, E, O);
  }, Vt.prototype.L = function(u, _, E, O) {
    return this.i.add(String(u), _, !0, E, O);
  };
  function Yn(u, _, E, O) {
    if (_ = u.i.g[String(_)], !_) return !0;
    _ = _.concat();
    for (var D = !0, F = 0; F < _.length; ++F) {
      var G = _[F];
      if (G && !G.da && G.capture == E) {
        var gt = G.listener, ne = G.ha || G.src;
        G.fa && Et(u.i, G), D = gt.call(ne, O) !== !1 && D;
      }
    }
    return D && !O.defaultPrevented;
  }
  function sn(u, _, E) {
    if (typeof u == "function") E && (u = f(u, E));
    else if (u && typeof u.handleEvent == "function") u = f(u.handleEvent, u);
    else throw Error("Invalid listener argument");
    return 2147483647 < Number(_) ? -1 : a.setTimeout(u, _ || 0);
  }
  function on(u) {
    u.g = sn(() => {
      u.g = null, u.i && (u.i = !1, on(u));
    }, u.l);
    const _ = u.h;
    u.h = null, u.m.apply(null, _);
  }
  class y0 extends Q {
    constructor(_, E) {
      super(), this.m = _, this.l = E, this.h = null, this.i = !1, this.g = null;
    }
    j(_) {
      this.h = arguments, this.g ? this.i = !0 : on(this);
    }
    N() {
      super.N(), this.g && (a.clearTimeout(this.g), this.g = null, this.i = !1, this.h = null);
    }
  }
  function Ur(u) {
    Q.call(this), this.h = u, this.g = {};
  }
  m(Ur, Q);
  var fu = [];
  function mu(u) {
    R(u.g, function(_, E) {
      this.g.hasOwnProperty(E) && Ai(_);
    }, u), u.g = {};
  }
  Ur.prototype.N = function() {
    Ur.aa.N.call(this), mu(this);
  }, Ur.prototype.handleEvent = function() {
    throw Error("EventHandler.handleEvent not implemented");
  };
  var Ja = a.JSON.stringify, v0 = a.JSON.parse, _0 = class {
    stringify(u) {
      return a.JSON.stringify(u, void 0);
    }
    parse(u) {
      return a.JSON.parse(u, void 0);
    }
  };
  function Za() {
  }
  Za.prototype.h = null;
  function gu(u) {
    return u.h || (u.h = u.i());
  }
  function yu() {
  }
  var zr = { OPEN: "a", kb: "b", Ja: "c", wb: "d" };
  function $a() {
    J.call(this, "d");
  }
  m($a, J);
  function tl() {
    J.call(this, "c");
  }
  m(tl, J);
  var an = {}, vu = null;
  function no() {
    return vu = vu || new Vt();
  }
  an.La = "serverreachability";
  function _u(u) {
    J.call(this, an.La, u);
  }
  m(_u, J);
  function jr(u) {
    const _ = no();
    ie(_, new _u(_));
  }
  an.STAT_EVENT = "statevent";
  function xu(u, _) {
    J.call(this, an.STAT_EVENT, u), this.stat = _;
  }
  m(xu, J);
  function be(u) {
    const _ = no();
    ie(_, new xu(_, u));
  }
  an.Ma = "timingevent";
  function bu(u, _) {
    J.call(this, an.Ma, u), this.size = _;
  }
  m(bu, J);
  function Gr(u, _) {
    if (typeof u != "function") throw Error("Fn must not be null and must be a function");
    return a.setTimeout(function() {
      u();
    }, _);
  }
  function Hr() {
    this.g = !0;
  }
  Hr.prototype.xa = function() {
    this.g = !1;
  };
  function x0(u, _, E, O, D, F) {
    u.info(function() {
      if (u.g) if (F)
        for (var G = "", gt = F.split("&"), ne = 0; ne < gt.length; ne++) {
          var lt = gt[ne].split("=");
          if (1 < lt.length) {
            var he = lt[0];
            lt = lt[1];
            var ce = he.split("_");
            G = 2 <= ce.length && ce[1] == "type" ? G + (he + "=" + lt + "&") : G + (he + "=redacted&");
          }
        }
      else G = null;
      else G = F;
      return "XMLHTTP REQ (" + O + ") [attempt " + D + "]: " + _ + `
` + E + `
` + G;
    });
  }
  function b0(u, _, E, O, D, F, G) {
    u.info(function() {
      return "XMLHTTP RESP (" + O + ") [ attempt " + D + "]: " + _ + `
` + E + `
` + F + " " + G;
    });
  }
  function Xn(u, _, E, O) {
    u.info(function() {
      return "XMLHTTP TEXT (" + _ + "): " + A0(u, E) + (O ? " " + O : "");
    });
  }
  function w0(u, _) {
    u.info(function() {
      return "TIMEOUT: " + _;
    });
  }
  Hr.prototype.info = function() {
  };
  function A0(u, _) {
    if (!u.g) return _;
    if (!_) return null;
    try {
      var E = JSON.parse(_);
      if (E) {
        for (u = 0; u < E.length; u++) if (Array.isArray(E[u])) {
          var O = E[u];
          if (!(2 > O.length)) {
            var D = O[1];
            if (Array.isArray(D) && !(1 > D.length)) {
              var F = D[0];
              if (F != "noop" && F != "stop" && F != "close") for (var G = 1; G < D.length; G++) D[G] = "";
            }
          }
        }
      }
      return Ja(E);
    } catch {
      return _;
    }
  }
  var ro = { NO_ERROR: 0, gb: 1, tb: 2, sb: 3, nb: 4, rb: 5, ub: 6, Ia: 7, TIMEOUT: 8, xb: 9 }, wu = { lb: "complete", Hb: "success", Ja: "error", Ia: "abort", zb: "ready", Ab: "readystatechange", TIMEOUT: "timeout", vb: "incrementaldata", yb: "progress", ob: "downloadprogress", Pb: "uploadprogress" }, el;
  function so() {
  }
  m(so, Za), so.prototype.g = function() {
    return new XMLHttpRequest();
  }, so.prototype.i = function() {
    return {};
  }, el = new so();
  function Ui(u, _, E, O) {
    this.j = u, this.i = _, this.l = E, this.R = O || 1, this.U = new Ur(this), this.I = 45e3, this.H = null, this.o = !1, this.m = this.A = this.v = this.L = this.F = this.S = this.B = null, this.D = [], this.g = null, this.C = 0, this.s = this.u = null, this.X = -1, this.J = !1, this.O = 0, this.M = null, this.W = this.K = this.T = this.P = !1, this.h = new Au();
  }
  function Au() {
    this.i = null, this.g = "", this.h = !1;
  }
  var Su = {}, il = {};
  function nl(u, _, E) {
    u.L = 1, u.v = ho(Si(_)), u.m = E, u.P = !0, Tu(u, null);
  }
  function Tu(u, _) {
    u.F = Date.now(), oo(u), u.A = Si(u.v);
    var E = u.A, O = u.R;
    Array.isArray(O) || (O = [String(O)]), Nu(E.i, "t", O), u.C = 0, E = u.j.J, u.h = new Au(), u.g = nd(u.j, E ? _ : null, !u.m), 0 < u.O && (u.M = new y0(f(u.Y, u, u.g), u.O)), _ = u.U, E = u.g, O = u.ca;
    var D = "readystatechange";
    Array.isArray(D) || (D && (fu[0] = D.toString()), D = fu);
    for (var F = 0; F < D.length; F++) {
      var G = Ne(E, D[F], O || _.handleEvent, !1, _.h || _);
      if (!G) break;
      _.g[G.key] = G;
    }
    _ = u.H ? v(u.H) : {}, u.m ? (u.u || (u.u = "POST"), _["Content-Type"] = "application/x-www-form-urlencoded", u.g.ea(
      u.A,
      u.u,
      u.m,
      _
    )) : (u.u = "GET", u.g.ea(u.A, u.u, null, _)), jr(), x0(u.i, u.u, u.A, u.l, u.R, u.m);
  }
  Ui.prototype.ca = function(u) {
    u = u.target;
    const _ = this.M;
    _ && Ti(u) == 3 ? _.j() : this.Y(u);
  }, Ui.prototype.Y = function(u) {
    try {
      if (u == this.g) t: {
        const ce = Ti(this.g);
        var _ = this.g.Ba();
        const Jn = this.g.Z();
        if (!(3 > ce) && (ce != 3 || this.g && (this.h.h || this.g.oa() || qu(this.g)))) {
          this.J || ce != 4 || _ == 7 || (_ == 8 || 0 >= Jn ? jr(3) : jr(2)), rl(this);
          var E = this.g.Z();
          this.X = E;
          e: if (Eu(this)) {
            var O = qu(this.g);
            u = "";
            var D = O.length, F = Ti(this.g) == 4;
            if (!this.h.i) {
              if (typeof TextDecoder > "u") {
                ln(this), Wr(this);
                var G = "";
                break e;
              }
              this.h.i = new a.TextDecoder();
            }
            for (_ = 0; _ < D; _++) this.h.h = !0, u += this.h.i.decode(O[_], { stream: !(F && _ == D - 1) });
            O.length = 0, this.h.g += u, this.C = 0, G = this.h.g;
          } else G = this.g.oa();
          if (this.o = E == 200, b0(this.i, this.u, this.A, this.l, this.R, ce, E), this.o) {
            if (this.T && !this.K) {
              e: {
                if (this.g) {
                  var gt, ne = this.g;
                  if ((gt = ne.g ? ne.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !S(gt)) {
                    var lt = gt;
                    break e;
                  }
                }
                lt = null;
              }
              if (E = lt) Xn(this.i, this.l, E, "Initial handshake response via X-HTTP-Initial-Response"), this.K = !0, sl(this, E);
              else {
                this.o = !1, this.s = 3, be(12), ln(this), Wr(this);
                break t;
              }
            }
            if (this.P) {
              E = !0;
              let ii;
              for (; !this.J && this.C < G.length; ) if (ii = S0(this, G), ii == il) {
                ce == 4 && (this.s = 4, be(14), E = !1), Xn(this.i, this.l, null, "[Incomplete Response]");
                break;
              } else if (ii == Su) {
                this.s = 4, be(15), Xn(this.i, this.l, G, "[Invalid Chunk]"), E = !1;
                break;
              } else Xn(this.i, this.l, ii, null), sl(this, ii);
              if (Eu(this) && this.C != 0 && (this.h.g = this.h.g.slice(this.C), this.C = 0), ce != 4 || G.length != 0 || this.h.h || (this.s = 1, be(16), E = !1), this.o = this.o && E, !E) Xn(this.i, this.l, G, "[Invalid Chunked Response]"), ln(this), Wr(this);
              else if (0 < G.length && !this.W) {
                this.W = !0;
                var he = this.j;
                he.g == this && he.ba && !he.M && (he.j.info("Great, no buffering proxy detected. Bytes received: " + G.length), ul(he), he.M = !0, be(11));
              }
            } else Xn(this.i, this.l, G, null), sl(this, G);
            ce == 4 && ln(this), this.o && !this.J && (ce == 4 ? $u(this.j, this) : (this.o = !1, oo(this)));
          } else z0(this.g), E == 400 && 0 < G.indexOf("Unknown SID") ? (this.s = 3, be(12)) : (this.s = 0, be(13)), ln(this), Wr(this);
        }
      }
    } catch {
    } finally {
    }
  };
  function Eu(u) {
    return u.g ? u.u == "GET" && u.L != 2 && u.j.Ca : !1;
  }
  function S0(u, _) {
    var E = u.C, O = _.indexOf(`
`, E);
    return O == -1 ? il : (E = Number(_.substring(E, O)), isNaN(E) ? Su : (O += 1, O + E > _.length ? il : (_ = _.slice(O, O + E), u.C = O + E, _)));
  }
  Ui.prototype.cancel = function() {
    this.J = !0, ln(this);
  };
  function oo(u) {
    u.S = Date.now() + u.I, Cu(u, u.I);
  }
  function Cu(u, _) {
    if (u.B != null) throw Error("WatchDog timer not null");
    u.B = Gr(f(u.ba, u), _);
  }
  function rl(u) {
    u.B && (a.clearTimeout(u.B), u.B = null);
  }
  Ui.prototype.ba = function() {
    this.B = null;
    const u = Date.now();
    0 <= u - this.S ? (w0(this.i, this.A), this.L != 2 && (jr(), be(17)), ln(this), this.s = 2, Wr(this)) : Cu(this, this.S - u);
  };
  function Wr(u) {
    u.j.G == 0 || u.J || $u(u.j, u);
  }
  function ln(u) {
    rl(u);
    var _ = u.M;
    _ && typeof _.ma == "function" && _.ma(), u.M = null, mu(u.U), u.g && (_ = u.g, u.g = null, _.abort(), _.ma());
  }
  function sl(u, _) {
    try {
      var E = u.j;
      if (E.G != 0 && (E.g == u || ol(E.h, u))) {
        if (!u.K && ol(E.h, u) && E.G == 3) {
          try {
            var O = E.Da.g.parse(_);
          } catch {
            O = null;
          }
          if (Array.isArray(O) && O.length == 3) {
            var D = O;
            if (D[0] == 0) {
              t:
                if (!E.u) {
                  if (E.g) if (E.g.F + 3e3 < u.F) go(E), fo(E);
                  else break t;
                  cl(E), be(18);
                }
            } else E.za = D[1], 0 < E.za - E.T && 37500 > D[2] && E.F && E.v == 0 && !E.C && (E.C = Gr(f(E.Za, E), 6e3));
            if (1 >= Ru(E.h) && E.ca) {
              try {
                E.ca();
              } catch {
              }
              E.ca = void 0;
            }
          } else cn(E, 11);
        } else if ((u.K || E.g == u) && go(E), !S(_)) for (D = E.Da.g.parse(_), _ = 0; _ < D.length; _++) {
          let lt = D[_];
          if (E.T = lt[0], lt = lt[1], E.G == 2) if (lt[0] == "c") {
            E.K = lt[1], E.ia = lt[2];
            const he = lt[3];
            he != null && (E.la = he, E.j.info("VER=" + E.la));
            const ce = lt[4];
            ce != null && (E.Aa = ce, E.j.info("SVER=" + E.Aa));
            const Jn = lt[5];
            Jn != null && typeof Jn == "number" && 0 < Jn && (O = 1.5 * Jn, E.L = O, E.j.info("backChannelRequestTimeoutMs_=" + O)), O = E;
            const ii = u.g;
            if (ii) {
              const vo = ii.g ? ii.g.getResponseHeader("X-Client-Wire-Protocol") : null;
              if (vo) {
                var F = O.h;
                F.g || vo.indexOf("spdy") == -1 && vo.indexOf("quic") == -1 && vo.indexOf("h2") == -1 || (F.j = F.l, F.g = /* @__PURE__ */ new Set(), F.h && (al(F, F.h), F.h = null));
              }
              if (O.D) {
                const dl = ii.g ? ii.g.getResponseHeader("X-HTTP-Session-Id") : null;
                dl && (O.ya = dl, xt(O.I, O.D, dl));
              }
            }
            E.G = 3, E.l && E.l.ua(), E.ba && (E.R = Date.now() - u.F, E.j.info("Handshake RTT: " + E.R + "ms")), O = E;
            var G = u;
            if (O.qa = id(O, O.J ? O.ia : null, O.W), G.K) {
              ku(O.h, G);
              var gt = G, ne = O.L;
              ne && (gt.I = ne), gt.B && (rl(gt), oo(gt)), O.g = G;
            } else Ju(O);
            0 < E.i.length && mo(E);
          } else lt[0] != "stop" && lt[0] != "close" || cn(E, 7);
          else E.G == 3 && (lt[0] == "stop" || lt[0] == "close" ? lt[0] == "stop" ? cn(E, 7) : hl(E) : lt[0] != "noop" && E.l && E.l.ta(lt), E.v = 0);
        }
      }
      jr(4);
    } catch {
    }
  }
  var T0 = class {
    constructor(u, _) {
      this.g = u, this.map = _;
    }
  };
  function Pu(u) {
    this.l = u || 10, a.PerformanceNavigationTiming ? (u = a.performance.getEntriesByType("navigation"), u = 0 < u.length && (u[0].nextHopProtocol == "hq" || u[0].nextHopProtocol == "h2")) : u = !!(a.chrome && a.chrome.loadTimes && a.chrome.loadTimes() && a.chrome.loadTimes().wasFetchedViaSpdy), this.j = u ? this.l : 1, this.g = null, 1 < this.j && (this.g = /* @__PURE__ */ new Set()), this.h = null, this.i = [];
  }
  function Iu(u) {
    return u.h ? !0 : u.g ? u.g.size >= u.j : !1;
  }
  function Ru(u) {
    return u.h ? 1 : u.g ? u.g.size : 0;
  }
  function ol(u, _) {
    return u.h ? u.h == _ : u.g ? u.g.has(_) : !1;
  }
  function al(u, _) {
    u.g ? u.g.add(_) : u.h = _;
  }
  function ku(u, _) {
    u.h && u.h == _ ? u.h = null : u.g && u.g.has(_) && u.g.delete(_);
  }
  Pu.prototype.cancel = function() {
    if (this.i = Mu(this), this.h) this.h.cancel(), this.h = null;
    else if (this.g && this.g.size !== 0) {
      for (const u of this.g.values()) u.cancel();
      this.g.clear();
    }
  };
  function Mu(u) {
    if (u.h != null) return u.i.concat(u.h.D);
    if (u.g != null && u.g.size !== 0) {
      let _ = u.i;
      for (const E of u.g.values()) _ = _.concat(E.D);
      return _;
    }
    return g(u.i);
  }
  function E0(u) {
    if (u.V && typeof u.V == "function") return u.V();
    if (typeof Map < "u" && u instanceof Map || typeof Set < "u" && u instanceof Set) return Array.from(u.values());
    if (typeof u == "string") return u.split("");
    if (l(u)) {
      for (var _ = [], E = u.length, O = 0; O < E; O++) _.push(u[O]);
      return _;
    }
    _ = [], E = 0;
    for (O in u) _[E++] = u[O];
    return _;
  }
  function C0(u) {
    if (u.na && typeof u.na == "function") return u.na();
    if (!u.V || typeof u.V != "function") {
      if (typeof Map < "u" && u instanceof Map) return Array.from(u.keys());
      if (!(typeof Set < "u" && u instanceof Set)) {
        if (l(u) || typeof u == "string") {
          var _ = [];
          u = u.length;
          for (var E = 0; E < u; E++) _.push(E);
          return _;
        }
        _ = [], E = 0;
        for (const O in u) _[E++] = O;
        return _;
      }
    }
  }
  function Ou(u, _) {
    if (u.forEach && typeof u.forEach == "function") u.forEach(_, void 0);
    else if (l(u) || typeof u == "string") Array.prototype.forEach.call(u, _, void 0);
    else for (var E = C0(u), O = E0(u), D = O.length, F = 0; F < D; F++) _.call(void 0, O[F], E && E[F], u);
  }
  var Du = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$");
  function P0(u, _) {
    if (u) {
      u = u.split("&");
      for (var E = 0; E < u.length; E++) {
        var O = u[E].indexOf("="), D = null;
        if (0 <= O) {
          var F = u[E].substring(0, O);
          D = u[E].substring(O + 1);
        } else F = u[E];
        _(F, D ? decodeURIComponent(D.replace(/\+/g, " ")) : "");
      }
    }
  }
  function hn(u) {
    if (this.g = this.o = this.j = "", this.s = null, this.m = this.l = "", this.h = !1, u instanceof hn) {
      this.h = u.h, ao(this, u.j), this.o = u.o, this.g = u.g, lo(this, u.s), this.l = u.l;
      var _ = u.i, E = new Xr();
      E.i = _.i, _.g && (E.g = new Map(_.g), E.h = _.h), Bu(this, E), this.m = u.m;
    } else u && (_ = String(u).match(Du)) ? (this.h = !1, ao(this, _[1] || "", !0), this.o = qr(_[2] || ""), this.g = qr(_[3] || "", !0), lo(this, _[4]), this.l = qr(_[5] || "", !0), Bu(this, _[6] || "", !0), this.m = qr(_[7] || "")) : (this.h = !1, this.i = new Xr(null, this.h));
  }
  hn.prototype.toString = function() {
    var u = [], _ = this.j;
    _ && u.push(Yr(_, Vu, !0), ":");
    var E = this.g;
    return (E || _ == "file") && (u.push("//"), (_ = this.o) && u.push(Yr(_, Vu, !0), "@"), u.push(encodeURIComponent(String(E)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), E = this.s, E != null && u.push(":", String(E))), (E = this.l) && (this.g && E.charAt(0) != "/" && u.push("/"), u.push(Yr(E, E.charAt(0) == "/" ? k0 : R0, !0))), (E = this.i.toString()) && u.push("?", E), (E = this.m) && u.push("#", Yr(E, O0)), u.join("");
  };
  function Si(u) {
    return new hn(u);
  }
  function ao(u, _, E) {
    u.j = E ? qr(_, !0) : _, u.j && (u.j = u.j.replace(/:$/, ""));
  }
  function lo(u, _) {
    if (_) {
      if (_ = Number(_), isNaN(_) || 0 > _) throw Error("Bad port number " + _);
      u.s = _;
    } else u.s = null;
  }
  function Bu(u, _, E) {
    _ instanceof Xr ? (u.i = _, D0(u.i, u.h)) : (E || (_ = Yr(_, M0)), u.i = new Xr(_, u.h));
  }
  function xt(u, _, E) {
    u.i.set(_, E);
  }
  function ho(u) {
    return xt(u, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36)), u;
  }
  function qr(u, _) {
    return u ? _ ? decodeURI(u.replace(/%25/g, "%2525")) : decodeURIComponent(u) : "";
  }
  function Yr(u, _, E) {
    return typeof u == "string" ? (u = encodeURI(u).replace(_, I0), E && (u = u.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), u) : null;
  }
  function I0(u) {
    return u = u.charCodeAt(0), "%" + (u >> 4 & 15).toString(16) + (u & 15).toString(16);
  }
  var Vu = /[#\/\?@]/g, R0 = /[#\?:]/g, k0 = /[#\?]/g, M0 = /[#\?@]/g, O0 = /#/g;
  function Xr(u, _) {
    this.h = this.g = null, this.i = u || null, this.j = !!_;
  }
  function zi(u) {
    u.g || (u.g = /* @__PURE__ */ new Map(), u.h = 0, u.i && P0(u.i, function(_, E) {
      u.add(decodeURIComponent(_.replace(/\+/g, " ")), E);
    }));
  }
  i = Xr.prototype, i.add = function(u, _) {
    zi(this), this.i = null, u = Kn(this, u);
    var E = this.g.get(u);
    return E || this.g.set(u, E = []), E.push(_), this.h += 1, this;
  };
  function Fu(u, _) {
    zi(u), _ = Kn(u, _), u.g.has(_) && (u.i = null, u.h -= u.g.get(_).length, u.g.delete(_));
  }
  function Lu(u, _) {
    return zi(u), _ = Kn(u, _), u.g.has(_);
  }
  i.forEach = function(u, _) {
    zi(this), this.g.forEach(function(E, O) {
      E.forEach(function(D) {
        u.call(_, D, O, this);
      }, this);
    }, this);
  }, i.na = function() {
    zi(this);
    const u = Array.from(this.g.values()), _ = Array.from(this.g.keys()), E = [];
    for (let O = 0; O < _.length; O++) {
      const D = u[O];
      for (let F = 0; F < D.length; F++) E.push(_[O]);
    }
    return E;
  }, i.V = function(u) {
    zi(this);
    let _ = [];
    if (typeof u == "string") Lu(this, u) && (_ = _.concat(this.g.get(Kn(this, u))));
    else {
      u = Array.from(this.g.values());
      for (let E = 0; E < u.length; E++) _ = _.concat(u[E]);
    }
    return _;
  }, i.set = function(u, _) {
    return zi(this), this.i = null, u = Kn(this, u), Lu(this, u) && (this.h -= this.g.get(u).length), this.g.set(u, [_]), this.h += 1, this;
  }, i.get = function(u, _) {
    return u ? (u = this.V(u), 0 < u.length ? String(u[0]) : _) : _;
  };
  function Nu(u, _, E) {
    Fu(u, _), 0 < E.length && (u.i = null, u.g.set(Kn(u, _), g(E)), u.h += E.length);
  }
  i.toString = function() {
    if (this.i) return this.i;
    if (!this.g) return "";
    const u = [], _ = Array.from(this.g.keys());
    for (var E = 0; E < _.length; E++) {
      var O = _[E];
      const F = encodeURIComponent(String(O)), G = this.V(O);
      for (O = 0; O < G.length; O++) {
        var D = F;
        G[O] !== "" && (D += "=" + encodeURIComponent(String(G[O]))), u.push(D);
      }
    }
    return this.i = u.join("&");
  };
  function Kn(u, _) {
    return _ = String(_), u.j && (_ = _.toLowerCase()), _;
  }
  function D0(u, _) {
    _ && !u.j && (zi(u), u.i = null, u.g.forEach(function(E, O) {
      var D = O.toLowerCase();
      O != D && (Fu(this, O), Nu(this, D, E));
    }, u)), u.j = _;
  }
  function B0(u, _) {
    const E = new Hr();
    if (a.Image) {
      const O = new Image();
      O.onload = d(ji, E, "TestLoadImage: loaded", !0, _, O), O.onerror = d(ji, E, "TestLoadImage: error", !1, _, O), O.onabort = d(ji, E, "TestLoadImage: abort", !1, _, O), O.ontimeout = d(ji, E, "TestLoadImage: timeout", !1, _, O), a.setTimeout(function() {
        O.ontimeout && O.ontimeout();
      }, 1e4), O.src = u;
    } else _(!1);
  }
  function V0(u, _) {
    const E = new Hr(), O = new AbortController(), D = setTimeout(() => {
      O.abort(), ji(E, "TestPingServer: timeout", !1, _);
    }, 1e4);
    fetch(u, { signal: O.signal }).then((F) => {
      clearTimeout(D), F.ok ? ji(E, "TestPingServer: ok", !0, _) : ji(E, "TestPingServer: server error", !1, _);
    }).catch(() => {
      clearTimeout(D), ji(E, "TestPingServer: error", !1, _);
    });
  }
  function ji(u, _, E, O, D) {
    try {
      D && (D.onload = null, D.onerror = null, D.onabort = null, D.ontimeout = null), O(E);
    } catch {
    }
  }
  function F0() {
    this.g = new _0();
  }
  function L0(u, _, E) {
    const O = E || "";
    try {
      Ou(u, function(D, F) {
        let G = D;
        h(D) && (G = Ja(D)), _.push(O + F + "=" + encodeURIComponent(G));
      });
    } catch (D) {
      throw _.push(O + "type=" + encodeURIComponent("_badmap")), D;
    }
  }
  function co(u) {
    this.l = u.Ub || null, this.j = u.eb || !1;
  }
  m(co, Za), co.prototype.g = function() {
    return new uo(this.l, this.j);
  }, co.prototype.i = /* @__PURE__ */ function(u) {
    return function() {
      return u;
    };
  }({});
  function uo(u, _) {
    Vt.call(this), this.D = u, this.o = _, this.m = void 0, this.status = this.readyState = 0, this.responseType = this.responseText = this.response = this.statusText = "", this.onreadystatechange = null, this.u = new Headers(), this.h = null, this.B = "GET", this.A = "", this.g = !1, this.v = this.j = this.l = null;
  }
  m(uo, Vt), i = uo.prototype, i.open = function(u, _) {
    if (this.readyState != 0) throw this.abort(), Error("Error reopening a connection");
    this.B = u, this.A = _, this.readyState = 1, Qr(this);
  }, i.send = function(u) {
    if (this.readyState != 1) throw this.abort(), Error("need to call open() first. ");
    this.g = !0;
    const _ = { headers: this.u, method: this.B, credentials: this.m, cache: void 0 };
    u && (_.body = u), (this.D || a).fetch(new Request(this.A, _)).then(this.Sa.bind(this), this.ga.bind(this));
  }, i.abort = function() {
    this.response = this.responseText = "", this.u = new Headers(), this.status = 0, this.j && this.j.cancel("Request was aborted.").catch(() => {
    }), 1 <= this.readyState && this.g && this.readyState != 4 && (this.g = !1, Kr(this)), this.readyState = 0;
  }, i.Sa = function(u) {
    if (this.g && (this.l = u, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = u.headers, this.readyState = 2, Qr(this)), this.g && (this.readyState = 3, Qr(this), this.g))) if (this.responseType === "arraybuffer") u.arrayBuffer().then(this.Qa.bind(this), this.ga.bind(this));
    else if (typeof a.ReadableStream < "u" && "body" in u) {
      if (this.j = u.body.getReader(), this.o) {
        if (this.responseType) throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
        this.response = [];
      } else this.response = this.responseText = "", this.v = new TextDecoder();
      Uu(this);
    } else u.text().then(this.Ra.bind(this), this.ga.bind(this));
  };
  function Uu(u) {
    u.j.read().then(u.Pa.bind(u)).catch(u.ga.bind(u));
  }
  i.Pa = function(u) {
    if (this.g) {
      if (this.o && u.value) this.response.push(u.value);
      else if (!this.o) {
        var _ = u.value ? u.value : new Uint8Array(0);
        (_ = this.v.decode(_, { stream: !u.done })) && (this.response = this.responseText += _);
      }
      u.done ? Kr(this) : Qr(this), this.readyState == 3 && Uu(this);
    }
  }, i.Ra = function(u) {
    this.g && (this.response = this.responseText = u, Kr(this));
  }, i.Qa = function(u) {
    this.g && (this.response = u, Kr(this));
  }, i.ga = function() {
    this.g && Kr(this);
  };
  function Kr(u) {
    u.readyState = 4, u.l = null, u.j = null, u.v = null, Qr(u);
  }
  i.setRequestHeader = function(u, _) {
    this.u.append(u, _);
  }, i.getResponseHeader = function(u) {
    return this.h && this.h.get(u.toLowerCase()) || "";
  }, i.getAllResponseHeaders = function() {
    if (!this.h) return "";
    const u = [], _ = this.h.entries();
    for (var E = _.next(); !E.done; ) E = E.value, u.push(E[0] + ": " + E[1]), E = _.next();
    return u.join(`\r
`);
  };
  function Qr(u) {
    u.onreadystatechange && u.onreadystatechange.call(u);
  }
  Object.defineProperty(uo.prototype, "withCredentials", { get: function() {
    return this.m === "include";
  }, set: function(u) {
    this.m = u ? "include" : "same-origin";
  } });
  function zu(u) {
    let _ = "";
    return R(u, function(E, O) {
      _ += O, _ += ":", _ += E, _ += `\r
`;
    }), _;
  }
  function ll(u, _, E) {
    t: {
      for (O in E) {
        var O = !1;
        break t;
      }
      O = !0;
    }
    O || (E = zu(E), typeof u == "string" ? E != null && encodeURIComponent(String(E)) : xt(u, _, E));
  }
  function Ot(u) {
    Vt.call(this), this.headers = /* @__PURE__ */ new Map(), this.o = u || null, this.h = !1, this.v = this.g = null, this.D = "", this.m = 0, this.l = "", this.j = this.B = this.u = this.A = !1, this.I = null, this.H = "", this.J = !1;
  }
  m(Ot, Vt);
  var N0 = /^https?$/i, U0 = ["POST", "PUT"];
  i = Ot.prototype, i.Ha = function(u) {
    this.J = u;
  }, i.ea = function(u, _, E, O) {
    if (this.g) throw Error("[goog.net.XhrIo] Object is active with another request=" + this.D + "; newUri=" + u);
    _ = _ ? _.toUpperCase() : "GET", this.D = u, this.l = "", this.m = 0, this.A = !1, this.h = !0, this.g = this.o ? this.o.g() : el.g(), this.v = this.o ? gu(this.o) : gu(el), this.g.onreadystatechange = f(this.Ea, this);
    try {
      this.B = !0, this.g.open(_, String(u), !0), this.B = !1;
    } catch (F) {
      ju(this, F);
      return;
    }
    if (u = E || "", E = new Map(this.headers), O) if (Object.getPrototypeOf(O) === Object.prototype) for (var D in O) E.set(D, O[D]);
    else if (typeof O.keys == "function" && typeof O.get == "function") for (const F of O.keys()) E.set(F, O.get(F));
    else throw Error("Unknown input type for opt_headers: " + String(O));
    O = Array.from(E.keys()).find((F) => F.toLowerCase() == "content-type"), D = a.FormData && u instanceof a.FormData, !(0 <= Array.prototype.indexOf.call(U0, _, void 0)) || O || D || E.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
    for (const [F, G] of E) this.g.setRequestHeader(F, G);
    this.H && (this.g.responseType = this.H), "withCredentials" in this.g && this.g.withCredentials !== this.J && (this.g.withCredentials = this.J);
    try {
      Wu(this), this.u = !0, this.g.send(u), this.u = !1;
    } catch (F) {
      ju(this, F);
    }
  };
  function ju(u, _) {
    u.h = !1, u.g && (u.j = !0, u.g.abort(), u.j = !1), u.l = _, u.m = 5, Gu(u), po(u);
  }
  function Gu(u) {
    u.A || (u.A = !0, ie(u, "complete"), ie(u, "error"));
  }
  i.abort = function(u) {
    this.g && this.h && (this.h = !1, this.j = !0, this.g.abort(), this.j = !1, this.m = u || 7, ie(this, "complete"), ie(this, "abort"), po(this));
  }, i.N = function() {
    this.g && (this.h && (this.h = !1, this.j = !0, this.g.abort(), this.j = !1), po(this, !0)), Ot.aa.N.call(this);
  }, i.Ea = function() {
    this.s || (this.B || this.u || this.j ? Hu(this) : this.bb());
  }, i.bb = function() {
    Hu(this);
  };
  function Hu(u) {
    if (u.h && typeof o < "u" && (!u.v[1] || Ti(u) != 4 || u.Z() != 2)) {
      if (u.u && Ti(u) == 4) sn(u.Ea, 0, u);
      else if (ie(u, "readystatechange"), Ti(u) == 4) {
        u.h = !1;
        try {
          const G = u.Z();
          t: switch (G) {
            case 200:
            case 201:
            case 202:
            case 204:
            case 206:
            case 304:
            case 1223:
              var _ = !0;
              break t;
            default:
              _ = !1;
          }
          var E;
          if (!(E = _)) {
            var O;
            if (O = G === 0) {
              var D = String(u.D).match(Du)[1] || null;
              !D && a.self && a.self.location && (D = a.self.location.protocol.slice(0, -1)), O = !N0.test(D ? D.toLowerCase() : "");
            }
            E = O;
          }
          if (E) ie(u, "complete"), ie(u, "success");
          else {
            u.m = 6;
            try {
              var F = 2 < Ti(u) ? u.g.statusText : "";
            } catch {
              F = "";
            }
            u.l = F + " [" + u.Z() + "]", Gu(u);
          }
        } finally {
          po(u);
        }
      }
    }
  }
  function po(u, _) {
    if (u.g) {
      Wu(u);
      const E = u.g, O = u.v[0] ? () => {
      } : null;
      u.g = null, u.v = null, _ || ie(u, "ready");
      try {
        E.onreadystatechange = O;
      } catch {
      }
    }
  }
  function Wu(u) {
    u.I && (a.clearTimeout(u.I), u.I = null);
  }
  i.isActive = function() {
    return !!this.g;
  };
  function Ti(u) {
    return u.g ? u.g.readyState : 0;
  }
  i.Z = function() {
    try {
      return 2 < Ti(this) ? this.g.status : -1;
    } catch {
      return -1;
    }
  }, i.oa = function() {
    try {
      return this.g ? this.g.responseText : "";
    } catch {
      return "";
    }
  }, i.Oa = function(u) {
    if (this.g) {
      var _ = this.g.responseText;
      return u && _.indexOf(u) == 0 && (_ = _.substring(u.length)), v0(_);
    }
  };
  function qu(u) {
    try {
      if (!u.g) return null;
      if ("response" in u.g) return u.g.response;
      switch (u.H) {
        case "":
        case "text":
          return u.g.responseText;
        case "arraybuffer":
          if ("mozResponseArrayBuffer" in u.g) return u.g.mozResponseArrayBuffer;
      }
      return null;
    } catch {
      return null;
    }
  }
  function z0(u) {
    const _ = {};
    u = (u.g && 2 <= Ti(u) && u.g.getAllResponseHeaders() || "").split(`\r
`);
    for (let O = 0; O < u.length; O++) {
      if (S(u[O])) continue;
      var E = P(u[O]);
      const D = E[0];
      if (E = E[1], typeof E != "string") continue;
      E = E.trim();
      const F = _[D] || [];
      _[D] = F, F.push(E);
    }
    w(_, function(O) {
      return O.join(", ");
    });
  }
  i.Ba = function() {
    return this.m;
  }, i.Ka = function() {
    return typeof this.l == "string" ? this.l : String(this.l);
  };
  function Jr(u, _, E) {
    return E && E.internalChannelParams && E.internalChannelParams[u] || _;
  }
  function Yu(u) {
    this.Aa = 0, this.i = [], this.j = new Hr(), this.ia = this.qa = this.I = this.W = this.g = this.ya = this.D = this.H = this.m = this.S = this.o = null, this.Ya = this.U = 0, this.Va = Jr("failFast", !1, u), this.F = this.C = this.u = this.s = this.l = null, this.X = !0, this.za = this.T = -1, this.Y = this.v = this.B = 0, this.Ta = Jr("baseRetryDelayMs", 5e3, u), this.cb = Jr("retryDelaySeedMs", 1e4, u), this.Wa = Jr("forwardChannelMaxRetries", 2, u), this.wa = Jr("forwardChannelRequestTimeoutMs", 2e4, u), this.pa = u && u.xmlHttpFactory || void 0, this.Xa = u && u.Tb || void 0, this.Ca = u && u.useFetchStreams || !1, this.L = void 0, this.J = u && u.supportsCrossDomainXhr || !1, this.K = "", this.h = new Pu(u && u.concurrentRequestLimit), this.Da = new F0(), this.P = u && u.fastHandshake || !1, this.O = u && u.encodeInitMessageHeaders || !1, this.P && this.O && (this.O = !1), this.Ua = u && u.Rb || !1, u && u.xa && this.j.xa(), u && u.forceLongPolling && (this.X = !1), this.ba = !this.P && this.X && u && u.detectBufferingProxy || !1, this.ja = void 0, u && u.longPollingTimeout && 0 < u.longPollingTimeout && (this.ja = u.longPollingTimeout), this.ca = void 0, this.R = 0, this.M = !1, this.ka = this.A = null;
  }
  i = Yu.prototype, i.la = 8, i.G = 1, i.connect = function(u, _, E, O) {
    be(0), this.W = u, this.H = _ || {}, E && O !== void 0 && (this.H.OSID = E, this.H.OAID = O), this.F = this.X, this.I = id(this, null, this.W), mo(this);
  };
  function hl(u) {
    if (Xu(u), u.G == 3) {
      var _ = u.U++, E = Si(u.I);
      if (xt(E, "SID", u.K), xt(E, "RID", _), xt(E, "TYPE", "terminate"), Zr(u, E), _ = new Ui(u, u.j, _), _.L = 2, _.v = ho(Si(E)), E = !1, a.navigator && a.navigator.sendBeacon) try {
        E = a.navigator.sendBeacon(_.v.toString(), "");
      } catch {
      }
      !E && a.Image && (new Image().src = _.v, E = !0), E || (_.g = nd(_.j, null), _.g.ea(_.v)), _.F = Date.now(), oo(_);
    }
    ed(u);
  }
  function fo(u) {
    u.g && (ul(u), u.g.cancel(), u.g = null);
  }
  function Xu(u) {
    fo(u), u.u && (a.clearTimeout(u.u), u.u = null), go(u), u.h.cancel(), u.s && (typeof u.s == "number" && a.clearTimeout(u.s), u.s = null);
  }
  function mo(u) {
    if (!Iu(u.h) && !u.s) {
      u.s = !0;
      var _ = u.Ga;
      U || H(), K || (U(), K = !0), j.add(_, u), u.B = 0;
    }
  }
  function j0(u, _) {
    return Ru(u.h) >= u.h.j - (u.s ? 1 : 0) ? !1 : u.s ? (u.i = _.D.concat(u.i), !0) : u.G == 1 || u.G == 2 || u.B >= (u.Va ? 0 : u.Wa) ? !1 : (u.s = Gr(f(u.Ga, u, _), td(u, u.B)), u.B++, !0);
  }
  i.Ga = function(u) {
    if (this.s) if (this.s = null, this.G == 1) {
      if (!u) {
        this.U = Math.floor(1e5 * Math.random()), u = this.U++;
        const D = new Ui(this, this.j, u);
        let F = this.o;
        if (this.S && (F ? (F = v(F), A(F, this.S)) : F = this.S), this.m !== null || this.O || (D.H = F, F = null), this.P) t: {
          for (var _ = 0, E = 0; E < this.i.length; E++) {
            e: {
              var O = this.i[E];
              if ("__data__" in O.map && (O = O.map.__data__, typeof O == "string")) {
                O = O.length;
                break e;
              }
              O = void 0;
            }
            if (O === void 0) break;
            if (_ += O, 4096 < _) {
              _ = E;
              break t;
            }
            if (_ === 4096 || E === this.i.length - 1) {
              _ = E + 1;
              break t;
            }
          }
          _ = 1e3;
        }
        else _ = 1e3;
        _ = Qu(this, D, _), E = Si(this.I), xt(E, "RID", u), xt(E, "CVER", 22), this.D && xt(E, "X-HTTP-Session-Id", this.D), Zr(this, E), F && (this.O ? _ = "headers=" + encodeURIComponent(String(zu(F))) + "&" + _ : this.m && ll(E, this.m, F)), al(this.h, D), this.Ua && xt(E, "TYPE", "init"), this.P ? (xt(E, "$req", _), xt(E, "SID", "null"), D.T = !0, nl(D, E, null)) : nl(D, E, _), this.G = 2;
      }
    } else this.G == 3 && (u ? Ku(this, u) : this.i.length == 0 || Iu(this.h) || Ku(this));
  };
  function Ku(u, _) {
    var E;
    _ ? E = _.l : E = u.U++;
    const O = Si(u.I);
    xt(O, "SID", u.K), xt(O, "RID", E), xt(O, "AID", u.T), Zr(u, O), u.m && u.o && ll(O, u.m, u.o), E = new Ui(u, u.j, E, u.B + 1), u.m === null && (E.H = u.o), _ && (u.i = _.D.concat(u.i)), _ = Qu(u, E, 1e3), E.I = Math.round(0.5 * u.wa) + Math.round(0.5 * u.wa * Math.random()), al(u.h, E), nl(E, O, _);
  }
  function Zr(u, _) {
    u.H && R(u.H, function(E, O) {
      xt(_, O, E);
    }), u.l && Ou({}, function(E, O) {
      xt(_, O, E);
    });
  }
  function Qu(u, _, E) {
    E = Math.min(u.i.length, E);
    var O = u.l ? f(u.l.Na, u.l, u) : null;
    t: {
      var D = u.i;
      let F = -1;
      for (; ; ) {
        const G = ["count=" + E];
        F == -1 ? 0 < E ? (F = D[0].g, G.push("ofs=" + F)) : F = 0 : G.push("ofs=" + F);
        let gt = !0;
        for (let ne = 0; ne < E; ne++) {
          let lt = D[ne].g;
          const he = D[ne].map;
          if (lt -= F, 0 > lt) F = Math.max(0, D[ne].g - 100), gt = !1;
          else try {
            L0(he, G, "req" + lt + "_");
          } catch {
            O && O(he);
          }
        }
        if (gt) {
          O = G.join("&");
          break t;
        }
      }
    }
    return u = u.i.splice(0, E), _.D = u, O;
  }
  function Ju(u) {
    if (!u.g && !u.u) {
      u.Y = 1;
      var _ = u.Fa;
      U || H(), K || (U(), K = !0), j.add(_, u), u.v = 0;
    }
  }
  function cl(u) {
    return u.g || u.u || 3 <= u.v ? !1 : (u.Y++, u.u = Gr(f(u.Fa, u), td(u, u.v)), u.v++, !0);
  }
  i.Fa = function() {
    if (this.u = null, Zu(this), this.ba && !(this.M || this.g == null || 0 >= this.R)) {
      var u = 2 * this.R;
      this.j.info("BP detection timer enabled: " + u), this.A = Gr(f(this.ab, this), u);
    }
  }, i.ab = function() {
    this.A && (this.A = null, this.j.info("BP detection timeout reached."), this.j.info("Buffering proxy detected and switch to long-polling!"), this.F = !1, this.M = !0, be(10), fo(this), Zu(this));
  };
  function ul(u) {
    u.A != null && (a.clearTimeout(u.A), u.A = null);
  }
  function Zu(u) {
    u.g = new Ui(u, u.j, "rpc", u.Y), u.m === null && (u.g.H = u.o), u.g.O = 0;
    var _ = Si(u.qa);
    xt(_, "RID", "rpc"), xt(_, "SID", u.K), xt(_, "AID", u.T), xt(_, "CI", u.F ? "0" : "1"), !u.F && u.ja && xt(_, "TO", u.ja), xt(_, "TYPE", "xmlhttp"), Zr(u, _), u.m && u.o && ll(_, u.m, u.o), u.L && (u.g.I = u.L);
    var E = u.g;
    u = u.ia, E.L = 1, E.v = ho(Si(_)), E.m = null, E.P = !0, Tu(E, u);
  }
  i.Za = function() {
    this.C != null && (this.C = null, fo(this), cl(this), be(19));
  };
  function go(u) {
    u.C != null && (a.clearTimeout(u.C), u.C = null);
  }
  function $u(u, _) {
    var E = null;
    if (u.g == _) {
      go(u), ul(u), u.g = null;
      var O = 2;
    } else if (ol(u.h, _)) E = _.D, ku(u.h, _), O = 1;
    else return;
    if (u.G != 0) {
      if (_.o) if (O == 1) {
        E = _.m ? _.m.length : 0, _ = Date.now() - _.F;
        var D = u.B;
        O = no(), ie(O, new bu(O, E)), mo(u);
      } else Ju(u);
      else if (D = _.s, D == 3 || D == 0 && 0 < _.X || !(O == 1 && j0(u, _) || O == 2 && cl(u))) switch (E && 0 < E.length && (_ = u.h, _.i = _.i.concat(E)), D) {
        case 1:
          cn(u, 5);
          break;
        case 4:
          cn(u, 10);
          break;
        case 3:
          cn(u, 6);
          break;
        default:
          cn(u, 2);
      }
    }
  }
  function td(u, _) {
    let E = u.Ta + Math.floor(Math.random() * u.cb);
    return u.isActive() || (E *= 2), E * _;
  }
  function cn(u, _) {
    if (u.j.info("Error code " + _), _ == 2) {
      var E = f(u.fb, u), O = u.Xa;
      const D = !O;
      O = new hn(O || "//www.google.com/images/cleardot.gif"), a.location && a.location.protocol == "http" || ao(O, "https"), ho(O), D ? B0(O.toString(), E) : V0(O.toString(), E);
    } else be(2);
    u.G = 0, u.l && u.l.sa(_), ed(u), Xu(u);
  }
  i.fb = function(u) {
    u ? (this.j.info("Successfully pinged google.com"), be(2)) : (this.j.info("Failed to ping google.com"), be(1));
  };
  function ed(u) {
    if (u.G = 0, u.ka = [], u.l) {
      const _ = Mu(u.h);
      (_.length != 0 || u.i.length != 0) && (y(u.ka, _), y(u.ka, u.i), u.h.i.length = 0, g(u.i), u.i.length = 0), u.l.ra();
    }
  }
  function id(u, _, E) {
    var O = E instanceof hn ? Si(E) : new hn(E);
    if (O.g != "") _ && (O.g = _ + "." + O.g), lo(O, O.s);
    else {
      var D = a.location;
      O = D.protocol, _ = _ ? _ + "." + D.hostname : D.hostname, D = +D.port;
      var F = new hn(null);
      O && ao(F, O), _ && (F.g = _), D && lo(F, D), E && (F.l = E), O = F;
    }
    return E = u.D, _ = u.ya, E && _ && xt(O, E, _), xt(O, "VER", u.la), Zr(u, O), O;
  }
  function nd(u, _, E) {
    if (_ && !u.J) throw Error("Can't create secondary domain capable XhrIo object.");
    return _ = u.Ca && !u.pa ? new Ot(new co({ eb: E })) : new Ot(u.pa), _.Ha(u.J), _;
  }
  i.isActive = function() {
    return !!this.l && this.l.isActive(this);
  };
  function rd() {
  }
  i = rd.prototype, i.ua = function() {
  }, i.ta = function() {
  }, i.sa = function() {
  }, i.ra = function() {
  }, i.isActive = function() {
    return !0;
  }, i.Na = function() {
  };
  function yo() {
  }
  yo.prototype.g = function(u, _) {
    return new ze(u, _);
  };
  function ze(u, _) {
    Vt.call(this), this.g = new Yu(_), this.l = u, this.h = _ && _.messageUrlParams || null, u = _ && _.messageHeaders || null, _ && _.clientProtocolHeaderRequired && (u ? u["X-Client-Protocol"] = "webchannel" : u = { "X-Client-Protocol": "webchannel" }), this.g.o = u, u = _ && _.initMessageHeaders || null, _ && _.messageContentType && (u ? u["X-WebChannel-Content-Type"] = _.messageContentType : u = { "X-WebChannel-Content-Type": _.messageContentType }), _ && _.va && (u ? u["X-WebChannel-Client-Profile"] = _.va : u = { "X-WebChannel-Client-Profile": _.va }), this.g.S = u, (u = _ && _.Sb) && !S(u) && (this.g.m = u), this.v = _ && _.supportsCrossDomainXhr || !1, this.u = _ && _.sendRawJson || !1, (_ = _ && _.httpSessionIdParam) && !S(_) && (this.g.D = _, u = this.h, u !== null && _ in u && (u = this.h, _ in u && delete u[_])), this.j = new Qn(this);
  }
  m(ze, Vt), ze.prototype.m = function() {
    this.g.l = this.j, this.v && (this.g.J = !0), this.g.connect(this.l, this.h || void 0);
  }, ze.prototype.close = function() {
    hl(this.g);
  }, ze.prototype.o = function(u) {
    var _ = this.g;
    if (typeof u == "string") {
      var E = {};
      E.__data__ = u, u = E;
    } else this.u && (E = {}, E.__data__ = Ja(u), u = E);
    _.i.push(new T0(_.Ya++, u)), _.G == 3 && mo(_);
  }, ze.prototype.N = function() {
    this.g.l = null, delete this.j, hl(this.g), delete this.g, ze.aa.N.call(this);
  };
  function sd(u) {
    $a.call(this), u.__headers__ && (this.headers = u.__headers__, this.statusCode = u.__status__, delete u.__headers__, delete u.__status__);
    var _ = u.__sm__;
    if (_) {
      t: {
        for (const E in _) {
          u = E;
          break t;
        }
        u = void 0;
      }
      (this.i = u) && (u = this.i, _ = _ !== null && u in _ ? _[u] : void 0), this.data = _;
    } else this.data = u;
  }
  m(sd, $a);
  function od() {
    tl.call(this), this.status = 1;
  }
  m(od, tl);
  function Qn(u) {
    this.g = u;
  }
  m(Qn, rd), Qn.prototype.ua = function() {
    ie(this.g, "a");
  }, Qn.prototype.ta = function(u) {
    ie(this.g, new sd(u));
  }, Qn.prototype.sa = function(u) {
    ie(this.g, new od());
  }, Qn.prototype.ra = function() {
    ie(this.g, "b");
  }, yo.prototype.createWebChannel = yo.prototype.g, ze.prototype.send = ze.prototype.o, ze.prototype.open = ze.prototype.m, ze.prototype.close = ze.prototype.close, gy = function() {
    return new yo();
  }, my = function() {
    return no();
  }, fy = an, $h = { mb: 0, pb: 1, qb: 2, Jb: 3, Ob: 4, Lb: 5, Mb: 6, Kb: 7, Ib: 8, Nb: 9, PROXY: 10, NOPROXY: 11, Gb: 12, Cb: 13, Db: 14, Bb: 15, Eb: 16, Fb: 17, ib: 18, hb: 19, jb: 20 }, ro.NO_ERROR = 0, ro.TIMEOUT = 8, ro.HTTP_ERROR = 6, Ho = ro, wu.COMPLETE = "complete", py = wu, yu.EventType = zr, zr.OPEN = "a", zr.CLOSE = "b", zr.ERROR = "c", zr.MESSAGE = "d", Vt.prototype.listen = Vt.prototype.K, ms = yu, Ot.prototype.listenOnce = Ot.prototype.L, Ot.prototype.getLastError = Ot.prototype.Ka, Ot.prototype.getLastErrorCode = Ot.prototype.Ba, Ot.prototype.getStatus = Ot.prototype.Z, Ot.prototype.getResponseJson = Ot.prototype.Oa, Ot.prototype.getResponseText = Ot.prototype.oa, Ot.prototype.send = Ot.prototype.ea, Ot.prototype.setWithCredentials = Ot.prototype.Ha, dy = Ot;
}).apply(typeof ko < "u" ? ko : typeof self < "u" ? self : typeof window < "u" ? window : {});
const Up = "@firebase/firestore";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class de {
  constructor(t) {
    this.uid = t;
  }
  isAuthenticated() {
    return this.uid != null;
  }
  /**
   * Returns a key representing this user, suitable for inclusion in a
   * dictionary.
   */
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(t) {
    return t.uid === this.uid;
  }
}
de.UNAUTHENTICATED = new de(null), // TODO(mikelehen): Look into getting a proper uid-equivalent for
// non-FirebaseAuth providers.
de.GOOGLE_CREDENTIALS = new de("google-credentials-uid"), de.FIRST_PARTY = new de("first-party-uid"), de.MOCK_USER = new de("mock-user");
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let Fr = "11.0.2";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Fn = new sy("@firebase/firestore");
function ir() {
  return Fn.logLevel;
}
function q(i, ...t) {
  if (Fn.logLevel <= at.DEBUG) {
    const e = t.map(Xc);
    Fn.debug(`Firestore (${Fr}): ${i}`, ...e);
  }
}
function Ln(i, ...t) {
  if (Fn.logLevel <= at.ERROR) {
    const e = t.map(Xc);
    Fn.error(`Firestore (${Fr}): ${i}`, ...e);
  }
}
function fa(i, ...t) {
  if (Fn.logLevel <= at.WARN) {
    const e = t.map(Xc);
    Fn.warn(`Firestore (${Fr}): ${i}`, ...e);
  }
}
function Xc(i) {
  if (typeof i == "string") return i;
  try {
    /**
    * @license
    * Copyright 2020 Google LLC
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */
    return function(e) {
      return JSON.stringify(e);
    }(i);
  } catch {
    return i;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function rt(i = "Unexpected state") {
  const t = `FIRESTORE (${Fr}) INTERNAL ASSERTION FAILED: ` + i;
  throw Ln(t), new Error(t);
}
function Bt(i, t) {
  i || rt();
}
function _t(i, t) {
  return i;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const z = {
  // Causes are copied from:
  // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h
  /** Not an error; returned on success. */
  OK: "ok",
  /** The operation was cancelled (typically by the caller). */
  CANCELLED: "cancelled",
  /** Unknown error or an error from a different error domain. */
  UNKNOWN: "unknown",
  /**
   * Client specified an invalid argument. Note that this differs from
   * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are
   * problematic regardless of the state of the system (e.g., a malformed file
   * name).
   */
  INVALID_ARGUMENT: "invalid-argument",
  /**
   * Deadline expired before operation could complete. For operations that
   * change the state of the system, this error may be returned even if the
   * operation has completed successfully. For example, a successful response
   * from a server could have been delayed long enough for the deadline to
   * expire.
   */
  DEADLINE_EXCEEDED: "deadline-exceeded",
  /** Some requested entity (e.g., file or directory) was not found. */
  NOT_FOUND: "not-found",
  /**
   * Some entity that we attempted to create (e.g., file or directory) already
   * exists.
   */
  ALREADY_EXISTS: "already-exists",
  /**
   * The caller does not have permission to execute the specified operation.
   * PERMISSION_DENIED must not be used for rejections caused by exhausting
   * some resource (use RESOURCE_EXHAUSTED instead for those errors).
   * PERMISSION_DENIED must not be used if the caller cannot be identified
   * (use UNAUTHENTICATED instead for those errors).
   */
  PERMISSION_DENIED: "permission-denied",
  /**
   * The request does not have valid authentication credentials for the
   * operation.
   */
  UNAUTHENTICATED: "unauthenticated",
  /**
   * Some resource has been exhausted, perhaps a per-user quota, or perhaps the
   * entire file system is out of space.
   */
  RESOURCE_EXHAUSTED: "resource-exhausted",
  /**
   * Operation was rejected because the system is not in a state required for
   * the operation's execution. For example, directory to be deleted may be
   * non-empty, an rmdir operation is applied to a non-directory, etc.
   *
   * A litmus test that may help a service implementor in deciding
   * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:
   *  (a) Use UNAVAILABLE if the client can retry just the failing call.
   *  (b) Use ABORTED if the client should retry at a higher-level
   *      (e.g., restarting a read-modify-write sequence).
   *  (c) Use FAILED_PRECONDITION if the client should not retry until
   *      the system state has been explicitly fixed. E.g., if an "rmdir"
   *      fails because the directory is non-empty, FAILED_PRECONDITION
   *      should be returned since the client should not retry unless
   *      they have first fixed up the directory by deleting files from it.
   *  (d) Use FAILED_PRECONDITION if the client performs conditional
   *      REST Get/Update/Delete on a resource and the resource on the
   *      server does not match the condition. E.g., conflicting
   *      read-modify-write on the same resource.
   */
  FAILED_PRECONDITION: "failed-precondition",
  /**
   * The operation was aborted, typically due to a concurrency issue like
   * sequencer check failures, transaction aborts, etc.
   *
   * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
   * and UNAVAILABLE.
   */
  ABORTED: "aborted",
  /**
   * Operation was attempted past the valid range. E.g., seeking or reading
   * past end of file.
   *
   * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed
   * if the system state changes. For example, a 32-bit file system will
   * generate INVALID_ARGUMENT if asked to read at an offset that is not in the
   * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from
   * an offset past the current file size.
   *
   * There is a fair bit of overlap between FAILED_PRECONDITION and
   * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)
   * when it applies so that callers who are iterating through a space can
   * easily look for an OUT_OF_RANGE error to detect when they are done.
   */
  OUT_OF_RANGE: "out-of-range",
  /** Operation is not implemented or not supported/enabled in this service. */
  UNIMPLEMENTED: "unimplemented",
  /**
   * Internal errors. Means some invariants expected by underlying System has
   * been broken. If you see one of these errors, Something is very broken.
   */
  INTERNAL: "internal",
  /**
   * The service is currently unavailable. This is a most likely a transient
   * condition and may be corrected by retrying with a backoff.
   *
   * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
   * and UNAVAILABLE.
   */
  UNAVAILABLE: "unavailable",
  /** Unrecoverable data loss or corruption. */
  DATA_LOSS: "data-loss"
};
class Z extends Vr {
  /** @hideconstructor */
  constructor(t, e) {
    super(t, e), this.code = t, this.message = e, // HACK: We write a toString property directly because Error is not a real
    // class and so inheritance does not work correctly. We could alternatively
    // do the same "back-door inheritance" trick that FirebaseError does.
    this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class kn {
  constructor() {
    this.promise = new Promise((t, e) => {
      this.resolve = t, this.reject = e;
    });
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class yy {
  constructor(t, e) {
    this.user = e, this.type = "OAuth", this.headers = /* @__PURE__ */ new Map(), this.headers.set("Authorization", `Bearer ${t}`);
  }
}
class vT {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(t, e) {
    t.enqueueRetryable(() => e(de.UNAUTHENTICATED));
  }
  shutdown() {
  }
}
class _T {
  constructor(t) {
    this.token = t, /**
     * Stores the listener registered with setChangeListener()
     * This isn't actually necessary since the UID never changes, but we use this
     * to verify the listen contract is adhered to in tests.
     */
    this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(t, e) {
    this.changeListener = e, // Fire with initial user.
    t.enqueueRetryable(() => e(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
}
class xT {
  constructor(t) {
    this.t = t, /** Tracks the current User. */
    this.currentUser = de.UNAUTHENTICATED, /**
     * Counter used to detect if the token changed while a getToken request was
     * outstanding.
     */
    this.i = 0, this.forceRefresh = !1, this.auth = null;
  }
  start(t, e) {
    Bt(this.o === void 0);
    let n = this.i;
    const r = (l) => this.i !== n ? (n = this.i, e(l)) : Promise.resolve();
    let s = new kn();
    this.o = () => {
      this.i++, this.currentUser = this.u(), s.resolve(), s = new kn(), t.enqueueRetryable(() => r(this.currentUser));
    };
    const o = () => {
      const l = s;
      t.enqueueRetryable(async () => {
        await l.promise, await r(this.currentUser);
      });
    }, a = (l) => {
      q("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = l, this.o && (this.auth.addAuthTokenListener(this.o), o());
    };
    this.t.onInit((l) => a(l)), // Our users can initialize Auth right after Firestore, so we give it
    // a chance to register itself with the component framework before we
    // determine whether to start up in unauthenticated mode.
    setTimeout(() => {
      if (!this.auth) {
        const l = this.t.getImmediate({
          optional: !0
        });
        l ? a(l) : (
          // If auth is still not available, proceed with `null` user
          (q("FirebaseAuthCredentialsProvider", "Auth not yet detected"), s.resolve(), s = new kn())
        );
      }
    }, 0), o();
  }
  getToken() {
    const t = this.i, e = this.forceRefresh;
    return this.forceRefresh = !1, this.auth ? this.auth.getToken(e).then((n) => (
      // Cancel the request since the token changed while the request was
      // outstanding so the response is potentially for a previous user (which
      // user, we can't be sure).
      this.i !== t ? (q("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : n ? (Bt(typeof n.accessToken == "string"), new yy(n.accessToken, this.currentUser)) : null
    )) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = !0;
  }
  shutdown() {
    this.auth && this.o && this.auth.removeAuthTokenListener(this.o), this.o = void 0;
  }
  // Auth.getUid() can return null even with a user logged in. It is because
  // getUid() is synchronous, but the auth code populating Uid is asynchronous.
  // This method should only be called in the AuthTokenListener callback
  // to guarantee to get the actual user.
  u() {
    const t = this.auth && this.auth.getUid();
    return Bt(t === null || typeof t == "string"), new de(t);
  }
}
class bT {
  constructor(t, e, n) {
    this.l = t, this.h = e, this.P = n, this.type = "FirstParty", this.user = de.FIRST_PARTY, this.T = /* @__PURE__ */ new Map();
  }
  /**
   * Gets an authorization token, using a provided factory function, or return
   * null.
   */
  I() {
    return this.P ? this.P() : null;
  }
  get headers() {
    this.T.set("X-Goog-AuthUser", this.l);
    const t = this.I();
    return t && this.T.set("Authorization", t), this.h && this.T.set("X-Goog-Iam-Authorization-Token", this.h), this.T;
  }
}
class wT {
  constructor(t, e, n) {
    this.l = t, this.h = e, this.P = n;
  }
  getToken() {
    return Promise.resolve(new bT(this.l, this.h, this.P));
  }
  start(t, e) {
    t.enqueueRetryable(() => e(de.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
}
class AT {
  constructor(t) {
    this.value = t, this.type = "AppCheck", this.headers = /* @__PURE__ */ new Map(), t && t.length > 0 && this.headers.set("x-firebase-appcheck", this.value);
  }
}
class ST {
  constructor(t) {
    this.A = t, this.forceRefresh = !1, this.appCheck = null, this.R = null;
  }
  start(t, e) {
    Bt(this.o === void 0);
    const n = (s) => {
      s.error != null && q("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${s.error.message}`);
      const o = s.token !== this.R;
      return this.R = s.token, q("FirebaseAppCheckTokenProvider", `Received ${o ? "new" : "existing"} token.`), o ? e(s.token) : Promise.resolve();
    };
    this.o = (s) => {
      t.enqueueRetryable(() => n(s));
    };
    const r = (s) => {
      q("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = s, this.o && this.appCheck.addTokenListener(this.o);
    };
    this.A.onInit((s) => r(s)), // Our users can initialize AppCheck after Firestore, so we give it
    // a chance to register itself with the component framework.
    setTimeout(() => {
      if (!this.appCheck) {
        const s = this.A.getImmediate({
          optional: !0
        });
        s ? r(s) : (
          // If AppCheck is still not available, proceed without it.
          q("FirebaseAppCheckTokenProvider", "AppCheck not yet detected")
        );
      }
    }, 0);
  }
  getToken() {
    const t = this.forceRefresh;
    return this.forceRefresh = !1, this.appCheck ? this.appCheck.getToken(t).then((e) => e ? (Bt(typeof e.token == "string"), this.R = e.token, new AT(e.token)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = !0;
  }
  shutdown() {
    this.appCheck && this.o && this.appCheck.removeTokenListener(this.o), this.o = void 0;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function TT(i) {
  const t = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    typeof self < "u" && (self.crypto || self.msCrypto)
  ), e = new Uint8Array(i);
  if (t && typeof t.getRandomValues == "function") t.getRandomValues(e);
  else
    for (let n = 0; n < i; n++) e[n] = Math.floor(256 * Math.random());
  return e;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class vy {
  static newId() {
    const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", e = Math.floor(256 / t.length) * t.length;
    let n = "";
    for (; n.length < 20; ) {
      const r = TT(40);
      for (let s = 0; s < r.length; ++s)
        n.length < 20 && r[s] < e && (n += t.charAt(r[s] % t.length));
    }
    return n;
  }
}
function ft(i, t) {
  return i < t ? -1 : i > t ? 1 : 0;
}
function Tr(i, t, e) {
  return i.length === t.length && i.every((n, r) => e(n, t[r]));
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class te {
  /**
   * Creates a new timestamp with the current date, with millisecond precision.
   *
   * @returns a new timestamp representing the current date.
   */
  static now() {
    return te.fromMillis(Date.now());
  }
  /**
   * Creates a new timestamp from the given date.
   *
   * @param date - The date to initialize the `Timestamp` from.
   * @returns A new `Timestamp` representing the same point in time as the given
   *     date.
   */
  static fromDate(t) {
    return te.fromMillis(t.getTime());
  }
  /**
   * Creates a new timestamp from the given number of milliseconds.
   *
   * @param milliseconds - Number of milliseconds since Unix epoch
   *     1970-01-01T00:00:00Z.
   * @returns A new `Timestamp` representing the same point in time as the given
   *     number of milliseconds.
   */
  static fromMillis(t) {
    const e = Math.floor(t / 1e3), n = Math.floor(1e6 * (t - 1e3 * e));
    return new te(e, n);
  }
  /**
   * Creates a new timestamp.
   *
   * @param seconds - The number of seconds of UTC time since Unix epoch
   *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
   *     9999-12-31T23:59:59Z inclusive.
   * @param nanoseconds - The non-negative fractions of a second at nanosecond
   *     resolution. Negative second values with fractions must still have
   *     non-negative nanoseconds values that count forward in time. Must be
   *     from 0 to 999,999,999 inclusive.
   */
  constructor(t, e) {
    if (this.seconds = t, this.nanoseconds = e, e < 0) throw new Z(z.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (e >= 1e9) throw new Z(z.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (t < -62135596800) throw new Z(z.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t);
    if (t >= 253402300800) throw new Z(z.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t);
  }
  /**
   * Converts a `Timestamp` to a JavaScript `Date` object. This conversion
   * causes a loss of precision since `Date` objects only support millisecond
   * precision.
   *
   * @returns JavaScript `Date` object representing the same point in time as
   *     this `Timestamp`, with millisecond precision.
   */
  toDate() {
    return new Date(this.toMillis());
  }
  /**
   * Converts a `Timestamp` to a numeric timestamp (in milliseconds since
   * epoch). This operation causes a loss of precision.
   *
   * @returns The point in time corresponding to this timestamp, represented as
   *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.
   */
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(t) {
    return this.seconds === t.seconds ? ft(this.nanoseconds, t.nanoseconds) : ft(this.seconds, t.seconds);
  }
  /**
   * Returns true if this `Timestamp` is equal to the provided one.
   *
   * @param other - The `Timestamp` to compare against.
   * @returns true if this `Timestamp` is equal to the provided one.
   */
  isEqual(t) {
    return t.seconds === this.seconds && t.nanoseconds === this.nanoseconds;
  }
  /** Returns a textual representation of this `Timestamp`. */
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  /** Returns a JSON-serializable representation of this `Timestamp`. */
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  /**
   * Converts this object to a primitive string, which allows `Timestamp` objects
   * to be compared using the `>`, `<=`, `>=` and `>` operators.
   */
  valueOf() {
    const t = this.seconds - -62135596800;
    return String(t).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class wt {
  static fromTimestamp(t) {
    return new wt(t);
  }
  static min() {
    return new wt(new te(0, 0));
  }
  static max() {
    return new wt(new te(253402300799, 999999999));
  }
  constructor(t) {
    this.timestamp = t;
  }
  compareTo(t) {
    return this.timestamp._compareTo(t.timestamp);
  }
  isEqual(t) {
    return this.timestamp.isEqual(t.timestamp);
  }
  /** Returns a number representation of the version for use in spec tests. */
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ws {
  constructor(t, e, n) {
    e === void 0 ? e = 0 : e > t.length && rt(), n === void 0 ? n = t.length - e : n > t.length - e && rt(), this.segments = t, this.offset = e, this.len = n;
  }
  get length() {
    return this.len;
  }
  isEqual(t) {
    return Ws.comparator(this, t) === 0;
  }
  child(t) {
    const e = this.segments.slice(this.offset, this.limit());
    return t instanceof Ws ? t.forEach((n) => {
      e.push(n);
    }) : e.push(t), this.construct(e);
  }
  /** The index of one past the last segment of the path. */
  limit() {
    return this.offset + this.length;
  }
  popFirst(t) {
    return t = t === void 0 ? 1 : t, this.construct(this.segments, this.offset + t, this.length - t);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(t) {
    return this.segments[this.offset + t];
  }
  isEmpty() {
    return this.length === 0;
  }
  isPrefixOf(t) {
    if (t.length < this.length) return !1;
    for (let e = 0; e < this.length; e++) if (this.get(e) !== t.get(e)) return !1;
    return !0;
  }
  isImmediateParentOf(t) {
    if (this.length + 1 !== t.length) return !1;
    for (let e = 0; e < this.length; e++) if (this.get(e) !== t.get(e)) return !1;
    return !0;
  }
  forEach(t) {
    for (let e = this.offset, n = this.limit(); e < n; e++) t(this.segments[e]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(t, e) {
    const n = Math.min(t.length, e.length);
    for (let r = 0; r < n; r++) {
      const s = t.get(r), o = e.get(r);
      if (s < o) return -1;
      if (s > o) return 1;
    }
    return t.length < e.length ? -1 : t.length > e.length ? 1 : 0;
  }
}
class zt extends Ws {
  construct(t, e, n) {
    return new zt(t, e, n);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  /**
   * Returns a string representation of this path
   * where each path segment has been encoded with
   * `encodeURIComponent`.
   */
  toUriEncodedString() {
    return this.toArray().map(encodeURIComponent).join("/");
  }
  /**
   * Creates a resource path from the given slash-delimited string. If multiple
   * arguments are provided, all components are combined. Leading and trailing
   * slashes from all components are ignored.
   */
  static fromString(...t) {
    const e = [];
    for (const n of t) {
      if (n.indexOf("//") >= 0) throw new Z(z.INVALID_ARGUMENT, `Invalid segment (${n}). Paths must not contain // in them.`);
      e.push(...n.split("/").filter((r) => r.length > 0));
    }
    return new zt(e);
  }
  static emptyPath() {
    return new zt([]);
  }
}
const ET = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
class oe extends Ws {
  construct(t, e, n) {
    return new oe(t, e, n);
  }
  /**
   * Returns true if the string could be used as a segment in a field path
   * without escaping.
   */
  static isValidIdentifier(t) {
    return ET.test(t);
  }
  canonicalString() {
    return this.toArray().map((t) => (t = t.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), oe.isValidIdentifier(t) || (t = "`" + t + "`"), t)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  /**
   * Returns true if this field references the key of a document.
   */
  isKeyField() {
    return this.length === 1 && this.get(0) === "__name__";
  }
  /**
   * The field designating the key of a document.
   */
  static keyField() {
    return new oe(["__name__"]);
  }
  /**
   * Parses a field string from the given server-formatted string.
   *
   * - Splitting the empty string is not allowed (for now at least).
   * - Empty segments within the string (e.g. if there are two consecutive
   *   separators) are not allowed.
   *
   * TODO(b/37244157): we should make this more strict. Right now, it allows
   * non-identifier path components, even if they aren't escaped.
   */
  static fromServerFormat(t) {
    const e = [];
    let n = "", r = 0;
    const s = () => {
      if (n.length === 0) throw new Z(z.INVALID_ARGUMENT, `Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      e.push(n), n = "";
    };
    let o = !1;
    for (; r < t.length; ) {
      const a = t[r];
      if (a === "\\") {
        if (r + 1 === t.length) throw new Z(z.INVALID_ARGUMENT, "Path has trailing escape character: " + t);
        const l = t[r + 1];
        if (l !== "\\" && l !== "." && l !== "`") throw new Z(z.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t);
        n += l, r += 2;
      } else a === "`" ? (o = !o, r++) : a !== "." || o ? (n += a, r++) : (s(), r++);
    }
    if (s(), o) throw new Z(z.INVALID_ARGUMENT, "Unterminated ` in path: " + t);
    return new oe(e);
  }
  static emptyPath() {
    return new oe([]);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class et {
  constructor(t) {
    this.path = t;
  }
  static fromPath(t) {
    return new et(zt.fromString(t));
  }
  static fromName(t) {
    return new et(zt.fromString(t).popFirst(5));
  }
  static empty() {
    return new et(zt.emptyPath());
  }
  get collectionGroup() {
    return this.path.popLast().lastSegment();
  }
  /** Returns true if the document is in the specified collectionId. */
  hasCollectionId(t) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === t;
  }
  /** Returns the collection group (i.e. the name of the parent collection) for this key. */
  getCollectionGroup() {
    return this.path.get(this.path.length - 2);
  }
  /** Returns the fully qualified path to the parent collection. */
  getCollectionPath() {
    return this.path.popLast();
  }
  isEqual(t) {
    return t !== null && zt.comparator(this.path, t.path) === 0;
  }
  toString() {
    return this.path.toString();
  }
  static comparator(t, e) {
    return zt.comparator(t.path, e.path);
  }
  static isDocumentKey(t) {
    return t.length % 2 == 0;
  }
  /**
   * Creates and returns a new document key with the given segments.
   *
   * @param segments - The segments of the path to the document
   * @returns A new instance of DocumentKey
   */
  static fromSegments(t) {
    return new et(new zt(t.slice()));
  }
}
function CT(i, t) {
  const e = i.toTimestamp().seconds, n = i.toTimestamp().nanoseconds + 1, r = wt.fromTimestamp(n === 1e9 ? new te(e + 1, 0) : new te(e, n));
  return new tn(r, et.empty(), t);
}
function PT(i) {
  return new tn(i.readTime, i.key, -1);
}
class tn {
  constructor(t, e, n) {
    this.readTime = t, this.documentKey = e, this.largestBatchId = n;
  }
  /** Returns an offset that sorts before all regular offsets. */
  static min() {
    return new tn(wt.min(), et.empty(), -1);
  }
  /** Returns an offset that sorts after all regular offsets. */
  static max() {
    return new tn(wt.max(), et.empty(), -1);
  }
}
function IT(i, t) {
  let e = i.readTime.compareTo(t.readTime);
  return e !== 0 ? e : (e = et.comparator(i.documentKey, t.documentKey), e !== 0 ? e : ft(i.largestBatchId, t.largestBatchId));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const RT = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
class kT {
  constructor() {
    this.onCommittedListeners = [];
  }
  addOnCommittedListener(t) {
    this.onCommittedListeners.push(t);
  }
  raiseOnCommittedEvent() {
    this.onCommittedListeners.forEach((t) => t());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Kc(i) {
  if (i.code !== z.FAILED_PRECONDITION || i.message !== RT) throw i;
  q("LocalStore", "Unexpectedly lost primary lease");
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class L {
  constructor(t) {
    this.nextCallback = null, this.catchCallback = null, // When the operation resolves, we'll set result or error and mark isDone.
    this.result = void 0, this.error = void 0, this.isDone = !1, // Set to true when .then() or .catch() are called and prevents additional
    // chaining.
    this.callbackAttached = !1, t((e) => {
      this.isDone = !0, this.result = e, this.nextCallback && // value should be defined unless T is Void, but we can't express
      // that in the type system.
      this.nextCallback(e);
    }, (e) => {
      this.isDone = !0, this.error = e, this.catchCallback && this.catchCallback(e);
    });
  }
  catch(t) {
    return this.next(void 0, t);
  }
  next(t, e) {
    return this.callbackAttached && rt(), this.callbackAttached = !0, this.isDone ? this.error ? this.wrapFailure(e, this.error) : this.wrapSuccess(t, this.result) : new L((n, r) => {
      this.nextCallback = (s) => {
        this.wrapSuccess(t, s).next(n, r);
      }, this.catchCallback = (s) => {
        this.wrapFailure(e, s).next(n, r);
      };
    });
  }
  toPromise() {
    return new Promise((t, e) => {
      this.next(t, e);
    });
  }
  wrapUserFunction(t) {
    try {
      const e = t();
      return e instanceof L ? e : L.resolve(e);
    } catch (e) {
      return L.reject(e);
    }
  }
  wrapSuccess(t, e) {
    return t ? this.wrapUserFunction(() => t(e)) : L.resolve(e);
  }
  wrapFailure(t, e) {
    return t ? this.wrapUserFunction(() => t(e)) : L.reject(e);
  }
  static resolve(t) {
    return new L((e, n) => {
      e(t);
    });
  }
  static reject(t) {
    return new L((e, n) => {
      n(t);
    });
  }
  static waitFor(t) {
    return new L((e, n) => {
      let r = 0, s = 0, o = !1;
      t.forEach((a) => {
        ++r, a.next(() => {
          ++s, o && s === r && e();
        }, (l) => n(l));
      }), o = !0, s === r && e();
    });
  }
  /**
   * Given an array of predicate functions that asynchronously evaluate to a
   * boolean, implements a short-circuiting `or` between the results. Predicates
   * will be evaluated until one of them returns `true`, then stop. The final
   * result will be whether any of them returned `true`.
   */
  static or(t) {
    let e = L.resolve(!1);
    for (const n of t) e = e.next((r) => r ? L.resolve(r) : n());
    return e;
  }
  static forEach(t, e) {
    const n = [];
    return t.forEach((r, s) => {
      n.push(e.call(this, r, s));
    }), this.waitFor(n);
  }
  /**
   * Concurrently map all array elements through asynchronous function.
   */
  static mapArray(t, e) {
    return new L((n, r) => {
      const s = t.length, o = new Array(s);
      let a = 0;
      for (let l = 0; l < s; l++) {
        const h = l;
        e(t[h]).next((c) => {
          o[h] = c, ++a, a === s && n(o);
        }, (c) => r(c));
      }
    });
  }
  /**
   * An alternative to recursive PersistencePromise calls, that avoids
   * potential memory problems from unbounded chains of promises.
   *
   * The `action` will be called repeatedly while `condition` is true.
   */
  static doWhile(t, e) {
    return new L((n, r) => {
      const s = () => {
        t() === !0 ? e().next(() => {
          s();
        }, r) : n();
      };
      s();
    });
  }
}
function MT(i) {
  const t = i.match(/Android ([\d.]+)/i), e = t ? t[1].split(".").slice(0, 2).join(".") : "-1";
  return Number(e);
}
function Zs(i) {
  return i.name === "IndexedDbTransactionError";
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Qc {
  constructor(t, e) {
    this.previousValue = t, e && (e.sequenceNumberHandler = (n) => this.ie(n), this.se = (n) => e.writeSequenceNumber(n));
  }
  ie(t) {
    return this.previousValue = Math.max(t, this.previousValue), this.previousValue;
  }
  next() {
    const t = ++this.previousValue;
    return this.se && this.se(t), t;
  }
}
Qc.oe = -1;
function Jc(i) {
  return i == null;
}
function ma(i) {
  return i === 0 && 1 / i == -1 / 0;
}
function OT(i) {
  return typeof i == "number" && Number.isInteger(i) && !ma(i) && i <= Number.MAX_SAFE_INTEGER && i >= Number.MIN_SAFE_INTEGER;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function DT(i) {
  let t = "";
  for (let e = 0; e < i.length; e++) t.length > 0 && (t = zp(t)), t = BT(i.get(e), t);
  return zp(t);
}
function BT(i, t) {
  let e = t;
  const n = i.length;
  for (let r = 0; r < n; r++) {
    const s = i.charAt(r);
    switch (s) {
      case "\0":
        e += "";
        break;
      case "":
        e += "";
        break;
      default:
        e += s;
    }
  }
  return e;
}
function zp(i) {
  return i + "";
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function jp(i) {
  let t = 0;
  for (const e in i) Object.prototype.hasOwnProperty.call(i, e) && t++;
  return t;
}
function Lr(i, t) {
  for (const e in i) Object.prototype.hasOwnProperty.call(i, e) && t(e, i[e]);
}
function _y(i) {
  for (const t in i) if (Object.prototype.hasOwnProperty.call(i, t)) return !1;
  return !0;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ve {
  constructor(t, e) {
    this.comparator = t, this.root = e || re.EMPTY;
  }
  // Returns a copy of the map, with the specified key/value added or replaced.
  insert(t, e) {
    return new Ve(this.comparator, this.root.insert(t, e, this.comparator).copy(null, null, re.BLACK, null, null));
  }
  // Returns a copy of the map, with the specified key removed.
  remove(t) {
    return new Ve(this.comparator, this.root.remove(t, this.comparator).copy(null, null, re.BLACK, null, null));
  }
  // Returns the value of the node with the given key, or null.
  get(t) {
    let e = this.root;
    for (; !e.isEmpty(); ) {
      const n = this.comparator(t, e.key);
      if (n === 0) return e.value;
      n < 0 ? e = e.left : n > 0 && (e = e.right);
    }
    return null;
  }
  // Returns the index of the element in this sorted map, or -1 if it doesn't
  // exist.
  indexOf(t) {
    let e = 0, n = this.root;
    for (; !n.isEmpty(); ) {
      const r = this.comparator(t, n.key);
      if (r === 0) return e + n.left.size;
      r < 0 ? n = n.left : (
        // Count all nodes left of the node plus the node itself
        (e += n.left.size + 1, n = n.right)
      );
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  // Returns the total number of nodes in the map.
  get size() {
    return this.root.size;
  }
  // Returns the minimum key in the map.
  minKey() {
    return this.root.minKey();
  }
  // Returns the maximum key in the map.
  maxKey() {
    return this.root.maxKey();
  }
  // Traverses the map in key order and calls the specified action function
  // for each key/value pair. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  inorderTraversal(t) {
    return this.root.inorderTraversal(t);
  }
  forEach(t) {
    this.inorderTraversal((e, n) => (t(e, n), !1));
  }
  toString() {
    const t = [];
    return this.inorderTraversal((e, n) => (t.push(`${e}:${n}`), !1)), `{${t.join(", ")}}`;
  }
  // Traverses the map in reverse key order and calls the specified action
  // function for each key/value pair. If action returns true, traversal is
  // aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  reverseTraversal(t) {
    return this.root.reverseTraversal(t);
  }
  // Returns an iterator over the SortedMap.
  getIterator() {
    return new Mo(this.root, null, this.comparator, !1);
  }
  getIteratorFrom(t) {
    return new Mo(this.root, t, this.comparator, !1);
  }
  getReverseIterator() {
    return new Mo(this.root, null, this.comparator, !0);
  }
  getReverseIteratorFrom(t) {
    return new Mo(this.root, t, this.comparator, !0);
  }
}
class Mo {
  constructor(t, e, n, r) {
    this.isReverse = r, this.nodeStack = [];
    let s = 1;
    for (; !t.isEmpty(); ) if (s = e ? n(t.key, e) : 1, // flip the comparison if we're going in reverse
    e && r && (s *= -1), s < 0)
      t = this.isReverse ? t.left : t.right;
    else {
      if (s === 0) {
        this.nodeStack.push(t);
        break;
      }
      this.nodeStack.push(t), t = this.isReverse ? t.right : t.left;
    }
  }
  getNext() {
    let t = this.nodeStack.pop();
    const e = {
      key: t.key,
      value: t.value
    };
    if (this.isReverse) for (t = t.left; !t.isEmpty(); ) this.nodeStack.push(t), t = t.right;
    else for (t = t.right; !t.isEmpty(); ) this.nodeStack.push(t), t = t.left;
    return e;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (this.nodeStack.length === 0) return null;
    const t = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: t.key,
      value: t.value
    };
  }
}
class re {
  constructor(t, e, n, r, s) {
    this.key = t, this.value = e, this.color = n ?? re.RED, this.left = r ?? re.EMPTY, this.right = s ?? re.EMPTY, this.size = this.left.size + 1 + this.right.size;
  }
  // Returns a copy of the current node, optionally replacing pieces of it.
  copy(t, e, n, r, s) {
    return new re(t ?? this.key, e ?? this.value, n ?? this.color, r ?? this.left, s ?? this.right);
  }
  isEmpty() {
    return !1;
  }
  // Traverses the tree in key order and calls the specified action function
  // for each node. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  inorderTraversal(t) {
    return this.left.inorderTraversal(t) || t(this.key, this.value) || this.right.inorderTraversal(t);
  }
  // Traverses the tree in reverse key order and calls the specified action
  // function for each node. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  reverseTraversal(t) {
    return this.right.reverseTraversal(t) || t(this.key, this.value) || this.left.reverseTraversal(t);
  }
  // Returns the minimum node in the tree.
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  // Returns the maximum key in the tree.
  minKey() {
    return this.min().key;
  }
  // Returns the maximum key in the tree.
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  // Returns new tree, with the key/value added.
  insert(t, e, n) {
    let r = this;
    const s = n(t, r.key);
    return r = s < 0 ? r.copy(null, null, null, r.left.insert(t, e, n), null) : s === 0 ? r.copy(null, e, null, null, null) : r.copy(null, null, null, null, r.right.insert(t, e, n)), r.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty()) return re.EMPTY;
    let t = this;
    return t.left.isRed() || t.left.left.isRed() || (t = t.moveRedLeft()), t = t.copy(null, null, null, t.left.removeMin(), null), t.fixUp();
  }
  // Returns new tree, with the specified item removed.
  remove(t, e) {
    let n, r = this;
    if (e(t, r.key) < 0) r.left.isEmpty() || r.left.isRed() || r.left.left.isRed() || (r = r.moveRedLeft()), r = r.copy(null, null, null, r.left.remove(t, e), null);
    else {
      if (r.left.isRed() && (r = r.rotateRight()), r.right.isEmpty() || r.right.isRed() || r.right.left.isRed() || (r = r.moveRedRight()), e(t, r.key) === 0) {
        if (r.right.isEmpty()) return re.EMPTY;
        n = r.right.min(), r = r.copy(n.key, n.value, null, null, r.right.removeMin());
      }
      r = r.copy(null, null, null, null, r.right.remove(t, e));
    }
    return r.fixUp();
  }
  isRed() {
    return this.color;
  }
  // Returns new tree after performing any needed rotations.
  fixUp() {
    let t = this;
    return t.right.isRed() && !t.left.isRed() && (t = t.rotateLeft()), t.left.isRed() && t.left.left.isRed() && (t = t.rotateRight()), t.left.isRed() && t.right.isRed() && (t = t.colorFlip()), t;
  }
  moveRedLeft() {
    let t = this.colorFlip();
    return t.right.left.isRed() && (t = t.copy(null, null, null, null, t.right.rotateRight()), t = t.rotateLeft(), t = t.colorFlip()), t;
  }
  moveRedRight() {
    let t = this.colorFlip();
    return t.left.left.isRed() && (t = t.rotateRight(), t = t.colorFlip()), t;
  }
  rotateLeft() {
    const t = this.copy(null, null, re.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, t, null);
  }
  rotateRight() {
    const t = this.copy(null, null, re.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, t);
  }
  colorFlip() {
    const t = this.left.copy(null, null, !this.left.color, null, null), e = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, t, e);
  }
  // For testing.
  checkMaxDepth() {
    const t = this.check();
    return Math.pow(2, t) <= this.size + 1;
  }
  // In a balanced RB tree, the black-depth (number of black nodes) from root to
  // leaves is equal on both sides.  This function verifies that or asserts.
  check() {
    if (this.isRed() && this.left.isRed() || this.right.isRed()) throw rt();
    const t = this.left.check();
    if (t !== this.right.check()) throw rt();
    return t + (this.isRed() ? 0 : 1);
  }
}
re.EMPTY = null, re.RED = !0, re.BLACK = !1;
re.EMPTY = new // Represents an empty node (a leaf node in the Red-Black Tree).
class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw rt();
  }
  get value() {
    throw rt();
  }
  get color() {
    throw rt();
  }
  get left() {
    throw rt();
  }
  get right() {
    throw rt();
  }
  // Returns a copy of the current node.
  copy(t, e, n, r, s) {
    return this;
  }
  // Returns a copy of the tree, with the specified key/value added.
  insert(t, e, n) {
    return new re(t, e);
  }
  // Returns a copy of the tree, with the specified key removed.
  remove(t, e) {
    return this;
  }
  isEmpty() {
    return !0;
  }
  inorderTraversal(t) {
    return !1;
  }
  reverseTraversal(t) {
    return !1;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return !1;
  }
  // For testing.
  checkMaxDepth() {
    return !0;
  }
  check() {
    return 0;
  }
}();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class le {
  constructor(t) {
    this.comparator = t, this.data = new Ve(this.comparator);
  }
  has(t) {
    return this.data.get(t) !== null;
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(t) {
    return this.data.indexOf(t);
  }
  /** Iterates elements in order defined by "comparator" */
  forEach(t) {
    this.data.inorderTraversal((e, n) => (t(e), !1));
  }
  /** Iterates over `elem`s such that: range[0] &lt;= elem &lt; range[1]. */
  forEachInRange(t, e) {
    const n = this.data.getIteratorFrom(t[0]);
    for (; n.hasNext(); ) {
      const r = n.getNext();
      if (this.comparator(r.key, t[1]) >= 0) return;
      e(r.key);
    }
  }
  /**
   * Iterates over `elem`s such that: start &lt;= elem until false is returned.
   */
  forEachWhile(t, e) {
    let n;
    for (n = e !== void 0 ? this.data.getIteratorFrom(e) : this.data.getIterator(); n.hasNext(); )
      if (!t(n.getNext().key)) return;
  }
  /** Finds the least element greater than or equal to `elem`. */
  firstAfterOrEqual(t) {
    const e = this.data.getIteratorFrom(t);
    return e.hasNext() ? e.getNext().key : null;
  }
  getIterator() {
    return new Gp(this.data.getIterator());
  }
  getIteratorFrom(t) {
    return new Gp(this.data.getIteratorFrom(t));
  }
  /** Inserts or updates an element */
  add(t) {
    return this.copy(this.data.remove(t).insert(t, !0));
  }
  /** Deletes an element */
  delete(t) {
    return this.has(t) ? this.copy(this.data.remove(t)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(t) {
    let e = this;
    return e.size < t.size && (e = t, t = this), t.forEach((n) => {
      e = e.add(n);
    }), e;
  }
  isEqual(t) {
    if (!(t instanceof le) || this.size !== t.size) return !1;
    const e = this.data.getIterator(), n = t.data.getIterator();
    for (; e.hasNext(); ) {
      const r = e.getNext().key, s = n.getNext().key;
      if (this.comparator(r, s) !== 0) return !1;
    }
    return !0;
  }
  toArray() {
    const t = [];
    return this.forEach((e) => {
      t.push(e);
    }), t;
  }
  toString() {
    const t = [];
    return this.forEach((e) => t.push(e)), "SortedSet(" + t.toString() + ")";
  }
  copy(t) {
    const e = new le(this.comparator);
    return e.data = t, e;
  }
}
class Gp {
  constructor(t) {
    this.iter = t;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class li {
  constructor(t) {
    this.fields = t, // TODO(dimond): validation of FieldMask
    // Sort the field mask to support `FieldMask.isEqual()` and assert below.
    t.sort(oe.comparator);
  }
  static empty() {
    return new li([]);
  }
  /**
   * Returns a new FieldMask object that is the result of adding all the given
   * fields paths to this field mask.
   */
  unionWith(t) {
    let e = new le(oe.comparator);
    for (const n of this.fields) e = e.add(n);
    for (const n of t) e = e.add(n);
    return new li(e.toArray());
  }
  /**
   * Verifies that `fieldPath` is included by at least one field in this field
   * mask.
   *
   * This is an O(n) operation, where `n` is the size of the field mask.
   */
  covers(t) {
    for (const e of this.fields) if (e.isPrefixOf(t)) return !0;
    return !1;
  }
  isEqual(t) {
    return Tr(this.fields, t.fields, (e, n) => e.isEqual(n));
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class VT extends Error {
  constructor() {
    super(...arguments), this.name = "Base64DecodeError";
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class _i {
  constructor(t) {
    this.binaryString = t;
  }
  static fromBase64String(t) {
    const e = function(r) {
      try {
        return atob(r);
      } catch (s) {
        throw typeof DOMException < "u" && s instanceof DOMException ? new VT("Invalid base64 string: " + s) : s;
      }
    }(t);
    return new _i(e);
  }
  static fromUint8Array(t) {
    const e = (
      /**
      * Helper function to convert an Uint8array to a binary string.
      */
      function(r) {
        let s = "";
        for (let o = 0; o < r.length; ++o) s += String.fromCharCode(r[o]);
        return s;
      }(t)
    );
    return new _i(e);
  }
  [Symbol.iterator]() {
    let t = 0;
    return {
      next: () => t < this.binaryString.length ? {
        value: this.binaryString.charCodeAt(t++),
        done: !1
      } : {
        value: void 0,
        done: !0
      }
    };
  }
  toBase64() {
    return function(e) {
      return btoa(e);
    }(this.binaryString);
  }
  toUint8Array() {
    return function(e) {
      const n = new Uint8Array(e.length);
      for (let r = 0; r < e.length; r++) n[r] = e.charCodeAt(r);
      return n;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(t) {
    return ft(this.binaryString, t.binaryString);
  }
  isEqual(t) {
    return this.binaryString === t.binaryString;
  }
}
_i.EMPTY_BYTE_STRING = new _i("");
const FT = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function Nn(i) {
  if (Bt(!!i), typeof i == "string") {
    let t = 0;
    const e = FT.exec(i);
    if (Bt(!!e), e[1]) {
      let r = e[1];
      r = (r + "000000000").substr(0, 9), t = Number(r);
    }
    const n = new Date(i);
    return {
      seconds: Math.floor(n.getTime() / 1e3),
      nanos: t
    };
  }
  return {
    seconds: se(i.seconds),
    nanos: se(i.nanos)
  };
}
function se(i) {
  return typeof i == "number" ? i : typeof i == "string" ? Number(i) : 0;
}
function Er(i) {
  return typeof i == "string" ? _i.fromBase64String(i) : _i.fromUint8Array(i);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Zc(i) {
  var t, e;
  return ((e = (((t = i == null ? void 0 : i.mapValue) === null || t === void 0 ? void 0 : t.fields) || {}).__type__) === null || e === void 0 ? void 0 : e.stringValue) === "server_timestamp";
}
function $c(i) {
  const t = i.mapValue.fields.__previous_value__;
  return Zc(t) ? $c(t) : t;
}
function ga(i) {
  const t = Nn(i.mapValue.fields.__local_write_time__.timestampValue);
  return new te(t.seconds, t.nanos);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LT {
  /**
   * Constructs a DatabaseInfo using the provided host, databaseId and
   * persistenceKey.
   *
   * @param databaseId - The database to use.
   * @param appId - The Firebase App Id.
   * @param persistenceKey - A unique identifier for this Firestore's local
   * storage (used in conjunction with the databaseId).
   * @param host - The Firestore backend host to connect to.
   * @param ssl - Whether to use SSL when connecting.
   * @param forceLongPolling - Whether to use the forceLongPolling option
   * when using WebChannel as the network transport.
   * @param autoDetectLongPolling - Whether to use the detectBufferingProxy
   * option when using WebChannel as the network transport.
   * @param longPollingOptions Options that configure long-polling.
   * @param useFetchStreams Whether to use the Fetch API instead of
   * XMLHTTPRequest
   */
  constructor(t, e, n, r, s, o, a, l, h) {
    this.databaseId = t, this.appId = e, this.persistenceKey = n, this.host = r, this.ssl = s, this.forceLongPolling = o, this.autoDetectLongPolling = a, this.longPollingOptions = l, this.useFetchStreams = h;
  }
}
class ya {
  constructor(t, e) {
    this.projectId = t, this.database = e || "(default)";
  }
  static empty() {
    return new ya("", "");
  }
  get isDefaultDatabase() {
    return this.database === "(default)";
  }
  isEqual(t) {
    return t instanceof ya && t.projectId === this.projectId && t.database === this.database;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Oo = {
  mapValue: {
    fields: {
      __type__: {
        stringValue: "__max__"
      }
    }
  }
};
function Un(i) {
  return "nullValue" in i ? 0 : "booleanValue" in i ? 1 : "integerValue" in i || "doubleValue" in i ? 2 : "timestampValue" in i ? 3 : "stringValue" in i ? 5 : "bytesValue" in i ? 6 : "referenceValue" in i ? 7 : "geoPointValue" in i ? 8 : "arrayValue" in i ? 9 : "mapValue" in i ? Zc(i) ? 4 : UT(i) ? 9007199254740991 : NT(i) ? 10 : 11 : rt();
}
function xi(i, t) {
  if (i === t) return !0;
  const e = Un(i);
  if (e !== Un(t)) return !1;
  switch (e) {
    case 0:
    case 9007199254740991:
      return !0;
    case 1:
      return i.booleanValue === t.booleanValue;
    case 4:
      return ga(i).isEqual(ga(t));
    case 3:
      return function(r, s) {
        if (typeof r.timestampValue == "string" && typeof s.timestampValue == "string" && r.timestampValue.length === s.timestampValue.length)
          return r.timestampValue === s.timestampValue;
        const o = Nn(r.timestampValue), a = Nn(s.timestampValue);
        return o.seconds === a.seconds && o.nanos === a.nanos;
      }(i, t);
    case 5:
      return i.stringValue === t.stringValue;
    case 6:
      return function(r, s) {
        return Er(r.bytesValue).isEqual(Er(s.bytesValue));
      }(i, t);
    case 7:
      return i.referenceValue === t.referenceValue;
    case 8:
      return function(r, s) {
        return se(r.geoPointValue.latitude) === se(s.geoPointValue.latitude) && se(r.geoPointValue.longitude) === se(s.geoPointValue.longitude);
      }(i, t);
    case 2:
      return function(r, s) {
        if ("integerValue" in r && "integerValue" in s) return se(r.integerValue) === se(s.integerValue);
        if ("doubleValue" in r && "doubleValue" in s) {
          const o = se(r.doubleValue), a = se(s.doubleValue);
          return o === a ? ma(o) === ma(a) : isNaN(o) && isNaN(a);
        }
        return !1;
      }(i, t);
    case 9:
      return Tr(i.arrayValue.values || [], t.arrayValue.values || [], xi);
    case 10:
    case 11:
      return function(r, s) {
        const o = r.mapValue.fields || {}, a = s.mapValue.fields || {};
        if (jp(o) !== jp(a)) return !1;
        for (const l in o) if (o.hasOwnProperty(l) && (a[l] === void 0 || !xi(o[l], a[l]))) return !1;
        return !0;
      }(i, t);
    default:
      return rt();
  }
}
function qs(i, t) {
  return (i.values || []).find((e) => xi(e, t)) !== void 0;
}
function Cr(i, t) {
  if (i === t) return 0;
  const e = Un(i), n = Un(t);
  if (e !== n) return ft(e, n);
  switch (e) {
    case 0:
    case 9007199254740991:
      return 0;
    case 1:
      return ft(i.booleanValue, t.booleanValue);
    case 2:
      return function(s, o) {
        const a = se(s.integerValue || s.doubleValue), l = se(o.integerValue || o.doubleValue);
        return a < l ? -1 : a > l ? 1 : a === l ? 0 : (
          // one or both are NaN.
          isNaN(a) ? isNaN(l) ? 0 : -1 : 1
        );
      }(i, t);
    case 3:
      return Hp(i.timestampValue, t.timestampValue);
    case 4:
      return Hp(ga(i), ga(t));
    case 5:
      return ft(i.stringValue, t.stringValue);
    case 6:
      return function(s, o) {
        const a = Er(s), l = Er(o);
        return a.compareTo(l);
      }(i.bytesValue, t.bytesValue);
    case 7:
      return function(s, o) {
        const a = s.split("/"), l = o.split("/");
        for (let h = 0; h < a.length && h < l.length; h++) {
          const c = ft(a[h], l[h]);
          if (c !== 0) return c;
        }
        return ft(a.length, l.length);
      }(i.referenceValue, t.referenceValue);
    case 8:
      return function(s, o) {
        const a = ft(se(s.latitude), se(o.latitude));
        return a !== 0 ? a : ft(se(s.longitude), se(o.longitude));
      }(i.geoPointValue, t.geoPointValue);
    case 9:
      return Wp(i.arrayValue, t.arrayValue);
    case 10:
      return function(s, o) {
        var a, l, h, c;
        const p = s.fields || {}, f = o.fields || {}, d = (a = p.value) === null || a === void 0 ? void 0 : a.arrayValue, m = (l = f.value) === null || l === void 0 ? void 0 : l.arrayValue, g = ft(((h = d == null ? void 0 : d.values) === null || h === void 0 ? void 0 : h.length) || 0, ((c = m == null ? void 0 : m.values) === null || c === void 0 ? void 0 : c.length) || 0);
        return g !== 0 ? g : Wp(d, m);
      }(i.mapValue, t.mapValue);
    case 11:
      return function(s, o) {
        if (s === Oo.mapValue && o === Oo.mapValue) return 0;
        if (s === Oo.mapValue) return 1;
        if (o === Oo.mapValue) return -1;
        const a = s.fields || {}, l = Object.keys(a), h = o.fields || {}, c = Object.keys(h);
        l.sort(), c.sort();
        for (let p = 0; p < l.length && p < c.length; ++p) {
          const f = ft(l[p], c[p]);
          if (f !== 0) return f;
          const d = Cr(a[l[p]], h[c[p]]);
          if (d !== 0) return d;
        }
        return ft(l.length, c.length);
      }(i.mapValue, t.mapValue);
    default:
      throw rt();
  }
}
function Hp(i, t) {
  if (typeof i == "string" && typeof t == "string" && i.length === t.length) return ft(i, t);
  const e = Nn(i), n = Nn(t), r = ft(e.seconds, n.seconds);
  return r !== 0 ? r : ft(e.nanos, n.nanos);
}
function Wp(i, t) {
  const e = i.values || [], n = t.values || [];
  for (let r = 0; r < e.length && r < n.length; ++r) {
    const s = Cr(e[r], n[r]);
    if (s) return s;
  }
  return ft(e.length, n.length);
}
function Pr(i) {
  return tc(i);
}
function tc(i) {
  return "nullValue" in i ? "null" : "booleanValue" in i ? "" + i.booleanValue : "integerValue" in i ? "" + i.integerValue : "doubleValue" in i ? "" + i.doubleValue : "timestampValue" in i ? function(e) {
    const n = Nn(e);
    return `time(${n.seconds},${n.nanos})`;
  }(i.timestampValue) : "stringValue" in i ? i.stringValue : "bytesValue" in i ? function(e) {
    return Er(e).toBase64();
  }(i.bytesValue) : "referenceValue" in i ? function(e) {
    return et.fromName(e).toString();
  }(i.referenceValue) : "geoPointValue" in i ? function(e) {
    return `geo(${e.latitude},${e.longitude})`;
  }(i.geoPointValue) : "arrayValue" in i ? function(e) {
    let n = "[", r = !0;
    for (const s of e.values || []) r ? r = !1 : n += ",", n += tc(s);
    return n + "]";
  }(i.arrayValue) : "mapValue" in i ? function(e) {
    const n = Object.keys(e.fields || {}).sort();
    let r = "{", s = !0;
    for (const o of n) s ? s = !1 : r += ",", r += `${o}:${tc(e.fields[o])}`;
    return r + "}";
  }(i.mapValue) : rt();
}
function Wo(i) {
  switch (Un(i)) {
    case 0:
    case 1:
      return 4;
    case 2:
      return 8;
    case 3:
    case 8:
      return 16;
    case 4:
      const t = $c(i);
      return t ? 16 + Wo(t) : 16;
    case 5:
      return 2 * i.stringValue.length;
    case 6:
      return Er(i.bytesValue).approximateByteSize();
    case 7:
      return i.referenceValue.length;
    case 9:
      return function(n) {
        return (n.values || []).reduce((r, s) => r + Wo(s), 0);
      }(i.arrayValue);
    case 10:
    case 11:
      return function(n) {
        let r = 0;
        return Lr(n.fields, (s, o) => {
          r += s.length + Wo(o);
        }), r;
      }(i.mapValue);
    default:
      throw rt();
  }
}
function ec(i) {
  return !!i && "integerValue" in i;
}
function tu(i) {
  return !!i && "arrayValue" in i;
}
function qo(i) {
  return !!i && "mapValue" in i;
}
function NT(i) {
  var t, e;
  return ((e = (((t = i == null ? void 0 : i.mapValue) === null || t === void 0 ? void 0 : t.fields) || {}).__type__) === null || e === void 0 ? void 0 : e.stringValue) === "__vector__";
}
function As(i) {
  if (i.geoPointValue) return {
    geoPointValue: Object.assign({}, i.geoPointValue)
  };
  if (i.timestampValue && typeof i.timestampValue == "object") return {
    timestampValue: Object.assign({}, i.timestampValue)
  };
  if (i.mapValue) {
    const t = {
      mapValue: {
        fields: {}
      }
    };
    return Lr(i.mapValue.fields, (e, n) => t.mapValue.fields[e] = As(n)), t;
  }
  if (i.arrayValue) {
    const t = {
      arrayValue: {
        values: []
      }
    };
    for (let e = 0; e < (i.arrayValue.values || []).length; ++e) t.arrayValue.values[e] = As(i.arrayValue.values[e]);
    return t;
  }
  return Object.assign({}, i);
}
function UT(i) {
  return (((i.mapValue || {}).fields || {}).__type__ || {}).stringValue === "__max__";
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class oi {
  constructor(t) {
    this.value = t;
  }
  static empty() {
    return new oi({
      mapValue: {}
    });
  }
  /**
   * Returns the value at the given path or null.
   *
   * @param path - the path to search
   * @returns The value at the path or null if the path is not set.
   */
  field(t) {
    if (t.isEmpty()) return this.value;
    {
      let e = this.value;
      for (let n = 0; n < t.length - 1; ++n) if (e = (e.mapValue.fields || {})[t.get(n)], !qo(e)) return null;
      return e = (e.mapValue.fields || {})[t.lastSegment()], e || null;
    }
  }
  /**
   * Sets the field to the provided value.
   *
   * @param path - The field path to set.
   * @param value - The value to set.
   */
  set(t, e) {
    this.getFieldsMap(t.popLast())[t.lastSegment()] = As(e);
  }
  /**
   * Sets the provided fields to the provided values.
   *
   * @param data - A map of fields to values (or null for deletes).
   */
  setAll(t) {
    let e = oe.emptyPath(), n = {}, r = [];
    t.forEach((o, a) => {
      if (!e.isImmediateParentOf(a)) {
        const l = this.getFieldsMap(e);
        this.applyChanges(l, n, r), n = {}, r = [], e = a.popLast();
      }
      o ? n[a.lastSegment()] = As(o) : r.push(a.lastSegment());
    });
    const s = this.getFieldsMap(e);
    this.applyChanges(s, n, r);
  }
  /**
   * Removes the field at the specified path. If there is no field at the
   * specified path, nothing is changed.
   *
   * @param path - The field path to remove.
   */
  delete(t) {
    const e = this.field(t.popLast());
    qo(e) && e.mapValue.fields && delete e.mapValue.fields[t.lastSegment()];
  }
  isEqual(t) {
    return xi(this.value, t.value);
  }
  /**
   * Returns the map that contains the leaf element of `path`. If the parent
   * entry does not yet exist, or if it is not a map, a new map will be created.
   */
  getFieldsMap(t) {
    let e = this.value;
    e.mapValue.fields || (e.mapValue = {
      fields: {}
    });
    for (let n = 0; n < t.length; ++n) {
      let r = e.mapValue.fields[t.get(n)];
      qo(r) && r.mapValue.fields || (r = {
        mapValue: {
          fields: {}
        }
      }, e.mapValue.fields[t.get(n)] = r), e = r;
    }
    return e.mapValue.fields;
  }
  /**
   * Modifies `fieldsMap` by adding, replacing or deleting the specified
   * entries.
   */
  applyChanges(t, e, n) {
    Lr(e, (r, s) => t[r] = s);
    for (const r of n) delete t[r];
  }
  clone() {
    return new oi(As(this.value));
  }
}
function xy(i) {
  const t = [];
  return Lr(i.fields, (e, n) => {
    const r = new oe([e]);
    if (qo(n)) {
      const s = xy(n.mapValue).fields;
      if (s.length === 0)
        t.push(r);
      else
        for (const o of s) t.push(r.child(o));
    } else
      t.push(r);
  }), new li(t);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ri {
  constructor(t, e, n, r, s, o, a) {
    this.key = t, this.documentType = e, this.version = n, this.readTime = r, this.createTime = s, this.data = o, this.documentState = a;
  }
  /**
   * Creates a document with no known version or data, but which can serve as
   * base document for mutations.
   */
  static newInvalidDocument(t) {
    return new ri(
      t,
      0,
      /* version */
      wt.min(),
      /* readTime */
      wt.min(),
      /* createTime */
      wt.min(),
      oi.empty(),
      0
      /* DocumentState.SYNCED */
    );
  }
  /**
   * Creates a new document that is known to exist with the given data at the
   * given version.
   */
  static newFoundDocument(t, e, n, r) {
    return new ri(
      t,
      1,
      /* version */
      e,
      /* readTime */
      wt.min(),
      /* createTime */
      n,
      r,
      0
      /* DocumentState.SYNCED */
    );
  }
  /** Creates a new document that is known to not exist at the given version. */
  static newNoDocument(t, e) {
    return new ri(
      t,
      2,
      /* version */
      e,
      /* readTime */
      wt.min(),
      /* createTime */
      wt.min(),
      oi.empty(),
      0
      /* DocumentState.SYNCED */
    );
  }
  /**
   * Creates a new document that is known to exist at the given version but
   * whose data is not known (e.g. a document that was updated without a known
   * base document).
   */
  static newUnknownDocument(t, e) {
    return new ri(
      t,
      3,
      /* version */
      e,
      /* readTime */
      wt.min(),
      /* createTime */
      wt.min(),
      oi.empty(),
      2
      /* DocumentState.HAS_COMMITTED_MUTATIONS */
    );
  }
  /**
   * Changes the document type to indicate that it exists and that its version
   * and data are known.
   */
  convertToFoundDocument(t, e) {
    return !this.createTime.isEqual(wt.min()) || this.documentType !== 2 && this.documentType !== 0 || (this.createTime = t), this.version = t, this.documentType = 1, this.data = e, this.documentState = 0, this;
  }
  /**
   * Changes the document type to indicate that it doesn't exist at the given
   * version.
   */
  convertToNoDocument(t) {
    return this.version = t, this.documentType = 2, this.data = oi.empty(), this.documentState = 0, this;
  }
  /**
   * Changes the document type to indicate that it exists at a given version but
   * that its data is not known (e.g. a document that was updated without a known
   * base document).
   */
  convertToUnknownDocument(t) {
    return this.version = t, this.documentType = 3, this.data = oi.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this.version = wt.min(), this;
  }
  setReadTime(t) {
    return this.readTime = t, this;
  }
  get hasLocalMutations() {
    return this.documentState === 1;
  }
  get hasCommittedMutations() {
    return this.documentState === 2;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return this.documentType !== 0;
  }
  isFoundDocument() {
    return this.documentType === 1;
  }
  isNoDocument() {
    return this.documentType === 2;
  }
  isUnknownDocument() {
    return this.documentType === 3;
  }
  isEqual(t) {
    return t instanceof ri && this.key.isEqual(t.key) && this.version.isEqual(t.version) && this.documentType === t.documentType && this.documentState === t.documentState && this.data.isEqual(t.data);
  }
  mutableCopy() {
    return new ri(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class va {
  constructor(t, e) {
    this.position = t, this.inclusive = e;
  }
}
function qp(i, t, e) {
  let n = 0;
  for (let r = 0; r < i.position.length; r++) {
    const s = t[r], o = i.position[r];
    if (s.field.isKeyField() ? n = et.comparator(et.fromName(o.referenceValue), e.key) : n = Cr(o, e.data.field(s.field)), s.dir === "desc" && (n *= -1), n !== 0) break;
  }
  return n;
}
function Yp(i, t) {
  if (i === null) return t === null;
  if (t === null || i.inclusive !== t.inclusive || i.position.length !== t.position.length) return !1;
  for (let e = 0; e < i.position.length; e++)
    if (!xi(i.position[e], t.position[e])) return !1;
  return !0;
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class _a {
  constructor(t, e = "asc") {
    this.field = t, this.dir = e;
  }
}
function zT(i, t) {
  return i.dir === t.dir && i.field.isEqual(t.field);
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class by {
}
class $t extends by {
  constructor(t, e, n) {
    super(), this.field = t, this.op = e, this.value = n;
  }
  /**
   * Creates a filter based on the provided arguments.
   */
  static create(t, e, n) {
    return t.isKeyField() ? e === "in" || e === "not-in" ? this.createKeyFieldInFilter(t, e, n) : new GT(t, e, n) : e === "array-contains" ? new qT(t, n) : e === "in" ? new YT(t, n) : e === "not-in" ? new XT(t, n) : e === "array-contains-any" ? new KT(t, n) : new $t(t, e, n);
  }
  static createKeyFieldInFilter(t, e, n) {
    return e === "in" ? new HT(t, n) : new WT(t, n);
  }
  matches(t) {
    const e = t.data.field(this.field);
    return this.op === "!=" ? e !== null && this.matchesComparison(Cr(e, this.value)) : e !== null && Un(this.value) === Un(e) && this.matchesComparison(Cr(e, this.value));
  }
  matchesComparison(t) {
    switch (this.op) {
      case "<":
        return t < 0;
      case "<=":
        return t <= 0;
      case "==":
        return t === 0;
      case "!=":
        return t !== 0;
      case ">":
        return t > 0;
      case ">=":
        return t >= 0;
      default:
        return rt();
    }
  }
  isInequality() {
    return [
      "<",
      "<=",
      ">",
      ">=",
      "!=",
      "not-in"
      /* Operator.NOT_IN */
    ].indexOf(this.op) >= 0;
  }
  getFlattenedFilters() {
    return [this];
  }
  getFilters() {
    return [this];
  }
}
class en extends by {
  constructor(t, e) {
    super(), this.filters = t, this.op = e, this.ae = null;
  }
  /**
   * Creates a filter based on the provided arguments.
   */
  static create(t, e) {
    return new en(t, e);
  }
  matches(t) {
    return wy(this) ? this.filters.find((e) => !e.matches(t)) === void 0 : this.filters.find((e) => e.matches(t)) !== void 0;
  }
  getFlattenedFilters() {
    return this.ae !== null || (this.ae = this.filters.reduce((t, e) => t.concat(e.getFlattenedFilters()), [])), this.ae;
  }
  // Returns a mutable copy of `this.filters`
  getFilters() {
    return Object.assign([], this.filters);
  }
}
function wy(i) {
  return i.op === "and";
}
function Ay(i) {
  return jT(i) && wy(i);
}
function jT(i) {
  for (const t of i.filters) if (t instanceof en) return !1;
  return !0;
}
function ic(i) {
  if (i instanceof $t)
    return i.field.canonicalString() + i.op.toString() + Pr(i.value);
  if (Ay(i))
    return i.filters.map((t) => ic(t)).join(",");
  {
    const t = i.filters.map((e) => ic(e)).join(",");
    return `${i.op}(${t})`;
  }
}
function Sy(i, t) {
  return i instanceof $t ? function(n, r) {
    return r instanceof $t && n.op === r.op && n.field.isEqual(r.field) && xi(n.value, r.value);
  }(i, t) : i instanceof en ? function(n, r) {
    return r instanceof en && n.op === r.op && n.filters.length === r.filters.length ? n.filters.reduce((s, o, a) => s && Sy(o, r.filters[a]), !0) : !1;
  }(i, t) : void rt();
}
function Ty(i) {
  return i instanceof $t ? function(e) {
    return `${e.field.canonicalString()} ${e.op} ${Pr(e.value)}`;
  }(i) : i instanceof en ? function(e) {
    return e.op.toString() + " {" + e.getFilters().map(Ty).join(" ,") + "}";
  }(i) : "Filter";
}
class GT extends $t {
  constructor(t, e, n) {
    super(t, e, n), this.key = et.fromName(n.referenceValue);
  }
  matches(t) {
    const e = et.comparator(t.key, this.key);
    return this.matchesComparison(e);
  }
}
class HT extends $t {
  constructor(t, e) {
    super(t, "in", e), this.keys = Ey("in", e);
  }
  matches(t) {
    return this.keys.some((e) => e.isEqual(t.key));
  }
}
class WT extends $t {
  constructor(t, e) {
    super(t, "not-in", e), this.keys = Ey("not-in", e);
  }
  matches(t) {
    return !this.keys.some((e) => e.isEqual(t.key));
  }
}
function Ey(i, t) {
  var e;
  return (((e = t.arrayValue) === null || e === void 0 ? void 0 : e.values) || []).map((n) => et.fromName(n.referenceValue));
}
class qT extends $t {
  constructor(t, e) {
    super(t, "array-contains", e);
  }
  matches(t) {
    const e = t.data.field(this.field);
    return tu(e) && qs(e.arrayValue, this.value);
  }
}
class YT extends $t {
  constructor(t, e) {
    super(t, "in", e);
  }
  matches(t) {
    const e = t.data.field(this.field);
    return e !== null && qs(this.value.arrayValue, e);
  }
}
class XT extends $t {
  constructor(t, e) {
    super(t, "not-in", e);
  }
  matches(t) {
    if (qs(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    })) return !1;
    const e = t.data.field(this.field);
    return e !== null && !qs(this.value.arrayValue, e);
  }
}
class KT extends $t {
  constructor(t, e) {
    super(t, "array-contains-any", e);
  }
  matches(t) {
    const e = t.data.field(this.field);
    return !(!tu(e) || !e.arrayValue.values) && e.arrayValue.values.some((n) => qs(this.value.arrayValue, n));
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class QT {
  constructor(t, e = null, n = [], r = [], s = null, o = null, a = null) {
    this.path = t, this.collectionGroup = e, this.orderBy = n, this.filters = r, this.limit = s, this.startAt = o, this.endAt = a, this.ue = null;
  }
}
function Xp(i, t = null, e = [], n = [], r = null, s = null, o = null) {
  return new QT(i, t, e, n, r, s, o);
}
function eu(i) {
  const t = _t(i);
  if (t.ue === null) {
    let e = t.path.canonicalString();
    t.collectionGroup !== null && (e += "|cg:" + t.collectionGroup), e += "|f:", e += t.filters.map((n) => ic(n)).join(","), e += "|ob:", e += t.orderBy.map((n) => function(s) {
      return s.field.canonicalString() + s.dir;
    }(n)).join(","), Jc(t.limit) || (e += "|l:", e += t.limit), t.startAt && (e += "|lb:", e += t.startAt.inclusive ? "b:" : "a:", e += t.startAt.position.map((n) => Pr(n)).join(",")), t.endAt && (e += "|ub:", e += t.endAt.inclusive ? "a:" : "b:", e += t.endAt.position.map((n) => Pr(n)).join(",")), t.ue = e;
  }
  return t.ue;
}
function iu(i, t) {
  if (i.limit !== t.limit || i.orderBy.length !== t.orderBy.length) return !1;
  for (let e = 0; e < i.orderBy.length; e++) if (!zT(i.orderBy[e], t.orderBy[e])) return !1;
  if (i.filters.length !== t.filters.length) return !1;
  for (let e = 0; e < i.filters.length; e++) if (!Sy(i.filters[e], t.filters[e])) return !1;
  return i.collectionGroup === t.collectionGroup && !!i.path.isEqual(t.path) && !!Yp(i.startAt, t.startAt) && Yp(i.endAt, t.endAt);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ga {
  /**
   * Initializes a Query with a path and optional additional query constraints.
   * Path must currently be empty if this is a collection group query.
   */
  constructor(t, e = null, n = [], r = [], s = null, o = "F", a = null, l = null) {
    this.path = t, this.collectionGroup = e, this.explicitOrderBy = n, this.filters = r, this.limit = s, this.limitType = o, this.startAt = a, this.endAt = l, this.ce = null, // The corresponding `Target` of this `Query` instance, for use with
    // non-aggregate queries.
    this.le = null, // The corresponding `Target` of this `Query` instance, for use with
    // aggregate queries. Unlike targets for non-aggregate queries,
    // aggregate query targets do not contain normalized order-bys, they only
    // contain explicit order-bys.
    this.he = null, this.startAt, this.endAt;
  }
}
function JT(i, t, e, n, r, s, o, a) {
  return new Ga(i, t, e, n, r, s, o, a);
}
function ZT(i) {
  return new Ga(i);
}
function Kp(i) {
  return i.filters.length === 0 && i.limit === null && i.startAt == null && i.endAt == null && (i.explicitOrderBy.length === 0 || i.explicitOrderBy.length === 1 && i.explicitOrderBy[0].field.isKeyField());
}
function $T(i) {
  return i.collectionGroup !== null;
}
function Ss(i) {
  const t = _t(i);
  if (t.ce === null) {
    t.ce = [];
    const e = /* @__PURE__ */ new Set();
    for (const s of t.explicitOrderBy) t.ce.push(s), e.add(s.field.canonicalString());
    const n = t.explicitOrderBy.length > 0 ? t.explicitOrderBy[t.explicitOrderBy.length - 1].dir : "asc";
    (function(o) {
      let a = new le(oe.comparator);
      return o.filters.forEach((l) => {
        l.getFlattenedFilters().forEach((h) => {
          h.isInequality() && (a = a.add(h.field));
        });
      }), a;
    })(t).forEach((s) => {
      e.has(s.canonicalString()) || s.isKeyField() || t.ce.push(new _a(s, n));
    }), // Add the document key field to the last if it is not explicitly ordered.
    e.has(oe.keyField().canonicalString()) || t.ce.push(new _a(oe.keyField(), n));
  }
  return t.ce;
}
function Mn(i) {
  const t = _t(i);
  return t.le || (t.le = tE(t, Ss(i))), t.le;
}
function tE(i, t) {
  if (i.limitType === "F") return Xp(i.path, i.collectionGroup, t, i.filters, i.limit, i.startAt, i.endAt);
  {
    t = t.map((r) => {
      const s = r.dir === "desc" ? "asc" : "desc";
      return new _a(r.field, s);
    });
    const e = i.endAt ? new va(i.endAt.position, i.endAt.inclusive) : null, n = i.startAt ? new va(i.startAt.position, i.startAt.inclusive) : null;
    return Xp(i.path, i.collectionGroup, t, i.filters, i.limit, e, n);
  }
}
function nc(i, t, e) {
  return new Ga(i.path, i.collectionGroup, i.explicitOrderBy.slice(), i.filters.slice(), t, e, i.startAt, i.endAt);
}
function Cy(i, t) {
  return iu(Mn(i), Mn(t)) && i.limitType === t.limitType;
}
function Py(i) {
  return `${eu(Mn(i))}|lt:${i.limitType}`;
}
function ss(i) {
  return `Query(target=${function(e) {
    let n = e.path.canonicalString();
    return e.collectionGroup !== null && (n += " collectionGroup=" + e.collectionGroup), e.filters.length > 0 && (n += `, filters: [${e.filters.map((r) => Ty(r)).join(", ")}]`), Jc(e.limit) || (n += ", limit: " + e.limit), e.orderBy.length > 0 && (n += `, orderBy: [${e.orderBy.map((r) => function(o) {
      return `${o.field.canonicalString()} (${o.dir})`;
    }(r)).join(", ")}]`), e.startAt && (n += ", startAt: ", n += e.startAt.inclusive ? "b:" : "a:", n += e.startAt.position.map((r) => Pr(r)).join(",")), e.endAt && (n += ", endAt: ", n += e.endAt.inclusive ? "a:" : "b:", n += e.endAt.position.map((r) => Pr(r)).join(",")), `Target(${n})`;
  }(Mn(i))}; limitType=${i.limitType})`;
}
function nu(i, t) {
  return t.isFoundDocument() && function(n, r) {
    const s = r.key.path;
    return n.collectionGroup !== null ? r.key.hasCollectionId(n.collectionGroup) && n.path.isPrefixOf(s) : et.isDocumentKey(n.path) ? n.path.isEqual(s) : n.path.isImmediateParentOf(s);
  }(i, t) && function(n, r) {
    for (const s of Ss(n))
      if (!s.field.isKeyField() && r.data.field(s.field) === null) return !1;
    return !0;
  }(i, t) && function(n, r) {
    for (const s of n.filters) if (!s.matches(r)) return !1;
    return !0;
  }(i, t) && function(n, r) {
    return !(n.startAt && !/**
    * Returns true if a document sorts before a bound using the provided sort
    * order.
    */
    function(o, a, l) {
      const h = qp(o, a, l);
      return o.inclusive ? h <= 0 : h < 0;
    }(n.startAt, Ss(n), r) || n.endAt && !function(o, a, l) {
      const h = qp(o, a, l);
      return o.inclusive ? h >= 0 : h > 0;
    }(n.endAt, Ss(n), r));
  }(i, t);
}
function eE(i) {
  return (t, e) => {
    let n = !1;
    for (const r of Ss(i)) {
      const s = iE(r, t, e);
      if (s !== 0) return s;
      n = n || r.field.isKeyField();
    }
    return 0;
  };
}
function iE(i, t, e) {
  const n = i.field.isKeyField() ? et.comparator(t.key, e.key) : function(s, o, a) {
    const l = o.data.field(s), h = a.data.field(s);
    return l !== null && h !== null ? Cr(l, h) : rt();
  }(i.field, t, e);
  switch (i.dir) {
    case "asc":
      return n;
    case "desc":
      return -1 * n;
    default:
      return rt();
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Gn {
  constructor(t, e) {
    this.mapKeyFn = t, this.equalsFn = e, /**
     * The inner map for a key/value pair. Due to the possibility of collisions we
     * keep a list of entries that we do a linear search through to find an actual
     * match. Note that collisions should be rare, so we still expect near
     * constant time lookups in practice.
     */
    this.inner = {}, /** The number of entries stored in the map */
    this.innerSize = 0;
  }
  /** Get a value for this key, or undefined if it does not exist. */
  get(t) {
    const e = this.mapKeyFn(t), n = this.inner[e];
    if (n !== void 0) {
      for (const [r, s] of n) if (this.equalsFn(r, t)) return s;
    }
  }
  has(t) {
    return this.get(t) !== void 0;
  }
  /** Put this key and value in the map. */
  set(t, e) {
    const n = this.mapKeyFn(t), r = this.inner[n];
    if (r === void 0) return this.inner[n] = [[t, e]], void this.innerSize++;
    for (let s = 0; s < r.length; s++) if (this.equalsFn(r[s][0], t))
      return void (r[s] = [t, e]);
    r.push([t, e]), this.innerSize++;
  }
  /**
   * Remove this key from the map. Returns a boolean if anything was deleted.
   */
  delete(t) {
    const e = this.mapKeyFn(t), n = this.inner[e];
    if (n === void 0) return !1;
    for (let r = 0; r < n.length; r++) if (this.equalsFn(n[r][0], t)) return n.length === 1 ? delete this.inner[e] : n.splice(r, 1), this.innerSize--, !0;
    return !1;
  }
  forEach(t) {
    Lr(this.inner, (e, n) => {
      for (const [r, s] of n) t(r, s);
    });
  }
  isEmpty() {
    return _y(this.inner);
  }
  size() {
    return this.innerSize;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const nE = new Ve(et.comparator);
function xa() {
  return nE;
}
const Iy = new Ve(et.comparator);
function Do(...i) {
  let t = Iy;
  for (const e of i) t = t.insert(e.key, e);
  return t;
}
function Ry(i) {
  let t = Iy;
  return i.forEach((e, n) => t = t.insert(e, n.overlayedDocument)), t;
}
function En() {
  return Ts();
}
function ky() {
  return Ts();
}
function Ts() {
  return new Gn((i) => i.toString(), (i, t) => i.isEqual(t));
}
const rE = new Ve(et.comparator), sE = new le(et.comparator);
function pe(...i) {
  let t = sE;
  for (const e of i) t = t.add(e);
  return t;
}
const oE = new le(ft);
function aE() {
  return oE;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ru(i, t) {
  if (i.useProto3Json) {
    if (isNaN(t)) return {
      doubleValue: "NaN"
    };
    if (t === 1 / 0) return {
      doubleValue: "Infinity"
    };
    if (t === -1 / 0) return {
      doubleValue: "-Infinity"
    };
  }
  return {
    doubleValue: ma(t) ? "-0" : t
  };
}
function My(i) {
  return {
    integerValue: "" + i
  };
}
function lE(i, t) {
  return OT(t) ? My(t) : ru(i, t);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ha {
  constructor() {
    this._ = void 0;
  }
}
function hE(i, t, e) {
  return i instanceof ba ? function(r, s) {
    const o = {
      fields: {
        __type__: {
          stringValue: "server_timestamp"
        },
        __local_write_time__: {
          timestampValue: {
            seconds: r.seconds,
            nanos: r.nanoseconds
          }
        }
      }
    };
    return s && Zc(s) && (s = $c(s)), s && (o.fields.__previous_value__ = s), {
      mapValue: o
    };
  }(e, t) : i instanceof Ys ? Dy(i, t) : i instanceof Xs ? By(i, t) : function(r, s) {
    const o = Oy(r, s), a = Qp(o) + Qp(r.Pe);
    return ec(o) && ec(r.Pe) ? My(a) : ru(r.serializer, a);
  }(i, t);
}
function cE(i, t, e) {
  return i instanceof Ys ? Dy(i, t) : i instanceof Xs ? By(i, t) : e;
}
function Oy(i, t) {
  return i instanceof wa ? (
    /** Returns true if `value` is either an IntegerValue or a DoubleValue. */
    function(n) {
      return ec(n) || function(s) {
        return !!s && "doubleValue" in s;
      }(n);
    }(t) ? t : {
      integerValue: 0
    }
  ) : null;
}
class ba extends Ha {
}
class Ys extends Ha {
  constructor(t) {
    super(), this.elements = t;
  }
}
function Dy(i, t) {
  const e = Vy(t);
  for (const n of i.elements) e.some((r) => xi(r, n)) || e.push(n);
  return {
    arrayValue: {
      values: e
    }
  };
}
class Xs extends Ha {
  constructor(t) {
    super(), this.elements = t;
  }
}
function By(i, t) {
  let e = Vy(t);
  for (const n of i.elements) e = e.filter((r) => !xi(r, n));
  return {
    arrayValue: {
      values: e
    }
  };
}
class wa extends Ha {
  constructor(t, e) {
    super(), this.serializer = t, this.Pe = e;
  }
}
function Qp(i) {
  return se(i.integerValue || i.doubleValue);
}
function Vy(i) {
  return tu(i) && i.arrayValue.values ? i.arrayValue.values.slice() : [];
}
function uE(i, t) {
  return i.field.isEqual(t.field) && function(n, r) {
    return n instanceof Ys && r instanceof Ys || n instanceof Xs && r instanceof Xs ? Tr(n.elements, r.elements, xi) : n instanceof wa && r instanceof wa ? xi(n.Pe, r.Pe) : n instanceof ba && r instanceof ba;
  }(i.transform, t.transform);
}
class dE {
  constructor(t, e) {
    this.version = t, this.transformResults = e;
  }
}
class Oi {
  constructor(t, e) {
    this.updateTime = t, this.exists = e;
  }
  /** Creates a new empty Precondition. */
  static none() {
    return new Oi();
  }
  /** Creates a new Precondition with an exists flag. */
  static exists(t) {
    return new Oi(void 0, t);
  }
  /** Creates a new Precondition based on a version a document exists at. */
  static updateTime(t) {
    return new Oi(t);
  }
  /** Returns whether this Precondition is empty. */
  get isNone() {
    return this.updateTime === void 0 && this.exists === void 0;
  }
  isEqual(t) {
    return this.exists === t.exists && (this.updateTime ? !!t.updateTime && this.updateTime.isEqual(t.updateTime) : !t.updateTime);
  }
}
function Yo(i, t) {
  return i.updateTime !== void 0 ? t.isFoundDocument() && t.version.isEqual(i.updateTime) : i.exists === void 0 || i.exists === t.isFoundDocument();
}
class Wa {
}
function Fy(i, t) {
  if (!i.hasLocalMutations || t && t.fields.length === 0) return null;
  if (t === null) return i.isNoDocument() ? new Ny(i.key, Oi.none()) : new $s(i.key, i.data, Oi.none());
  {
    const e = i.data, n = oi.empty();
    let r = new le(oe.comparator);
    for (let s of t.fields) if (!r.has(s)) {
      let o = e.field(s);
      o === null && s.length > 1 && (s = s.popLast(), o = e.field(s)), o === null ? n.delete(s) : n.set(s, o), r = r.add(s);
    }
    return new Hn(i.key, n, new li(r.toArray()), Oi.none());
  }
}
function pE(i, t, e) {
  i instanceof $s ? function(r, s, o) {
    const a = r.value.clone(), l = Zp(r.fieldTransforms, s, o.transformResults);
    a.setAll(l), s.convertToFoundDocument(o.version, a).setHasCommittedMutations();
  }(i, t, e) : i instanceof Hn ? function(r, s, o) {
    if (!Yo(r.precondition, s))
      return void s.convertToUnknownDocument(o.version);
    const a = Zp(r.fieldTransforms, s, o.transformResults), l = s.data;
    l.setAll(Ly(r)), l.setAll(a), s.convertToFoundDocument(o.version, l).setHasCommittedMutations();
  }(i, t, e) : function(r, s, o) {
    s.convertToNoDocument(o.version).setHasCommittedMutations();
  }(0, t, e);
}
function Es(i, t, e, n) {
  return i instanceof $s ? function(s, o, a, l) {
    if (!Yo(s.precondition, o))
      return a;
    const h = s.value.clone(), c = $p(s.fieldTransforms, l, o);
    return h.setAll(c), o.convertToFoundDocument(o.version, h).setHasLocalMutations(), null;
  }(i, t, e, n) : i instanceof Hn ? function(s, o, a, l) {
    if (!Yo(s.precondition, o)) return a;
    const h = $p(s.fieldTransforms, l, o), c = o.data;
    return c.setAll(Ly(s)), c.setAll(h), o.convertToFoundDocument(o.version, c).setHasLocalMutations(), a === null ? null : a.unionWith(s.fieldMask.fields).unionWith(s.fieldTransforms.map((p) => p.field));
  }(i, t, e, n) : function(s, o, a) {
    return Yo(s.precondition, o) ? (o.convertToNoDocument(o.version).setHasLocalMutations(), null) : a;
  }(i, t, e);
}
function fE(i, t) {
  let e = null;
  for (const n of i.fieldTransforms) {
    const r = t.data.field(n.field), s = Oy(n.transform, r || null);
    s != null && (e === null && (e = oi.empty()), e.set(n.field, s));
  }
  return e || null;
}
function Jp(i, t) {
  return i.type === t.type && !!i.key.isEqual(t.key) && !!i.precondition.isEqual(t.precondition) && !!function(n, r) {
    return n === void 0 && r === void 0 || !(!n || !r) && Tr(n, r, (s, o) => uE(s, o));
  }(i.fieldTransforms, t.fieldTransforms) && (i.type === 0 ? i.value.isEqual(t.value) : i.type !== 1 || i.data.isEqual(t.data) && i.fieldMask.isEqual(t.fieldMask));
}
class $s extends Wa {
  constructor(t, e, n, r = []) {
    super(), this.key = t, this.value = e, this.precondition = n, this.fieldTransforms = r, this.type = 0;
  }
  getFieldMask() {
    return null;
  }
}
class Hn extends Wa {
  constructor(t, e, n, r, s = []) {
    super(), this.key = t, this.data = e, this.fieldMask = n, this.precondition = r, this.fieldTransforms = s, this.type = 1;
  }
  getFieldMask() {
    return this.fieldMask;
  }
}
function Ly(i) {
  const t = /* @__PURE__ */ new Map();
  return i.fieldMask.fields.forEach((e) => {
    if (!e.isEmpty()) {
      const n = i.data.field(e);
      t.set(e, n);
    }
  }), t;
}
function Zp(i, t, e) {
  const n = /* @__PURE__ */ new Map();
  Bt(i.length === e.length);
  for (let r = 0; r < e.length; r++) {
    const s = i[r], o = s.transform, a = t.data.field(s.field);
    n.set(s.field, cE(o, a, e[r]));
  }
  return n;
}
function $p(i, t, e) {
  const n = /* @__PURE__ */ new Map();
  for (const r of i) {
    const s = r.transform, o = e.data.field(r.field);
    n.set(r.field, hE(s, o, t));
  }
  return n;
}
class Ny extends Wa {
  constructor(t, e) {
    super(), this.key = t, this.precondition = e, this.type = 2, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
}
class mE extends Wa {
  constructor(t, e) {
    super(), this.key = t, this.precondition = e, this.type = 3, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class gE {
  /**
   * @param batchId - The unique ID of this mutation batch.
   * @param localWriteTime - The original write time of this mutation.
   * @param baseMutations - Mutations that are used to populate the base
   * values when this mutation is applied locally. This can be used to locally
   * overwrite values that are persisted in the remote document cache. Base
   * mutations are never sent to the backend.
   * @param mutations - The user-provided mutations in this mutation batch.
   * User-provided mutations are applied both locally and remotely on the
   * backend.
   */
  constructor(t, e, n, r) {
    this.batchId = t, this.localWriteTime = e, this.baseMutations = n, this.mutations = r;
  }
  /**
   * Applies all the mutations in this MutationBatch to the specified document
   * to compute the state of the remote document
   *
   * @param document - The document to apply mutations to.
   * @param batchResult - The result of applying the MutationBatch to the
   * backend.
   */
  applyToRemoteDocument(t, e) {
    const n = e.mutationResults;
    for (let r = 0; r < this.mutations.length; r++) {
      const s = this.mutations[r];
      s.key.isEqual(t.key) && pE(s, t, n[r]);
    }
  }
  /**
   * Computes the local view of a document given all the mutations in this
   * batch.
   *
   * @param document - The document to apply mutations to.
   * @param mutatedFields - Fields that have been updated before applying this mutation batch.
   * @returns A `FieldMask` representing all the fields that are mutated.
   */
  applyToLocalView(t, e) {
    for (const n of this.baseMutations) n.key.isEqual(t.key) && (e = Es(n, t, e, this.localWriteTime));
    for (const n of this.mutations) n.key.isEqual(t.key) && (e = Es(n, t, e, this.localWriteTime));
    return e;
  }
  /**
   * Computes the local view for all provided documents given the mutations in
   * this batch. Returns a `DocumentKey` to `Mutation` map which can be used to
   * replace all the mutation applications.
   */
  applyToLocalDocumentSet(t, e) {
    const n = ky();
    return this.mutations.forEach((r) => {
      const s = t.get(r.key), o = s.overlayedDocument;
      let a = this.applyToLocalView(o, s.mutatedFields);
      a = e.has(r.key) ? null : a;
      const l = Fy(o, a);
      l !== null && n.set(r.key, l), o.isValidDocument() || o.convertToNoDocument(wt.min());
    }), n;
  }
  keys() {
    return this.mutations.reduce((t, e) => t.add(e.key), pe());
  }
  isEqual(t) {
    return this.batchId === t.batchId && Tr(this.mutations, t.mutations, (e, n) => Jp(e, n)) && Tr(this.baseMutations, t.baseMutations, (e, n) => Jp(e, n));
  }
}
class su {
  constructor(t, e, n, r) {
    this.batch = t, this.commitVersion = e, this.mutationResults = n, this.docVersions = r;
  }
  /**
   * Creates a new MutationBatchResult for the given batch and results. There
   * must be one result for each mutation in the batch. This static factory
   * caches a document=&gt;version mapping (docVersions).
   */
  static from(t, e, n) {
    Bt(t.mutations.length === n.length);
    let r = /* @__PURE__ */ function() {
      return rE;
    }();
    const s = t.mutations;
    for (let o = 0; o < s.length; o++) r = r.insert(s[o].key, n[o].version);
    return new su(t, e, n, r);
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class yE {
  constructor(t, e) {
    this.largestBatchId = t, this.mutation = e;
  }
  getKey() {
    return this.mutation.key;
  }
  isEqual(t) {
    return t !== null && this.mutation === t.mutation;
  }
  toString() {
    return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Nt, ot;
function vE(i) {
  switch (i) {
    default:
      return rt();
    case z.CANCELLED:
    case z.UNKNOWN:
    case z.DEADLINE_EXCEEDED:
    case z.RESOURCE_EXHAUSTED:
    case z.INTERNAL:
    case z.UNAVAILABLE:
    case z.UNAUTHENTICATED:
      return !1;
    case z.INVALID_ARGUMENT:
    case z.NOT_FOUND:
    case z.ALREADY_EXISTS:
    case z.PERMISSION_DENIED:
    case z.FAILED_PRECONDITION:
    case z.ABORTED:
    case z.OUT_OF_RANGE:
    case z.UNIMPLEMENTED:
    case z.DATA_LOSS:
      return !0;
  }
}
function _E(i) {
  if (i === void 0)
    return Ln("GRPC error has no .code"), z.UNKNOWN;
  switch (i) {
    case Nt.OK:
      return z.OK;
    case Nt.CANCELLED:
      return z.CANCELLED;
    case Nt.UNKNOWN:
      return z.UNKNOWN;
    case Nt.DEADLINE_EXCEEDED:
      return z.DEADLINE_EXCEEDED;
    case Nt.RESOURCE_EXHAUSTED:
      return z.RESOURCE_EXHAUSTED;
    case Nt.INTERNAL:
      return z.INTERNAL;
    case Nt.UNAVAILABLE:
      return z.UNAVAILABLE;
    case Nt.UNAUTHENTICATED:
      return z.UNAUTHENTICATED;
    case Nt.INVALID_ARGUMENT:
      return z.INVALID_ARGUMENT;
    case Nt.NOT_FOUND:
      return z.NOT_FOUND;
    case Nt.ALREADY_EXISTS:
      return z.ALREADY_EXISTS;
    case Nt.PERMISSION_DENIED:
      return z.PERMISSION_DENIED;
    case Nt.FAILED_PRECONDITION:
      return z.FAILED_PRECONDITION;
    case Nt.ABORTED:
      return z.ABORTED;
    case Nt.OUT_OF_RANGE:
      return z.OUT_OF_RANGE;
    case Nt.UNIMPLEMENTED:
      return z.UNIMPLEMENTED;
    case Nt.DATA_LOSS:
      return z.DATA_LOSS;
    default:
      return rt();
  }
}
(ot = Nt || (Nt = {}))[ot.OK = 0] = "OK", ot[ot.CANCELLED = 1] = "CANCELLED", ot[ot.UNKNOWN = 2] = "UNKNOWN", ot[ot.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", ot[ot.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", ot[ot.NOT_FOUND = 5] = "NOT_FOUND", ot[ot.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", ot[ot.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", ot[ot.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", ot[ot.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", ot[ot.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", ot[ot.ABORTED = 10] = "ABORTED", ot[ot.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", ot[ot.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", ot[ot.INTERNAL = 13] = "INTERNAL", ot[ot.UNAVAILABLE = 14] = "UNAVAILABLE", ot[ot.DATA_LOSS = 15] = "DATA_LOSS";
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
new uy([4294967295, 4294967295], 0);
class xE {
  constructor(t, e) {
    this.databaseId = t, this.useProto3Json = e;
  }
}
function rc(i, t) {
  return i.useProto3Json ? `${new Date(1e3 * t.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + t.nanoseconds).slice(-9)}Z` : {
    seconds: "" + t.seconds,
    nanos: t.nanoseconds
  };
}
function bE(i, t) {
  return i.useProto3Json ? t.toBase64() : t.toUint8Array();
}
function wE(i, t) {
  return rc(i, t.toTimestamp());
}
function mr(i) {
  return Bt(!!i), wt.fromTimestamp(function(e) {
    const n = Nn(e);
    return new te(n.seconds, n.nanos);
  }(i));
}
function Uy(i, t) {
  return sc(i, t).canonicalString();
}
function sc(i, t) {
  const e = function(r) {
    return new zt(["projects", r.projectId, "databases", r.database]);
  }(i).child("documents");
  return t === void 0 ? e : e.child(t);
}
function AE(i) {
  const t = zt.fromString(i);
  return Bt(kE(t)), t;
}
function oc(i, t) {
  return Uy(i.databaseId, t.path);
}
function SE(i) {
  const t = AE(i);
  return t.length === 4 ? zt.emptyPath() : EE(t);
}
function TE(i) {
  return new zt(["projects", i.databaseId.projectId, "databases", i.databaseId.database]).canonicalString();
}
function EE(i) {
  return Bt(i.length > 4 && i.get(4) === "documents"), i.popFirst(5);
}
function tf(i, t, e) {
  return {
    name: oc(i, t),
    fields: e.value.mapValue.fields
  };
}
function CE(i, t) {
  let e;
  if (t instanceof $s) e = {
    update: tf(i, t.key, t.value)
  };
  else if (t instanceof Ny) e = {
    delete: oc(i, t.key)
  };
  else if (t instanceof Hn) e = {
    update: tf(i, t.key, t.data),
    updateMask: RE(t.fieldMask)
  };
  else {
    if (!(t instanceof mE)) return rt();
    e = {
      verify: oc(i, t.key)
    };
  }
  return t.fieldTransforms.length > 0 && (e.updateTransforms = t.fieldTransforms.map((n) => function(s, o) {
    const a = o.transform;
    if (a instanceof ba) return {
      fieldPath: o.field.canonicalString(),
      setToServerValue: "REQUEST_TIME"
    };
    if (a instanceof Ys) return {
      fieldPath: o.field.canonicalString(),
      appendMissingElements: {
        values: a.elements
      }
    };
    if (a instanceof Xs) return {
      fieldPath: o.field.canonicalString(),
      removeAllFromArray: {
        values: a.elements
      }
    };
    if (a instanceof wa) return {
      fieldPath: o.field.canonicalString(),
      increment: a.Pe
    };
    throw rt();
  }(0, n))), t.precondition.isNone || (e.currentDocument = function(r, s) {
    return s.updateTime !== void 0 ? {
      updateTime: wE(r, s.updateTime)
    } : s.exists !== void 0 ? {
      exists: s.exists
    } : rt();
  }(i, t.precondition)), e;
}
function PE(i, t) {
  return i && i.length > 0 ? (Bt(t !== void 0), i.map((e) => function(r, s) {
    let o = r.updateTime ? mr(r.updateTime) : mr(s);
    return o.isEqual(wt.min()) && // The Firestore Emulator currently returns an update time of 0 for
    // deletes of non-existing documents (rather than null). This breaks the
    // test "get deleted doc while offline with source=cache" as NoDocuments
    // with version 0 are filtered by IndexedDb's RemoteDocumentCache.
    // TODO(#2149): Remove this when Emulator is fixed
    (o = mr(s)), new dE(o, r.transformResults || []);
  }(e, t))) : [];
}
function IE(i) {
  let t = SE(i.parent);
  const e = i.structuredQuery, n = e.from ? e.from.length : 0;
  let r = null;
  if (n > 0) {
    Bt(n === 1);
    const c = e.from[0];
    c.allDescendants ? r = c.collectionId : t = t.child(c.collectionId);
  }
  let s = [];
  e.where && (s = function(p) {
    const f = zy(p);
    return f instanceof en && Ay(f) ? f.getFilters() : [f];
  }(e.where));
  let o = [];
  e.orderBy && (o = function(p) {
    return p.map((f) => function(m) {
      return new _a(
        nr(m.field),
        // visible for testing
        function(y) {
          switch (y) {
            case "ASCENDING":
              return "asc";
            case "DESCENDING":
              return "desc";
            default:
              return;
          }
        }(m.direction)
      );
    }(f));
  }(e.orderBy));
  let a = null;
  e.limit && (a = function(p) {
    let f;
    return f = typeof p == "object" ? p.value : p, Jc(f) ? null : f;
  }(e.limit));
  let l = null;
  e.startAt && (l = function(p) {
    const f = !!p.before, d = p.values || [];
    return new va(d, f);
  }(e.startAt));
  let h = null;
  return e.endAt && (h = function(p) {
    const f = !p.before, d = p.values || [];
    return new va(d, f);
  }(e.endAt)), JT(t, r, o, s, a, "F", l, h);
}
function zy(i) {
  return i.unaryFilter !== void 0 ? function(e) {
    switch (e.unaryFilter.op) {
      case "IS_NAN":
        const n = nr(e.unaryFilter.field);
        return $t.create(n, "==", {
          doubleValue: NaN
        });
      case "IS_NULL":
        const r = nr(e.unaryFilter.field);
        return $t.create(r, "==", {
          nullValue: "NULL_VALUE"
        });
      case "IS_NOT_NAN":
        const s = nr(e.unaryFilter.field);
        return $t.create(s, "!=", {
          doubleValue: NaN
        });
      case "IS_NOT_NULL":
        const o = nr(e.unaryFilter.field);
        return $t.create(o, "!=", {
          nullValue: "NULL_VALUE"
        });
      default:
        return rt();
    }
  }(i) : i.fieldFilter !== void 0 ? function(e) {
    return $t.create(nr(e.fieldFilter.field), function(r) {
      switch (r) {
        case "EQUAL":
          return "==";
        case "NOT_EQUAL":
          return "!=";
        case "GREATER_THAN":
          return ">";
        case "GREATER_THAN_OR_EQUAL":
          return ">=";
        case "LESS_THAN":
          return "<";
        case "LESS_THAN_OR_EQUAL":
          return "<=";
        case "ARRAY_CONTAINS":
          return "array-contains";
        case "IN":
          return "in";
        case "NOT_IN":
          return "not-in";
        case "ARRAY_CONTAINS_ANY":
          return "array-contains-any";
        default:
          return rt();
      }
    }(e.fieldFilter.op), e.fieldFilter.value);
  }(i) : i.compositeFilter !== void 0 ? function(e) {
    return en.create(e.compositeFilter.filters.map((n) => zy(n)), function(r) {
      switch (r) {
        case "AND":
          return "and";
        case "OR":
          return "or";
        default:
          return rt();
      }
    }(e.compositeFilter.op));
  }(i) : rt();
}
function nr(i) {
  return oe.fromServerFormat(i.fieldPath);
}
function RE(i) {
  const t = [];
  return i.fields.forEach((e) => t.push(e.canonicalString())), {
    fieldPaths: t
  };
}
function kE(i) {
  return i.length >= 4 && i.get(0) === "projects" && i.get(2) === "databases";
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ME {
  constructor(t) {
    this.ht = t;
  }
}
function OE(i) {
  const t = IE({
    parent: i.parent,
    structuredQuery: i.structuredQuery
  });
  return i.limitType === "LAST" ? nc(
    t,
    t.limit,
    "L"
    /* LimitType.Last */
  ) : t;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DE {
  constructor() {
    this.ln = new BE();
  }
  addToCollectionParentIndex(t, e) {
    return this.ln.add(e), L.resolve();
  }
  getCollectionParents(t, e) {
    return L.resolve(this.ln.getEntries(e));
  }
  addFieldIndex(t, e) {
    return L.resolve();
  }
  deleteFieldIndex(t, e) {
    return L.resolve();
  }
  deleteAllFieldIndexes(t) {
    return L.resolve();
  }
  createTargetIndexes(t, e) {
    return L.resolve();
  }
  getDocumentsMatchingTarget(t, e) {
    return L.resolve(null);
  }
  getIndexType(t, e) {
    return L.resolve(
      0
      /* IndexType.NONE */
    );
  }
  getFieldIndexes(t, e) {
    return L.resolve([]);
  }
  getNextCollectionGroupToUpdate(t) {
    return L.resolve(null);
  }
  getMinOffset(t, e) {
    return L.resolve(tn.min());
  }
  getMinOffsetFromCollectionGroup(t, e) {
    return L.resolve(tn.min());
  }
  updateCollectionGroup(t, e, n) {
    return L.resolve();
  }
  updateIndexEntries(t, e) {
    return L.resolve();
  }
}
class BE {
  constructor() {
    this.index = {};
  }
  // Returns false if the entry already existed.
  add(t) {
    const e = t.lastSegment(), n = t.popLast(), r = this.index[e] || new le(zt.comparator), s = !r.has(n);
    return this.index[e] = r.add(n), s;
  }
  has(t) {
    const e = t.lastSegment(), n = t.popLast(), r = this.index[e];
    return r && r.has(n);
  }
  getEntries(t) {
    return (this.index[t] || new le(zt.comparator)).toArray();
  }
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ef = {
  didRun: !1,
  sequenceNumbersCollected: 0,
  targetsRemoved: 0,
  documentsRemoved: 0
};
class Ce {
  static withCacheSize(t) {
    return new Ce(t, Ce.DEFAULT_COLLECTION_PERCENTILE, Ce.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
  }
  constructor(t, e, n) {
    this.cacheSizeCollectionThreshold = t, this.percentileToCollect = e, this.maximumSequenceNumbersToCollect = n;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Ce.DEFAULT_COLLECTION_PERCENTILE = 10, Ce.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, Ce.DEFAULT = new Ce(41943040, Ce.DEFAULT_COLLECTION_PERCENTILE, Ce.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), Ce.DISABLED = new Ce(-1, 0, 0);
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ir {
  constructor(t) {
    this.kn = t;
  }
  next() {
    return this.kn += 2, this.kn;
  }
  static qn() {
    return new Ir(0);
  }
  static Qn() {
    return new Ir(-1);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function nf([i, t], [e, n]) {
  const r = ft(i, e);
  return r === 0 ? ft(t, n) : r;
}
class VE {
  constructor(t) {
    this.Gn = t, this.buffer = new le(nf), this.zn = 0;
  }
  jn() {
    return ++this.zn;
  }
  Hn(t) {
    const e = [t, this.jn()];
    if (this.buffer.size < this.Gn) this.buffer = this.buffer.add(e);
    else {
      const n = this.buffer.last();
      nf(e, n) < 0 && (this.buffer = this.buffer.delete(n).add(e));
    }
  }
  get maxValue() {
    return this.buffer.last()[0];
  }
}
class FE {
  constructor(t, e, n) {
    this.garbageCollector = t, this.asyncQueue = e, this.localStore = n, this.Jn = null;
  }
  start() {
    this.garbageCollector.params.cacheSizeCollectionThreshold !== -1 && this.Yn(6e4);
  }
  stop() {
    this.Jn && (this.Jn.cancel(), this.Jn = null);
  }
  get started() {
    return this.Jn !== null;
  }
  Yn(t) {
    q("LruGarbageCollector", `Garbage collection scheduled in ${t}ms`), this.Jn = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", t, async () => {
      this.Jn = null;
      try {
        await this.localStore.collectGarbage(this.garbageCollector);
      } catch (e) {
        Zs(e) ? q("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", e) : await Kc(e);
      }
      await this.Yn(3e5);
    });
  }
}
class LE {
  constructor(t, e) {
    this.Zn = t, this.params = e;
  }
  calculateTargetCount(t, e) {
    return this.Zn.Xn(t).next((n) => Math.floor(e / 100 * n));
  }
  nthSequenceNumber(t, e) {
    if (e === 0) return L.resolve(Qc.oe);
    const n = new VE(e);
    return this.Zn.forEachTarget(t, (r) => n.Hn(r.sequenceNumber)).next(() => this.Zn.er(t, (r) => n.Hn(r))).next(() => n.maxValue);
  }
  removeTargets(t, e, n) {
    return this.Zn.removeTargets(t, e, n);
  }
  removeOrphanedDocuments(t, e) {
    return this.Zn.removeOrphanedDocuments(t, e);
  }
  collect(t, e) {
    return this.params.cacheSizeCollectionThreshold === -1 ? (q("LruGarbageCollector", "Garbage collection skipped; disabled"), L.resolve(ef)) : this.getCacheSize(t).next((n) => n < this.params.cacheSizeCollectionThreshold ? (q("LruGarbageCollector", `Garbage collection skipped; Cache size ${n} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`), ef) : this.tr(t, e));
  }
  getCacheSize(t) {
    return this.Zn.getCacheSize(t);
  }
  tr(t, e) {
    let n, r, s, o, a, l, h;
    const c = Date.now();
    return this.calculateTargetCount(t, this.params.percentileToCollect).next((p) => (
      // Cap at the configured max
      (p > this.params.maximumSequenceNumbersToCollect ? (q("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${p}`), r = this.params.maximumSequenceNumbersToCollect) : r = p, o = Date.now(), this.nthSequenceNumber(t, r))
    )).next((p) => (n = p, a = Date.now(), this.removeTargets(t, n, e))).next((p) => (s = p, l = Date.now(), this.removeOrphanedDocuments(t, n))).next((p) => (h = Date.now(), ir() <= at.DEBUG && q("LruGarbageCollector", `LRU Garbage Collection
	Counted targets in ${o - c}ms
	Determined least recently used ${r} in ` + (a - o) + `ms
	Removed ${s} targets in ` + (l - a) + `ms
	Removed ${p} documents in ` + (h - l) + `ms
Total Duration: ${h - c}ms`), L.resolve({
      didRun: !0,
      sequenceNumbersCollected: r,
      targetsRemoved: s,
      documentsRemoved: p
    })));
  }
}
function NE(i, t) {
  return new LE(i, t);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UE {
  constructor() {
    this.changes = new Gn((t) => t.toString(), (t, e) => t.isEqual(e)), this.changesApplied = !1;
  }
  /**
   * Buffers a `RemoteDocumentCache.addEntry()` call.
   *
   * You can only modify documents that have already been retrieved via
   * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).
   */
  addEntry(t) {
    this.assertNotApplied(), this.changes.set(t.key, t);
  }
  /**
   * Buffers a `RemoteDocumentCache.removeEntry()` call.
   *
   * You can only remove documents that have already been retrieved via
   * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).
   */
  removeEntry(t, e) {
    this.assertNotApplied(), this.changes.set(t, ri.newInvalidDocument(t).setReadTime(e));
  }
  /**
   * Looks up an entry in the cache. The buffered changes will first be checked,
   * and if no buffered change applies, this will forward to
   * `RemoteDocumentCache.getEntry()`.
   *
   * @param transaction - The transaction in which to perform any persistence
   *     operations.
   * @param documentKey - The key of the entry to look up.
   * @returns The cached document or an invalid document if we have nothing
   * cached.
   */
  getEntry(t, e) {
    this.assertNotApplied();
    const n = this.changes.get(e);
    return n !== void 0 ? L.resolve(n) : this.getFromCache(t, e);
  }
  /**
   * Looks up several entries in the cache, forwarding to
   * `RemoteDocumentCache.getEntry()`.
   *
   * @param transaction - The transaction in which to perform any persistence
   *     operations.
   * @param documentKeys - The keys of the entries to look up.
   * @returns A map of cached documents, indexed by key. If an entry cannot be
   *     found, the corresponding key will be mapped to an invalid document.
   */
  getEntries(t, e) {
    return this.getAllFromCache(t, e);
  }
  /**
   * Applies buffered changes to the underlying RemoteDocumentCache, using
   * the provided transaction.
   */
  apply(t) {
    return this.assertNotApplied(), this.changesApplied = !0, this.applyChanges(t);
  }
  /** Helper to assert this.changes is not null  */
  assertNotApplied() {
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class zE {
  constructor(t, e) {
    this.overlayedDocument = t, this.mutatedFields = e;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class jE {
  constructor(t, e, n, r) {
    this.remoteDocumentCache = t, this.mutationQueue = e, this.documentOverlayCache = n, this.indexManager = r;
  }
  /**
   * Get the local view of the document identified by `key`.
   *
   * @returns Local view of the document or null if we don't have any cached
   * state for it.
   */
  getDocument(t, e) {
    let n = null;
    return this.documentOverlayCache.getOverlay(t, e).next((r) => (n = r, this.remoteDocumentCache.getEntry(t, e))).next((r) => (n !== null && Es(n.mutation, r, li.empty(), te.now()), r));
  }
  /**
   * Gets the local view of the documents identified by `keys`.
   *
   * If we don't have cached state for a document in `keys`, a NoDocument will
   * be stored for that key in the resulting set.
   */
  getDocuments(t, e) {
    return this.remoteDocumentCache.getEntries(t, e).next((n) => this.getLocalViewOfDocuments(t, n, pe()).next(() => n));
  }
  /**
   * Similar to `getDocuments`, but creates the local view from the given
   * `baseDocs` without retrieving documents from the local store.
   *
   * @param transaction - The transaction this operation is scoped to.
   * @param docs - The documents to apply local mutations to get the local views.
   * @param existenceStateChanged - The set of document keys whose existence state
   *   is changed. This is useful to determine if some documents overlay needs
   *   to be recalculated.
   */
  getLocalViewOfDocuments(t, e, n = pe()) {
    const r = En();
    return this.populateOverlays(t, r, e).next(() => this.computeViews(t, e, r, n).next((s) => {
      let o = Do();
      return s.forEach((a, l) => {
        o = o.insert(a, l.overlayedDocument);
      }), o;
    }));
  }
  /**
   * Gets the overlayed documents for the given document map, which will include
   * the local view of those documents and a `FieldMask` indicating which fields
   * are mutated locally, `null` if overlay is a Set or Delete mutation.
   */
  getOverlayedDocuments(t, e) {
    const n = En();
    return this.populateOverlays(t, n, e).next(() => this.computeViews(t, e, n, pe()));
  }
  /**
   * Fetches the overlays for {@code docs} and adds them to provided overlay map
   * if the map does not already contain an entry for the given document key.
   */
  populateOverlays(t, e, n) {
    const r = [];
    return n.forEach((s) => {
      e.has(s) || r.push(s);
    }), this.documentOverlayCache.getOverlays(t, r).next((s) => {
      s.forEach((o, a) => {
        e.set(o, a);
      });
    });
  }
  /**
   * Computes the local view for the given documents.
   *
   * @param docs - The documents to compute views for. It also has the base
   *   version of the documents.
   * @param overlays - The overlays that need to be applied to the given base
   *   version of the documents.
   * @param existenceStateChanged - A set of documents whose existence states
   *   might have changed. This is used to determine if we need to re-calculate
   *   overlays from mutation queues.
   * @return A map represents the local documents view.
   */
  computeViews(t, e, n, r) {
    let s = xa();
    const o = Ts(), a = function() {
      return Ts();
    }();
    return e.forEach((l, h) => {
      const c = n.get(h.key);
      r.has(h.key) && (c === void 0 || c.mutation instanceof Hn) ? s = s.insert(h.key, h) : c !== void 0 ? (o.set(h.key, c.mutation.getFieldMask()), Es(c.mutation, h, c.mutation.getFieldMask(), te.now())) : (
        // no overlay exists
        // Using EMPTY to indicate there is no overlay for the document.
        o.set(h.key, li.empty())
      );
    }), this.recalculateAndSaveOverlays(t, s).next((l) => (l.forEach((h, c) => o.set(h, c)), e.forEach((h, c) => {
      var p;
      return a.set(h, new zE(c, (p = o.get(h)) !== null && p !== void 0 ? p : null));
    }), a));
  }
  recalculateAndSaveOverlays(t, e) {
    const n = Ts();
    let r = new Ve((o, a) => o - a), s = pe();
    return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(t, e).next((o) => {
      for (const a of o) a.keys().forEach((l) => {
        const h = e.get(l);
        if (h === null) return;
        let c = n.get(l) || li.empty();
        c = a.applyToLocalView(h, c), n.set(l, c);
        const p = (r.get(a.batchId) || pe()).add(l);
        r = r.insert(a.batchId, p);
      });
    }).next(() => {
      const o = [], a = r.getReverseIterator();
      for (; a.hasNext(); ) {
        const l = a.getNext(), h = l.key, c = l.value, p = ky();
        c.forEach((f) => {
          if (!s.has(f)) {
            const d = Fy(e.get(f), n.get(f));
            d !== null && p.set(f, d), s = s.add(f);
          }
        }), o.push(this.documentOverlayCache.saveOverlays(t, h, p));
      }
      return L.waitFor(o);
    }).next(() => n);
  }
  /**
   * Recalculates overlays by reading the documents from remote document cache
   * first, and saves them after they are calculated.
   */
  recalculateAndSaveOverlaysForDocumentKeys(t, e) {
    return this.remoteDocumentCache.getEntries(t, e).next((n) => this.recalculateAndSaveOverlays(t, n));
  }
  /**
   * Performs a query against the local view of all documents.
   *
   * @param transaction - The persistence transaction.
   * @param query - The query to match documents against.
   * @param offset - Read time and key to start scanning by (exclusive).
   * @param context - A optional tracker to keep a record of important details
   *   during database local query execution.
   */
  getDocumentsMatchingQuery(t, e, n, r) {
    return function(o) {
      return et.isDocumentKey(o.path) && o.collectionGroup === null && o.filters.length === 0;
    }(e) ? this.getDocumentsMatchingDocumentQuery(t, e.path) : $T(e) ? this.getDocumentsMatchingCollectionGroupQuery(t, e, n, r) : this.getDocumentsMatchingCollectionQuery(t, e, n, r);
  }
  /**
   * Given a collection group, returns the next documents that follow the provided offset, along
   * with an updated batch ID.
   *
   * <p>The documents returned by this method are ordered by remote version from the provided
   * offset. If there are no more remote documents after the provided offset, documents with
   * mutations in order of batch id from the offset are returned. Since all documents in a batch are
   * returned together, the total number of documents returned can exceed {@code count}.
   *
   * @param transaction
   * @param collectionGroup The collection group for the documents.
   * @param offset The offset to index into.
   * @param count The number of documents to return
   * @return A LocalWriteResult with the documents that follow the provided offset and the last processed batch id.
   */
  getNextDocuments(t, e, n, r) {
    return this.remoteDocumentCache.getAllFromCollectionGroup(t, e, n, r).next((s) => {
      const o = r - s.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(t, e, n.largestBatchId, r - s.size) : L.resolve(En());
      let a = -1, l = s;
      return o.next((h) => L.forEach(h, (c, p) => (a < p.largestBatchId && (a = p.largestBatchId), s.get(c) ? L.resolve() : this.remoteDocumentCache.getEntry(t, c).next((f) => {
        l = l.insert(c, f);
      }))).next(() => this.populateOverlays(t, h, s)).next(() => this.computeViews(t, l, h, pe())).next((c) => ({
        batchId: a,
        changes: Ry(c)
      })));
    });
  }
  getDocumentsMatchingDocumentQuery(t, e) {
    return this.getDocument(t, new et(e)).next((n) => {
      let r = Do();
      return n.isFoundDocument() && (r = r.insert(n.key, n)), r;
    });
  }
  getDocumentsMatchingCollectionGroupQuery(t, e, n, r) {
    const s = e.collectionGroup;
    let o = Do();
    return this.indexManager.getCollectionParents(t, s).next((a) => L.forEach(a, (l) => {
      const h = function(p, f) {
        return new Ga(
          f,
          /*collectionGroup=*/
          null,
          p.explicitOrderBy.slice(),
          p.filters.slice(),
          p.limit,
          p.limitType,
          p.startAt,
          p.endAt
        );
      }(e, l.child(s));
      return this.getDocumentsMatchingCollectionQuery(t, h, n, r).next((c) => {
        c.forEach((p, f) => {
          o = o.insert(p, f);
        });
      });
    }).next(() => o));
  }
  getDocumentsMatchingCollectionQuery(t, e, n, r) {
    let s;
    return this.documentOverlayCache.getOverlaysForCollection(t, e.path, n.largestBatchId).next((o) => (s = o, this.remoteDocumentCache.getDocumentsMatchingQuery(t, e, n, s, r))).next((o) => {
      s.forEach((l, h) => {
        const c = h.getKey();
        o.get(c) === null && (o = o.insert(c, ri.newInvalidDocument(c)));
      });
      let a = Do();
      return o.forEach((l, h) => {
        const c = s.get(l);
        c !== void 0 && Es(c.mutation, h, li.empty(), te.now()), // Finally, insert the documents that still match the query
        nu(e, h) && (a = a.insert(l, h));
      }), a;
    });
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class GE {
  constructor(t) {
    this.serializer = t, this.Tr = /* @__PURE__ */ new Map(), this.Ir = /* @__PURE__ */ new Map();
  }
  getBundleMetadata(t, e) {
    return L.resolve(this.Tr.get(e));
  }
  saveBundleMetadata(t, e) {
    return this.Tr.set(
      e.id,
      /** Decodes a BundleMetadata proto into a BundleMetadata object. */
      function(r) {
        return {
          id: r.id,
          version: r.version,
          createTime: mr(r.createTime)
        };
      }(e)
    ), L.resolve();
  }
  getNamedQuery(t, e) {
    return L.resolve(this.Ir.get(e));
  }
  saveNamedQuery(t, e) {
    return this.Ir.set(e.name, function(r) {
      return {
        name: r.name,
        query: OE(r.bundledQuery),
        readTime: mr(r.readTime)
      };
    }(e)), L.resolve();
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class HE {
  constructor() {
    this.overlays = new Ve(et.comparator), this.Er = /* @__PURE__ */ new Map();
  }
  getOverlay(t, e) {
    return L.resolve(this.overlays.get(e));
  }
  getOverlays(t, e) {
    const n = En();
    return L.forEach(e, (r) => this.getOverlay(t, r).next((s) => {
      s !== null && n.set(r, s);
    })).next(() => n);
  }
  saveOverlays(t, e, n) {
    return n.forEach((r, s) => {
      this.Tt(t, e, s);
    }), L.resolve();
  }
  removeOverlaysForBatchId(t, e, n) {
    const r = this.Er.get(n);
    return r !== void 0 && (r.forEach((s) => this.overlays = this.overlays.remove(s)), this.Er.delete(n)), L.resolve();
  }
  getOverlaysForCollection(t, e, n) {
    const r = En(), s = e.length + 1, o = new et(e.child("")), a = this.overlays.getIteratorFrom(o);
    for (; a.hasNext(); ) {
      const l = a.getNext().value, h = l.getKey();
      if (!e.isPrefixOf(h.path)) break;
      h.path.length === s && l.largestBatchId > n && r.set(l.getKey(), l);
    }
    return L.resolve(r);
  }
  getOverlaysForCollectionGroup(t, e, n, r) {
    let s = new Ve((h, c) => h - c);
    const o = this.overlays.getIterator();
    for (; o.hasNext(); ) {
      const h = o.getNext().value;
      if (h.getKey().getCollectionGroup() === e && h.largestBatchId > n) {
        let c = s.get(h.largestBatchId);
        c === null && (c = En(), s = s.insert(h.largestBatchId, c)), c.set(h.getKey(), h);
      }
    }
    const a = En(), l = s.getIterator();
    for (; l.hasNext() && (l.getNext().value.forEach((h, c) => a.set(h, c)), !(a.size() >= r)); )
      ;
    return L.resolve(a);
  }
  Tt(t, e, n) {
    const r = this.overlays.get(n.key);
    if (r !== null) {
      const o = this.Er.get(r.largestBatchId).delete(n.key);
      this.Er.set(r.largestBatchId, o);
    }
    this.overlays = this.overlays.insert(n.key, new yE(e, n));
    let s = this.Er.get(e);
    s === void 0 && (s = pe(), this.Er.set(e, s)), this.Er.set(e, s.add(n.key));
  }
}
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class WE {
  constructor() {
    this.sessionToken = _i.EMPTY_BYTE_STRING;
  }
  getSessionToken(t) {
    return L.resolve(this.sessionToken);
  }
  setSessionToken(t, e) {
    return this.sessionToken = e, L.resolve();
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ou {
  constructor() {
    this.dr = new le(Qt.Ar), // A set of outstanding references to a document sorted by target id.
    this.Rr = new le(Qt.Vr);
  }
  /** Returns true if the reference set contains no references. */
  isEmpty() {
    return this.dr.isEmpty();
  }
  /** Adds a reference to the given document key for the given ID. */
  addReference(t, e) {
    const n = new Qt(t, e);
    this.dr = this.dr.add(n), this.Rr = this.Rr.add(n);
  }
  /** Add references to the given document keys for the given ID. */
  mr(t, e) {
    t.forEach((n) => this.addReference(n, e));
  }
  /**
   * Removes a reference to the given document key for the given
   * ID.
   */
  removeReference(t, e) {
    this.gr(new Qt(t, e));
  }
  pr(t, e) {
    t.forEach((n) => this.removeReference(n, e));
  }
  /**
   * Clears all references with a given ID. Calls removeRef() for each key
   * removed.
   */
  yr(t) {
    const e = new et(new zt([])), n = new Qt(e, t), r = new Qt(e, t + 1), s = [];
    return this.Rr.forEachInRange([n, r], (o) => {
      this.gr(o), s.push(o.key);
    }), s;
  }
  wr() {
    this.dr.forEach((t) => this.gr(t));
  }
  gr(t) {
    this.dr = this.dr.delete(t), this.Rr = this.Rr.delete(t);
  }
  Sr(t) {
    const e = new et(new zt([])), n = new Qt(e, t), r = new Qt(e, t + 1);
    let s = pe();
    return this.Rr.forEachInRange([n, r], (o) => {
      s = s.add(o.key);
    }), s;
  }
  containsKey(t) {
    const e = new Qt(t, 0), n = this.dr.firstAfterOrEqual(e);
    return n !== null && t.isEqual(n.key);
  }
}
class Qt {
  constructor(t, e) {
    this.key = t, this.br = e;
  }
  /** Compare by key then by ID */
  static Ar(t, e) {
    return et.comparator(t.key, e.key) || ft(t.br, e.br);
  }
  /** Compare by ID then by key */
  static Vr(t, e) {
    return ft(t.br, e.br) || et.comparator(t.key, e.key);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class qE {
  constructor(t, e) {
    this.indexManager = t, this.referenceDelegate = e, /**
     * The set of all mutations that have been sent but not yet been applied to
     * the backend.
     */
    this.mutationQueue = [], /** Next value to use when assigning sequential IDs to each mutation batch. */
    this.Dr = 1, /** An ordered mapping between documents and the mutations batch IDs. */
    this.vr = new le(Qt.Ar);
  }
  checkEmpty(t) {
    return L.resolve(this.mutationQueue.length === 0);
  }
  addMutationBatch(t, e, n, r) {
    const s = this.Dr;
    this.Dr++, this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1];
    const o = new gE(s, e, n, r);
    this.mutationQueue.push(o);
    for (const a of r) this.vr = this.vr.add(new Qt(a.key, s)), this.indexManager.addToCollectionParentIndex(t, a.key.path.popLast());
    return L.resolve(o);
  }
  lookupMutationBatch(t, e) {
    return L.resolve(this.Cr(e));
  }
  getNextMutationBatchAfterBatchId(t, e) {
    const n = e + 1, r = this.Fr(n), s = r < 0 ? 0 : r;
    return L.resolve(this.mutationQueue.length > s ? this.mutationQueue[s] : null);
  }
  getHighestUnacknowledgedBatchId() {
    return L.resolve(this.mutationQueue.length === 0 ? -1 : this.Dr - 1);
  }
  getAllMutationBatches(t) {
    return L.resolve(this.mutationQueue.slice());
  }
  getAllMutationBatchesAffectingDocumentKey(t, e) {
    const n = new Qt(e, 0), r = new Qt(e, Number.POSITIVE_INFINITY), s = [];
    return this.vr.forEachInRange([n, r], (o) => {
      const a = this.Cr(o.br);
      s.push(a);
    }), L.resolve(s);
  }
  getAllMutationBatchesAffectingDocumentKeys(t, e) {
    let n = new le(ft);
    return e.forEach((r) => {
      const s = new Qt(r, 0), o = new Qt(r, Number.POSITIVE_INFINITY);
      this.vr.forEachInRange([s, o], (a) => {
        n = n.add(a.br);
      });
    }), L.resolve(this.Mr(n));
  }
  getAllMutationBatchesAffectingQuery(t, e) {
    const n = e.path, r = n.length + 1;
    let s = n;
    et.isDocumentKey(s) || (s = s.child(""));
    const o = new Qt(new et(s), 0);
    let a = new le(ft);
    return this.vr.forEachWhile((l) => {
      const h = l.key.path;
      return !!n.isPrefixOf(h) && // Rows with document keys more than one segment longer than the query
      // path can't be matches. For example, a query on 'rooms' can't match
      // the document /rooms/abc/messages/xyx.
      // TODO(mcg): we'll need a different scanner when we implement
      // ancestor queries.
      (h.length === r && (a = a.add(l.br)), !0);
    }, o), L.resolve(this.Mr(a));
  }
  Mr(t) {
    const e = [];
    return t.forEach((n) => {
      const r = this.Cr(n);
      r !== null && e.push(r);
    }), e;
  }
  removeMutationBatch(t, e) {
    Bt(this.Or(e.batchId, "removed") === 0), this.mutationQueue.shift();
    let n = this.vr;
    return L.forEach(e.mutations, (r) => {
      const s = new Qt(r.key, e.batchId);
      return n = n.delete(s), this.referenceDelegate.markPotentiallyOrphaned(t, r.key);
    }).next(() => {
      this.vr = n;
    });
  }
  Ln(t) {
  }
  containsKey(t, e) {
    const n = new Qt(e, 0), r = this.vr.firstAfterOrEqual(n);
    return L.resolve(e.isEqual(r && r.key));
  }
  performConsistencyCheck(t) {
    return this.mutationQueue.length, L.resolve();
  }
  /**
   * Finds the index of the given batchId in the mutation queue and asserts that
   * the resulting index is within the bounds of the queue.
   *
   * @param batchId - The batchId to search for
   * @param action - A description of what the caller is doing, phrased in passive
   * form (e.g. "acknowledged" in a routine that acknowledges batches).
   */
  Or(t, e) {
    return this.Fr(t);
  }
  /**
   * Finds the index of the given batchId in the mutation queue. This operation
   * is O(1).
   *
   * @returns The computed index of the batch with the given batchId, based on
   * the state of the queue. Note this index can be negative if the requested
   * batchId has already been removed from the queue or past the end of the
   * queue if the batchId is larger than the last added batch.
   */
  Fr(t) {
    return this.mutationQueue.length === 0 ? 0 : t - this.mutationQueue[0].batchId;
  }
  /**
   * A version of lookupMutationBatch that doesn't return a promise, this makes
   * other functions that uses this code easier to read and more efficient.
   */
  Cr(t) {
    const e = this.Fr(t);
    return e < 0 || e >= this.mutationQueue.length ? null : this.mutationQueue[e];
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class YE {
  /**
   * @param sizer - Used to assess the size of a document. For eager GC, this is
   * expected to just return 0 to avoid unnecessarily doing the work of
   * calculating the size.
   */
  constructor(t) {
    this.Nr = t, /** Underlying cache of documents and their read times. */
    this.docs = function() {
      return new Ve(et.comparator);
    }(), /** Size of all cached documents. */
    this.size = 0;
  }
  setIndexManager(t) {
    this.indexManager = t;
  }
  /**
   * Adds the supplied entry to the cache and updates the cache size as appropriate.
   *
   * All calls of `addEntry`  are required to go through the RemoteDocumentChangeBuffer
   * returned by `newChangeBuffer()`.
   */
  addEntry(t, e) {
    const n = e.key, r = this.docs.get(n), s = r ? r.size : 0, o = this.Nr(e);
    return this.docs = this.docs.insert(n, {
      document: e.mutableCopy(),
      size: o
    }), this.size += o - s, this.indexManager.addToCollectionParentIndex(t, n.path.popLast());
  }
  /**
   * Removes the specified entry from the cache and updates the cache size as appropriate.
   *
   * All calls of `removeEntry` are required to go through the RemoteDocumentChangeBuffer
   * returned by `newChangeBuffer()`.
   */
  removeEntry(t) {
    const e = this.docs.get(t);
    e && (this.docs = this.docs.remove(t), this.size -= e.size);
  }
  getEntry(t, e) {
    const n = this.docs.get(e);
    return L.resolve(n ? n.document.mutableCopy() : ri.newInvalidDocument(e));
  }
  getEntries(t, e) {
    let n = xa();
    return e.forEach((r) => {
      const s = this.docs.get(r);
      n = n.insert(r, s ? s.document.mutableCopy() : ri.newInvalidDocument(r));
    }), L.resolve(n);
  }
  getDocumentsMatchingQuery(t, e, n, r) {
    let s = xa();
    const o = e.path, a = new et(o.child("")), l = this.docs.getIteratorFrom(a);
    for (; l.hasNext(); ) {
      const { key: h, value: { document: c } } = l.getNext();
      if (!o.isPrefixOf(h.path)) break;
      h.path.length > o.length + 1 || IT(PT(c), n) <= 0 || (r.has(c.key) || nu(e, c)) && (s = s.insert(c.key, c.mutableCopy()));
    }
    return L.resolve(s);
  }
  getAllFromCollectionGroup(t, e, n, r) {
    rt();
  }
  Lr(t, e) {
    return L.forEach(this.docs, (n) => e(n));
  }
  newChangeBuffer(t) {
    return new XE(this);
  }
  getSize(t) {
    return L.resolve(this.size);
  }
}
class XE extends UE {
  constructor(t) {
    super(), this.hr = t;
  }
  applyChanges(t) {
    const e = [];
    return this.changes.forEach((n, r) => {
      r.isValidDocument() ? e.push(this.hr.addEntry(t, r)) : this.hr.removeEntry(n);
    }), L.waitFor(e);
  }
  getFromCache(t, e) {
    return this.hr.getEntry(t, e);
  }
  getAllFromCache(t, e) {
    return this.hr.getEntries(t, e);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class KE {
  constructor(t) {
    this.persistence = t, /**
     * Maps a target to the data about that target
     */
    this.Br = new Gn((e) => eu(e), iu), /** The last received snapshot version. */
    this.lastRemoteSnapshotVersion = wt.min(), /** The highest numbered target ID encountered. */
    this.highestTargetId = 0, /** The highest sequence number encountered. */
    this.kr = 0, /**
     * A ordered bidirectional mapping between documents and the remote target
     * IDs.
     */
    this.qr = new ou(), this.targetCount = 0, this.Qr = Ir.qn();
  }
  forEachTarget(t, e) {
    return this.Br.forEach((n, r) => e(r)), L.resolve();
  }
  getLastRemoteSnapshotVersion(t) {
    return L.resolve(this.lastRemoteSnapshotVersion);
  }
  getHighestSequenceNumber(t) {
    return L.resolve(this.kr);
  }
  allocateTargetId(t) {
    return this.highestTargetId = this.Qr.next(), L.resolve(this.highestTargetId);
  }
  setTargetsMetadata(t, e, n) {
    return n && (this.lastRemoteSnapshotVersion = n), e > this.kr && (this.kr = e), L.resolve();
  }
  Un(t) {
    this.Br.set(t.target, t);
    const e = t.targetId;
    e > this.highestTargetId && (this.Qr = new Ir(e), this.highestTargetId = e), t.sequenceNumber > this.kr && (this.kr = t.sequenceNumber);
  }
  addTargetData(t, e) {
    return this.Un(e), this.targetCount += 1, L.resolve();
  }
  updateTargetData(t, e) {
    return this.Un(e), L.resolve();
  }
  removeTargetData(t, e) {
    return this.Br.delete(e.target), this.qr.yr(e.targetId), this.targetCount -= 1, L.resolve();
  }
  removeTargets(t, e, n) {
    let r = 0;
    const s = [];
    return this.Br.forEach((o, a) => {
      a.sequenceNumber <= e && n.get(a.targetId) === null && (this.Br.delete(o), s.push(this.removeMatchingKeysForTargetId(t, a.targetId)), r++);
    }), L.waitFor(s).next(() => r);
  }
  getTargetCount(t) {
    return L.resolve(this.targetCount);
  }
  getTargetData(t, e) {
    const n = this.Br.get(e) || null;
    return L.resolve(n);
  }
  addMatchingKeys(t, e, n) {
    return this.qr.mr(e, n), L.resolve();
  }
  removeMatchingKeys(t, e, n) {
    this.qr.pr(e, n);
    const r = this.persistence.referenceDelegate, s = [];
    return r && e.forEach((o) => {
      s.push(r.markPotentiallyOrphaned(t, o));
    }), L.waitFor(s);
  }
  removeMatchingKeysForTargetId(t, e) {
    return this.qr.yr(e), L.resolve();
  }
  getMatchingKeysForTargetId(t, e) {
    const n = this.qr.Sr(e);
    return L.resolve(n);
  }
  containsKey(t, e) {
    return L.resolve(this.qr.containsKey(e));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class jy {
  /**
   * The constructor accepts a factory for creating a reference delegate. This
   * allows both the delegate and this instance to have strong references to
   * each other without having nullable fields that would then need to be
   * checked or asserted on every access.
   */
  constructor(t, e) {
    this.Kr = {}, this.overlays = {}, this.$r = new Qc(0), this.Ur = !1, this.Ur = !0, this.Wr = new WE(), this.referenceDelegate = t(this), this.Gr = new KE(this), this.indexManager = new DE(), this.remoteDocumentCache = function(r) {
      return new YE(r);
    }((n) => this.referenceDelegate.zr(n)), this.serializer = new ME(e), this.jr = new GE(this.serializer);
  }
  start() {
    return Promise.resolve();
  }
  shutdown() {
    return this.Ur = !1, Promise.resolve();
  }
  get started() {
    return this.Ur;
  }
  setDatabaseDeletedListener() {
  }
  setNetworkEnabled() {
  }
  getIndexManager(t) {
    return this.indexManager;
  }
  getDocumentOverlayCache(t) {
    let e = this.overlays[t.toKey()];
    return e || (e = new HE(), this.overlays[t.toKey()] = e), e;
  }
  getMutationQueue(t, e) {
    let n = this.Kr[t.toKey()];
    return n || (n = new qE(e, this.referenceDelegate), this.Kr[t.toKey()] = n), n;
  }
  getGlobalsCache() {
    return this.Wr;
  }
  getTargetCache() {
    return this.Gr;
  }
  getRemoteDocumentCache() {
    return this.remoteDocumentCache;
  }
  getBundleCache() {
    return this.jr;
  }
  runTransaction(t, e, n) {
    q("MemoryPersistence", "Starting transaction:", t);
    const r = new QE(this.$r.next());
    return this.referenceDelegate.Hr(), n(r).next((s) => this.referenceDelegate.Jr(r).next(() => s)).toPromise().then((s) => (r.raiseOnCommittedEvent(), s));
  }
  Yr(t, e) {
    return L.or(Object.values(this.Kr).map((n) => () => n.containsKey(t, e)));
  }
}
class QE extends kT {
  constructor(t) {
    super(), this.currentSequenceNumber = t;
  }
}
class au {
  constructor(t) {
    this.persistence = t, /** Tracks all documents that are active in Query views. */
    this.Zr = new ou(), /** The list of documents that are potentially GCed after each transaction. */
    this.Xr = null;
  }
  static ei(t) {
    return new au(t);
  }
  get ti() {
    if (this.Xr) return this.Xr;
    throw rt();
  }
  addReference(t, e, n) {
    return this.Zr.addReference(n, e), this.ti.delete(n.toString()), L.resolve();
  }
  removeReference(t, e, n) {
    return this.Zr.removeReference(n, e), this.ti.add(n.toString()), L.resolve();
  }
  markPotentiallyOrphaned(t, e) {
    return this.ti.add(e.toString()), L.resolve();
  }
  removeTarget(t, e) {
    this.Zr.yr(e.targetId).forEach((r) => this.ti.add(r.toString()));
    const n = this.persistence.getTargetCache();
    return n.getMatchingKeysForTargetId(t, e.targetId).next((r) => {
      r.forEach((s) => this.ti.add(s.toString()));
    }).next(() => n.removeTargetData(t, e));
  }
  Hr() {
    this.Xr = /* @__PURE__ */ new Set();
  }
  Jr(t) {
    const e = this.persistence.getRemoteDocumentCache().newChangeBuffer();
    return L.forEach(this.ti, (n) => {
      const r = et.fromPath(n);
      return this.ni(t, r).next((s) => {
        s || e.removeEntry(r, wt.min());
      });
    }).next(() => (this.Xr = null, e.apply(t)));
  }
  updateLimboDocument(t, e) {
    return this.ni(t, e).next((n) => {
      n ? this.ti.delete(e.toString()) : this.ti.add(e.toString());
    });
  }
  zr(t) {
    return 0;
  }
  ni(t, e) {
    return L.or([() => L.resolve(this.Zr.containsKey(e)), () => this.persistence.getTargetCache().containsKey(t, e), () => this.persistence.Yr(t, e)]);
  }
}
class Aa {
  constructor(t, e) {
    this.persistence = t, this.ri = new Gn((n) => DT(n.path), (n, r) => n.isEqual(r)), this.garbageCollector = NE(this, e);
  }
  static ei(t, e) {
    return new Aa(t, e);
  }
  // No-ops, present so memory persistence doesn't have to care which delegate
  // it has.
  Hr() {
  }
  Jr(t) {
    return L.resolve();
  }
  forEachTarget(t, e) {
    return this.persistence.getTargetCache().forEachTarget(t, e);
  }
  Xn(t) {
    const e = this.nr(t);
    return this.persistence.getTargetCache().getTargetCount(t).next((n) => e.next((r) => n + r));
  }
  nr(t) {
    let e = 0;
    return this.er(t, (n) => {
      e++;
    }).next(() => e);
  }
  er(t, e) {
    return L.forEach(this.ri, (n, r) => this.ir(t, n, r).next((s) => s ? L.resolve() : e(r)));
  }
  removeTargets(t, e, n) {
    return this.persistence.getTargetCache().removeTargets(t, e, n);
  }
  removeOrphanedDocuments(t, e) {
    let n = 0;
    const r = this.persistence.getRemoteDocumentCache(), s = r.newChangeBuffer();
    return r.Lr(t, (o) => this.ir(t, o, e).next((a) => {
      a || (n++, s.removeEntry(o, wt.min()));
    })).next(() => s.apply(t)).next(() => n);
  }
  markPotentiallyOrphaned(t, e) {
    return this.ri.set(e, t.currentSequenceNumber), L.resolve();
  }
  removeTarget(t, e) {
    const n = e.withSequenceNumber(t.currentSequenceNumber);
    return this.persistence.getTargetCache().updateTargetData(t, n);
  }
  addReference(t, e, n) {
    return this.ri.set(n, t.currentSequenceNumber), L.resolve();
  }
  removeReference(t, e, n) {
    return this.ri.set(n, t.currentSequenceNumber), L.resolve();
  }
  updateLimboDocument(t, e) {
    return this.ri.set(e, t.currentSequenceNumber), L.resolve();
  }
  zr(t) {
    let e = t.key.toString().length;
    return t.isFoundDocument() && (e += Wo(t.data.value)), e;
  }
  ir(t, e, n) {
    return L.or([() => this.persistence.Yr(t, e), () => this.persistence.getTargetCache().containsKey(t, e), () => {
      const r = this.ri.get(e);
      return L.resolve(r !== void 0 && r > n);
    }]);
  }
  getCacheSize(t) {
    return this.persistence.getRemoteDocumentCache().getSize(t);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class lu {
  constructor(t, e, n, r) {
    this.targetId = t, this.fromCache = e, this.Wi = n, this.Gi = r;
  }
  static zi(t, e) {
    let n = pe(), r = pe();
    for (const s of e.docChanges) switch (s.type) {
      case 0:
        n = n.add(s.doc.key);
        break;
      case 1:
        r = r.add(s.doc.key);
    }
    return new lu(t, e.fromCache, n, r);
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class JE {
  constructor() {
    this._documentReadCount = 0;
  }
  get documentReadCount() {
    return this._documentReadCount;
  }
  incrementDocumentReadCount(t) {
    this._documentReadCount += t;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ZE {
  constructor() {
    this.ji = !1, this.Hi = !1, /**
     * SDK only decides whether it should create index when collection size is
     * larger than this.
     */
    this.Ji = 100, this.Yi = /**
    * This cost represents the evaluation result of
    * (([index, docKey] + [docKey, docContent]) per document in the result set)
    * / ([docKey, docContent] per documents in full collection scan) coming from
    * experiment [enter PR experiment URL here].
    */
    function() {
      return tS() ? 8 : MT(ZA()) > 0 ? 6 : 4;
    }();
  }
  /** Sets the document view to query against. */
  initialize(t, e) {
    this.Zi = t, this.indexManager = e, this.ji = !0;
  }
  /** Returns all local documents matching the specified query. */
  getDocumentsMatchingQuery(t, e, n, r) {
    const s = {
      result: null
    };
    return this.Xi(t, e).next((o) => {
      s.result = o;
    }).next(() => {
      if (!s.result) return this.es(t, e, r, n).next((o) => {
        s.result = o;
      });
    }).next(() => {
      if (s.result) return;
      const o = new JE();
      return this.ts(t, e, o).next((a) => {
        if (s.result = a, this.Hi) return this.ns(t, e, o, a.size);
      });
    }).next(() => s.result);
  }
  ns(t, e, n, r) {
    return n.documentReadCount < this.Ji ? (ir() <= at.DEBUG && q("QueryEngine", "SDK will not create cache indexes for query:", ss(e), "since it only creates cache indexes for collection contains", "more than or equal to", this.Ji, "documents"), L.resolve()) : (ir() <= at.DEBUG && q("QueryEngine", "Query:", ss(e), "scans", n.documentReadCount, "local documents and returns", r, "documents as results."), n.documentReadCount > this.Yi * r ? (ir() <= at.DEBUG && q("QueryEngine", "The SDK decides to create cache indexes for query:", ss(e), "as using cache indexes may help improve performance."), this.indexManager.createTargetIndexes(t, Mn(e))) : L.resolve());
  }
  /**
   * Performs an indexed query that evaluates the query based on a collection's
   * persisted index values. Returns `null` if an index is not available.
   */
  Xi(t, e) {
    if (Kp(e))
      return L.resolve(null);
    let n = Mn(e);
    return this.indexManager.getIndexType(t, n).next((r) => r === 0 ? null : (e.limit !== null && r === 1 && // We cannot apply a limit for targets that are served using a partial
    // index. If a partial index will be used to serve the target, the
    // query may return a superset of documents that match the target
    // (e.g. if the index doesn't include all the target's filters), or
    // may return the correct set of documents in the wrong order (e.g. if
    // the index doesn't include a segment for one of the orderBys).
    // Therefore, a limit should not be applied in such cases.
    (e = nc(
      e,
      null,
      "F"
      /* LimitType.First */
    ), n = Mn(e)), this.indexManager.getDocumentsMatchingTarget(t, n).next((s) => {
      const o = pe(...s);
      return this.Zi.getDocuments(t, o).next((a) => this.indexManager.getMinOffset(t, n).next((l) => {
        const h = this.rs(e, a);
        return this.ss(e, h, o, l.readTime) ? this.Xi(t, nc(
          e,
          null,
          "F"
          /* LimitType.First */
        )) : this.os(t, h, e, l);
      }));
    })));
  }
  /**
   * Performs a query based on the target's persisted query mapping. Returns
   * `null` if the mapping is not available or cannot be used.
   */
  es(t, e, n, r) {
    return Kp(e) || r.isEqual(wt.min()) ? L.resolve(null) : this.Zi.getDocuments(t, n).next((s) => {
      const o = this.rs(e, s);
      return this.ss(e, o, n, r) ? L.resolve(null) : (ir() <= at.DEBUG && q("QueryEngine", "Re-using previous result from %s to execute query: %s", r.toString(), ss(e)), this.os(t, o, e, CT(r, -1)).next((a) => a));
    });
  }
  /** Applies the query filter and sorting to the provided documents.  */
  rs(t, e) {
    let n = new le(eE(t));
    return e.forEach((r, s) => {
      nu(t, s) && (n = n.add(s));
    }), n;
  }
  /**
   * Determines if a limit query needs to be refilled from cache, making it
   * ineligible for index-free execution.
   *
   * @param query - The query.
   * @param sortedPreviousResults - The documents that matched the query when it
   * was last synchronized, sorted by the query's comparator.
   * @param remoteKeys - The document keys that matched the query at the last
   * snapshot.
   * @param limboFreeSnapshotVersion - The version of the snapshot when the
   * query was last synchronized.
   */
  ss(t, e, n, r) {
    if (t.limit === null)
      return !1;
    if (n.size !== e.size)
      return !0;
    const s = t.limitType === "F" ? e.last() : e.first();
    return !!s && (s.hasPendingWrites || s.version.compareTo(r) > 0);
  }
  ts(t, e, n) {
    return ir() <= at.DEBUG && q("QueryEngine", "Using full collection scan to execute query:", ss(e)), this.Zi.getDocumentsMatchingQuery(t, e, tn.min(), n);
  }
  /**
   * Combines the results from an indexed execution with the remaining documents
   * that have not yet been indexed.
   */
  os(t, e, n, r) {
    return this.Zi.getDocumentsMatchingQuery(t, n, r).next((s) => (
      // Merge with existing results
      (e.forEach((o) => {
        s = s.insert(o.key, o);
      }), s)
    ));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class $E {
  constructor(t, e, n, r) {
    this.persistence = t, this._s = e, this.serializer = r, /**
     * Maps a targetID to data about its target.
     *
     * PORTING NOTE: We are using an immutable data structure on Web to make re-runs
     * of `applyRemoteEvent()` idempotent.
     */
    this.us = new Ve(ft), /** Maps a target to its targetID. */
    // TODO(wuandy): Evaluate if TargetId can be part of Target.
    this.cs = new Gn((s) => eu(s), iu), /**
     * A per collection group index of the last read time processed by
     * `getNewDocumentChanges()`.
     *
     * PORTING NOTE: This is only used for multi-tab synchronization.
     */
    this.ls = /* @__PURE__ */ new Map(), this.hs = t.getRemoteDocumentCache(), this.Gr = t.getTargetCache(), this.jr = t.getBundleCache(), this.Ps(n);
  }
  Ps(t) {
    this.documentOverlayCache = this.persistence.getDocumentOverlayCache(t), this.indexManager = this.persistence.getIndexManager(t), this.mutationQueue = this.persistence.getMutationQueue(t, this.indexManager), this.localDocuments = new jE(this.hs, this.mutationQueue, this.documentOverlayCache, this.indexManager), this.hs.setIndexManager(this.indexManager), this._s.initialize(this.localDocuments, this.indexManager);
  }
  collectGarbage(t) {
    return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (e) => t.collect(e, this.us));
  }
}
function tC(i, t, e, n) {
  return new $E(i, t, e, n);
}
async function Gy(i, t) {
  const e = _t(i);
  return await e.persistence.runTransaction("Handle user change", "readonly", (n) => {
    let r;
    return e.mutationQueue.getAllMutationBatches(n).next((s) => (r = s, e.Ps(t), e.mutationQueue.getAllMutationBatches(n))).next((s) => {
      const o = [], a = [];
      let l = pe();
      for (const h of r) {
        o.push(h.batchId);
        for (const c of h.mutations) l = l.add(c.key);
      }
      for (const h of s) {
        a.push(h.batchId);
        for (const c of h.mutations) l = l.add(c.key);
      }
      return e.localDocuments.getDocuments(n, l).next((h) => ({
        Ts: h,
        removedBatchIds: o,
        addedBatchIds: a
      }));
    });
  });
}
function eC(i, t) {
  const e = _t(i);
  return e.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (n) => {
    const r = t.batch.keys(), s = e.hs.newChangeBuffer({
      trackRemovals: !0
    });
    return function(a, l, h, c) {
      const p = h.batch, f = p.keys();
      let d = L.resolve();
      return f.forEach((m) => {
        d = d.next(() => c.getEntry(l, m)).next((g) => {
          const y = h.docVersions.get(m);
          Bt(y !== null), g.version.compareTo(y) < 0 && (p.applyToRemoteDocument(g, h), g.isValidDocument() && // We use the commitVersion as the readTime rather than the
          // document's updateTime since the updateTime is not advanced
          // for updates that do not modify the underlying document.
          (g.setReadTime(h.commitVersion), c.addEntry(g)));
        });
      }), d.next(() => a.mutationQueue.removeMutationBatch(l, p));
    }(e, n, t, s).next(() => s.apply(n)).next(() => e.mutationQueue.performConsistencyCheck(n)).next(() => e.documentOverlayCache.removeOverlaysForBatchId(n, r, t.batch.batchId)).next(() => e.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(n, function(a) {
      let l = pe();
      for (let h = 0; h < a.mutationResults.length; ++h)
        a.mutationResults[h].transformResults.length > 0 && (l = l.add(a.batch.mutations[h].key));
      return l;
    }(t))).next(() => e.localDocuments.getDocuments(n, r));
  });
}
function iC(i) {
  const t = _t(i);
  return t.persistence.runTransaction("Get last remote snapshot version", "readonly", (e) => t.Gr.getLastRemoteSnapshotVersion(e));
}
function nC(i, t) {
  const e = _t(i);
  return e.persistence.runTransaction("Get next mutation batch", "readonly", (n) => (t === void 0 && (t = -1), e.mutationQueue.getNextMutationBatchAfterBatchId(n, t)));
}
class rf {
  constructor() {
    this.activeTargetIds = aE();
  }
  ps(t) {
    this.activeTargetIds = this.activeTargetIds.add(t);
  }
  ys(t) {
    this.activeTargetIds = this.activeTargetIds.delete(t);
  }
  /**
   * Converts this entry into a JSON-encoded format we can use for WebStorage.
   * Does not encode `clientId` as it is part of the key in WebStorage.
   */
  gs() {
    const t = {
      activeTargetIds: this.activeTargetIds.toArray(),
      updateTimeMs: Date.now()
    };
    return JSON.stringify(t);
  }
}
class rC {
  constructor() {
    this._o = new rf(), this.ao = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
  }
  addPendingMutation(t) {
  }
  updateMutationState(t, e, n) {
  }
  addLocalQueryTarget(t, e = !0) {
    return e && this._o.ps(t), this.ao[t] || "not-current";
  }
  updateQueryState(t, e, n) {
    this.ao[t] = e;
  }
  removeLocalQueryTarget(t) {
    this._o.ys(t);
  }
  isLocalQueryTarget(t) {
    return this._o.activeTargetIds.has(t);
  }
  clearQueryState(t) {
    delete this.ao[t];
  }
  getAllActiveQueryTargets() {
    return this._o.activeTargetIds;
  }
  isActiveQueryTarget(t) {
    return this._o.activeTargetIds.has(t);
  }
  start() {
    return this._o = new rf(), Promise.resolve();
  }
  handleUserChange(t, e, n) {
  }
  setOnlineState(t) {
  }
  shutdown() {
  }
  writeSequenceNumber(t) {
  }
  notifyBundleLoaded(t) {
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class sC {
  uo(t) {
  }
  shutdown() {
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class sf {
  constructor() {
    this.co = () => this.lo(), this.ho = () => this.Po(), this.To = [], this.Io();
  }
  uo(t) {
    this.To.push(t);
  }
  shutdown() {
    window.removeEventListener("online", this.co), window.removeEventListener("offline", this.ho);
  }
  Io() {
    window.addEventListener("online", this.co), window.addEventListener("offline", this.ho);
  }
  lo() {
    q("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
    for (const t of this.To) t(
      0
      /* NetworkStatus.AVAILABLE */
    );
  }
  Po() {
    q("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
    for (const t of this.To) t(
      1
      /* NetworkStatus.UNAVAILABLE */
    );
  }
  // TODO(chenbrian): Consider passing in window either into this component or
  // here for testing via FakeWindow.
  /** Checks that all used attributes of window are available. */
  static p() {
    return typeof window < "u" && window.addEventListener !== void 0 && window.removeEventListener !== void 0;
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let Bo = null;
function eh() {
  return Bo === null ? Bo = function() {
    return 268435456 + Math.round(2147483648 * Math.random());
  }() : Bo++, "0x" + Bo.toString(16);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const oC = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery",
  RunAggregationQuery: "runAggregationQuery"
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class aC {
  constructor(t) {
    this.Eo = t.Eo, this.Ao = t.Ao;
  }
  Ro(t) {
    this.Vo = t;
  }
  mo(t) {
    this.fo = t;
  }
  po(t) {
    this.yo = t;
  }
  onMessage(t) {
    this.wo = t;
  }
  close() {
    this.Ao();
  }
  send(t) {
    this.Eo(t);
  }
  So() {
    this.Vo();
  }
  bo() {
    this.fo();
  }
  Do(t) {
    this.yo(t);
  }
  vo(t) {
    this.wo(t);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ue = "WebChannelConnection";
class lC extends /**
 * Base class for all Rest-based connections to the backend (WebChannel and
 * HTTP).
 */
class {
  get Co() {
    return !1;
  }
  constructor(e) {
    this.databaseInfo = e, this.databaseId = e.databaseId;
    const n = e.ssl ? "https" : "http", r = encodeURIComponent(this.databaseId.projectId), s = encodeURIComponent(this.databaseId.database);
    this.Fo = n + "://" + e.host, this.Mo = `projects/${r}/databases/${s}`, this.xo = this.databaseId.database === "(default)" ? `project_id=${r}` : `project_id=${r}&database_id=${s}`;
  }
  Oo(e, n, r, s, o) {
    const a = eh(), l = this.No(e, n.toUriEncodedString());
    q("RestConnection", `Sending RPC '${e}' ${a}:`, l, r);
    const h = {
      "google-cloud-resource-prefix": this.Mo,
      "x-goog-request-params": this.xo
    };
    return this.Lo(h, s, o), this.Bo(e, l, h, r).then((c) => (q("RestConnection", `Received RPC '${e}' ${a}: `, c), c), (c) => {
      throw fa("RestConnection", `RPC '${e}' ${a} failed with error: `, c, "url: ", l, "request:", r), c;
    });
  }
  ko(e, n, r, s, o, a) {
    return this.Oo(e, n, r, s, o);
  }
  /**
   * Modifies the headers for a request, adding any authorization token if
   * present and any additional headers for the request.
   */
  Lo(e, n, r) {
    e["X-Goog-Api-Client"] = // SDK_VERSION is updated to different value at runtime depending on the entry point,
    // so we need to get its value when we need it in a function.
    function() {
      return "gl-js/ fire/" + Fr;
    }(), // Content-Type: text/plain will avoid preflight requests which might
    // mess with CORS and redirects by proxies. If we add custom headers
    // we will need to change this code to potentially use the $httpOverwrite
    // parameter supported by ESF to avoid triggering preflight requests.
    e["Content-Type"] = "text/plain", this.databaseInfo.appId && (e["X-Firebase-GMPID"] = this.databaseInfo.appId), n && n.headers.forEach((s, o) => e[o] = s), r && r.headers.forEach((s, o) => e[o] = s);
  }
  No(e, n) {
    const r = oC[e];
    return `${this.Fo}/v1/${n}:${r}`;
  }
  /**
   * Closes and cleans up any resources associated with the connection. This
   * implementation is a no-op because there are no resources associated
   * with the RestConnection that need to be cleaned up.
   */
  terminate() {
  }
} {
  constructor(t) {
    super(t), this.forceLongPolling = t.forceLongPolling, this.autoDetectLongPolling = t.autoDetectLongPolling, this.useFetchStreams = t.useFetchStreams, this.longPollingOptions = t.longPollingOptions;
  }
  Bo(t, e, n, r) {
    const s = eh();
    return new Promise((o, a) => {
      const l = new dy();
      l.setWithCredentials(!0), l.listenOnce(py.COMPLETE, () => {
        try {
          switch (l.getLastErrorCode()) {
            case Ho.NO_ERROR:
              const c = l.getResponseJson();
              q(ue, `XHR for RPC '${t}' ${s} received:`, JSON.stringify(c)), o(c);
              break;
            case Ho.TIMEOUT:
              q(ue, `RPC '${t}' ${s} timed out`), a(new Z(z.DEADLINE_EXCEEDED, "Request time out"));
              break;
            case Ho.HTTP_ERROR:
              const p = l.getStatus();
              if (q(ue, `RPC '${t}' ${s} failed with status:`, p, "response text:", l.getResponseText()), p > 0) {
                let f = l.getResponseJson();
                Array.isArray(f) && (f = f[0]);
                const d = f == null ? void 0 : f.error;
                if (d && d.status && d.message) {
                  const m = function(y) {
                    const b = y.toLowerCase().replace(/_/g, "-");
                    return Object.values(z).indexOf(b) >= 0 ? b : z.UNKNOWN;
                  }(d.status);
                  a(new Z(m, d.message));
                } else a(new Z(z.UNKNOWN, "Server responded with status " + l.getStatus()));
              } else
                a(new Z(z.UNAVAILABLE, "Connection failed."));
              break;
            default:
              rt();
          }
        } finally {
          q(ue, `RPC '${t}' ${s} completed.`);
        }
      });
      const h = JSON.stringify(r);
      q(ue, `RPC '${t}' ${s} sending request:`, r), l.send(e, "POST", h, n, 15);
    });
  }
  qo(t, e, n) {
    const r = eh(), s = [this.Fo, "/", "google.firestore.v1.Firestore", "/", t, "/channel"], o = gy(), a = my(), l = {
      // Required for backend stickiness, routing behavior is based on this
      // parameter.
      httpSessionIdParam: "gsessionid",
      initMessageHeaders: {},
      messageUrlParams: {
        // This param is used to improve routing and project isolation by the
        // backend and must be included in every request.
        database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
      },
      sendRawJson: !0,
      supportsCrossDomainXhr: !0,
      internalChannelParams: {
        // Override the default timeout (randomized between 10-20 seconds) since
        // a large write batch on a slow internet connection may take a long
        // time to send to the backend. Rather than have WebChannel impose a
        // tight timeout which could lead to infinite timeouts and retries, we
        // set it very large (5-10 minutes) and rely on the browser's builtin
        // timeouts to kick in if the request isn't working.
        forwardChannelRequestTimeoutMs: 6e5
      },
      forceLongPolling: this.forceLongPolling,
      detectBufferingProxy: this.autoDetectLongPolling
    }, h = this.longPollingOptions.timeoutSeconds;
    h !== void 0 && (l.longPollingTimeout = Math.round(1e3 * h)), this.useFetchStreams && (l.useFetchStreams = !0), this.Lo(l.initMessageHeaders, e, n), // Sending the custom headers we just added to request.initMessageHeaders
    // (Authorization, etc.) will trigger the browser to make a CORS preflight
    // request because the XHR will no longer meet the criteria for a "simple"
    // CORS request:
    // https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Simple_requests
    // Therefore to avoid the CORS preflight request (an extra network
    // roundtrip), we use the encodeInitMessageHeaders option to specify that
    // the headers should instead be encoded in the request's POST payload,
    // which is recognized by the webchannel backend.
    l.encodeInitMessageHeaders = !0;
    const c = s.join("");
    q(ue, `Creating RPC '${t}' stream ${r}: ${c}`, l);
    const p = o.createWebChannel(c, l);
    let f = !1, d = !1;
    const m = new aC({
      Eo: (y) => {
        d ? q(ue, `Not sending because RPC '${t}' stream ${r} is closed:`, y) : (f || (q(ue, `Opening RPC '${t}' stream ${r} transport.`), p.open(), f = !0), q(ue, `RPC '${t}' stream ${r} sending:`, y), p.send(y));
      },
      Ao: () => p.close()
    }), g = (y, b, S) => {
      y.listen(b, (C) => {
        try {
          S(C);
        } catch (I) {
          setTimeout(() => {
            throw I;
          }, 0);
        }
      });
    };
    return g(p, ms.EventType.OPEN, () => {
      d || (q(ue, `RPC '${t}' stream ${r} transport opened.`), m.So());
    }), g(p, ms.EventType.CLOSE, () => {
      d || (d = !0, q(ue, `RPC '${t}' stream ${r} transport closed`), m.Do());
    }), g(p, ms.EventType.ERROR, (y) => {
      d || (d = !0, fa(ue, `RPC '${t}' stream ${r} transport errored:`, y), m.Do(new Z(z.UNAVAILABLE, "The operation could not be completed")));
    }), g(p, ms.EventType.MESSAGE, (y) => {
      var b;
      if (!d) {
        const S = y.data[0];
        Bt(!!S);
        const C = S, I = (C == null ? void 0 : C.error) || ((b = C[0]) === null || b === void 0 ? void 0 : b.error);
        if (I) {
          q(ue, `RPC '${t}' stream ${r} received error:`, I);
          const T = I.status;
          let R = (
            /**
            * Maps an error Code from a GRPC status identifier like 'NOT_FOUND'.
            *
            * @returns The Code equivalent to the given status string or undefined if
            *     there is no match.
            */
            function(x) {
              const A = Nt[x];
              if (A !== void 0) return _E(A);
            }(T)
          ), w = I.message;
          R === void 0 && (R = z.INTERNAL, w = "Unknown error status: " + T + " with message " + I.message), // Mark closed so no further events are propagated
          d = !0, m.Do(new Z(R, w)), p.close();
        } else q(ue, `RPC '${t}' stream ${r} received:`, S), m.vo(S);
      }
    }), g(a, fy.STAT_EVENT, (y) => {
      y.stat === $h.PROXY ? q(ue, `RPC '${t}' stream ${r} detected buffering proxy`) : y.stat === $h.NOPROXY && q(ue, `RPC '${t}' stream ${r} detected no buffering proxy`);
    }), setTimeout(() => {
      m.bo();
    }, 0), m;
  }
}
function ih() {
  return typeof document < "u" ? document : null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function qa(i) {
  return new xE(
    i,
    /* useProto3Json= */
    !0
  );
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Hy {
  constructor(t, e, n = 1e3, r = 1.5, s = 6e4) {
    this.li = t, this.timerId = e, this.Qo = n, this.Ko = r, this.$o = s, this.Uo = 0, this.Wo = null, /** The last backoff attempt, as epoch milliseconds. */
    this.Go = Date.now(), this.reset();
  }
  /**
   * Resets the backoff delay.
   *
   * The very next backoffAndWait() will have no delay. If it is called again
   * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and
   * subsequent ones will increase according to the backoffFactor.
   */
  reset() {
    this.Uo = 0;
  }
  /**
   * Resets the backoff delay to the maximum delay (e.g. for use after a
   * RESOURCE_EXHAUSTED error).
   */
  zo() {
    this.Uo = this.$o;
  }
  /**
   * Returns a promise that resolves after currentDelayMs, and increases the
   * delay for any subsequent attempts. If there was a pending backoff operation
   * already, it will be canceled.
   */
  jo(t) {
    this.cancel();
    const e = Math.floor(this.Uo + this.Ho()), n = Math.max(0, Date.now() - this.Go), r = Math.max(0, e - n);
    r > 0 && q("ExponentialBackoff", `Backing off for ${r} ms (base delay: ${this.Uo} ms, delay with jitter: ${e} ms, last attempt: ${n} ms ago)`), this.Wo = this.li.enqueueAfterDelay(this.timerId, r, () => (this.Go = Date.now(), t())), // Apply backoff factor to determine next delay and ensure it is within
    // bounds.
    this.Uo *= this.Ko, this.Uo < this.Qo && (this.Uo = this.Qo), this.Uo > this.$o && (this.Uo = this.$o);
  }
  Jo() {
    this.Wo !== null && (this.Wo.skipDelay(), this.Wo = null);
  }
  cancel() {
    this.Wo !== null && (this.Wo.cancel(), this.Wo = null);
  }
  /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */
  Ho() {
    return (Math.random() - 0.5) * this.Uo;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class hC {
  constructor(t, e, n, r, s, o, a, l) {
    this.li = t, this.Yo = n, this.Zo = r, this.connection = s, this.authCredentialsProvider = o, this.appCheckCredentialsProvider = a, this.listener = l, this.state = 0, /**
     * A close count that's incremented every time the stream is closed; used by
     * getCloseGuardedDispatcher() to invalidate callbacks that happen after
     * close.
     */
    this.Xo = 0, this.e_ = null, this.t_ = null, this.stream = null, /**
     * Count of response messages received.
     */
    this.n_ = 0, this.r_ = new Hy(t, e);
  }
  /**
   * Returns true if start() has been called and no error has occurred. True
   * indicates the stream is open or in the process of opening (which
   * encompasses respecting backoff, getting auth tokens, and starting the
   * actual RPC). Use isOpen() to determine if the stream is open and ready for
   * outbound requests.
   */
  i_() {
    return this.state === 1 || this.state === 5 || this.s_();
  }
  /**
   * Returns true if the underlying RPC is open (the onOpen() listener has been
   * called) and the stream is ready for outbound requests.
   */
  s_() {
    return this.state === 2 || this.state === 3;
  }
  /**
   * Starts the RPC. Only allowed if isStarted() returns false. The stream is
   * not immediately ready for use: onOpen() will be invoked when the RPC is
   * ready for outbound requests, at which point isOpen() will return true.
   *
   * When start returns, isStarted() will return true.
   */
  start() {
    this.n_ = 0, this.state !== 4 ? this.auth() : this.o_();
  }
  /**
   * Stops the RPC. This call is idempotent and allowed regardless of the
   * current isStarted() state.
   *
   * When stop returns, isStarted() and isOpen() will both return false.
   */
  async stop() {
    this.i_() && await this.close(
      0
      /* PersistentStreamState.Initial */
    );
  }
  /**
   * After an error the stream will usually back off on the next attempt to
   * start it. If the error warrants an immediate restart of the stream, the
   * sender can use this to indicate that the receiver should not back off.
   *
   * Each error will call the onClose() listener. That function can decide to
   * inhibit backoff if required.
   */
  __() {
    this.state = 0, this.r_.reset();
  }
  /**
   * Marks this stream as idle. If no further actions are performed on the
   * stream for one minute, the stream will automatically close itself and
   * notify the stream's onClose() handler with Status.OK. The stream will then
   * be in a !isStarted() state, requiring the caller to start the stream again
   * before further use.
   *
   * Only streams that are in state 'Open' can be marked idle, as all other
   * states imply pending network operations.
   */
  a_() {
    this.s_() && this.e_ === null && (this.e_ = this.li.enqueueAfterDelay(this.Yo, 6e4, () => this.u_()));
  }
  /** Sends a message to the underlying stream. */
  c_(t) {
    this.l_(), this.stream.send(t);
  }
  /** Called by the idle timer when the stream should close due to inactivity. */
  async u_() {
    if (this.s_())
      return this.close(
        0
        /* PersistentStreamState.Initial */
      );
  }
  /** Marks the stream as active again. */
  l_() {
    this.e_ && (this.e_.cancel(), this.e_ = null);
  }
  /** Cancels the health check delayed operation. */
  h_() {
    this.t_ && (this.t_.cancel(), this.t_ = null);
  }
  /**
   * Closes the stream and cleans up as necessary:
   *
   * * closes the underlying GRPC stream;
   * * calls the onClose handler with the given 'error';
   * * sets internal stream state to 'finalState';
   * * adjusts the backoff timer based on the error
   *
   * A new stream can be opened by calling start().
   *
   * @param finalState - the intended state of the stream after closing.
   * @param error - the error the connection was closed with.
   */
  async close(t, e) {
    this.l_(), this.h_(), this.r_.cancel(), // Invalidates any stream-related callbacks (e.g. from auth or the
    // underlying stream), guaranteeing they won't execute.
    this.Xo++, t !== 4 ? (
      // If this is an intentional close ensure we don't delay our next connection attempt.
      this.r_.reset()
    ) : e && e.code === z.RESOURCE_EXHAUSTED ? (
      // Log the error. (Probably either 'quota exceeded' or 'max queue length reached'.)
      (Ln(e.toString()), Ln("Using maximum backoff delay to prevent overloading the backend."), this.r_.zo())
    ) : e && e.code === z.UNAUTHENTICATED && this.state !== 3 && // "unauthenticated" error means the token was rejected. This should rarely
    // happen since both Auth and AppCheck ensure a sufficient TTL when we
    // request a token. If a user manually resets their system clock this can
    // fail, however. In this case, we should get a Code.UNAUTHENTICATED error
    // before we received the first message and we need to invalidate the token
    // to ensure that we fetch a new token.
    (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), // Clean up the underlying stream because we are no longer interested in events.
    this.stream !== null && (this.P_(), this.stream.close(), this.stream = null), // This state must be assigned before calling onClose() to allow the callback to
    // inhibit backoff or otherwise manipulate the state in its non-started state.
    this.state = t, // Notify the listener that the stream closed.
    await this.listener.po(e);
  }
  /**
   * Can be overridden to perform additional cleanup before the stream is closed.
   * Calling super.tearDown() is not required.
   */
  P_() {
  }
  auth() {
    this.state = 1;
    const t = this.T_(this.Xo), e = this.Xo;
    Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([n, r]) => {
      this.Xo === e && // Normally we'd have to schedule the callback on the AsyncQueue.
      // However, the following calls are safe to be called outside the
      // AsyncQueue since they don't chain asynchronous calls
      this.I_(n, r);
    }, (n) => {
      t(() => {
        const r = new Z(z.UNKNOWN, "Fetching auth token failed: " + n.message);
        return this.E_(r);
      });
    });
  }
  I_(t, e) {
    const n = this.T_(this.Xo);
    this.stream = this.d_(t, e), this.stream.Ro(() => {
      n(() => this.listener.Ro());
    }), this.stream.mo(() => {
      n(() => (this.state = 2, this.t_ = this.li.enqueueAfterDelay(this.Zo, 1e4, () => (this.s_() && (this.state = 3), Promise.resolve())), this.listener.mo()));
    }), this.stream.po((r) => {
      n(() => this.E_(r));
    }), this.stream.onMessage((r) => {
      n(() => ++this.n_ == 1 ? this.A_(r) : this.onNext(r));
    });
  }
  o_() {
    this.state = 5, this.r_.jo(async () => {
      this.state = 0, this.start();
    });
  }
  // Visible for tests
  E_(t) {
    return q("PersistentStream", `close with error: ${t}`), this.stream = null, this.close(4, t);
  }
  /**
   * Returns a "dispatcher" function that dispatches operations onto the
   * AsyncQueue but only runs them if closeCount remains unchanged. This allows
   * us to turn auth / stream callbacks into no-ops if the stream is closed /
   * re-opened, etc.
   */
  T_(t) {
    return (e) => {
      this.li.enqueueAndForget(() => this.Xo === t ? e() : (q("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()));
    };
  }
}
class cC extends hC {
  constructor(t, e, n, r, s, o) {
    super(t, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", e, n, r, o), this.serializer = s;
  }
  /**
   * Tracks whether or not a handshake has been successfully exchanged and
   * the stream is ready to accept mutations.
   */
  get f_() {
    return this.n_ > 0;
  }
  // Override of PersistentStream.start
  start() {
    this.lastStreamToken = void 0, super.start();
  }
  P_() {
    this.f_ && this.g_([]);
  }
  d_(t, e) {
    return this.connection.qo("Write", t, e);
  }
  A_(t) {
    return Bt(!!t.streamToken), this.lastStreamToken = t.streamToken, // The first response is always the handshake response
    Bt(!t.writeResults || t.writeResults.length === 0), this.listener.p_();
  }
  onNext(t) {
    Bt(!!t.streamToken), this.lastStreamToken = t.streamToken, // A successful first write response means the stream is healthy,
    // Note, that we could consider a successful handshake healthy, however,
    // the write itself might be causing an error we want to back off from.
    this.r_.reset();
    const e = PE(t.writeResults, t.commitTime), n = mr(t.commitTime);
    return this.listener.y_(n, e);
  }
  /**
   * Sends an initial streamToken to the server, performing the handshake
   * required to make the StreamingWrite RPC work. Subsequent
   * calls should wait until onHandshakeComplete was called.
   */
  w_() {
    const t = {};
    t.database = TE(this.serializer), this.c_(t);
  }
  /** Sends a group of mutations to the Firestore backend to apply. */
  g_(t) {
    const e = {
      streamToken: this.lastStreamToken,
      writes: t.map((n) => CE(this.serializer, n))
    };
    this.c_(e);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class uC extends class {
} {
  constructor(t, e, n, r) {
    super(), this.authCredentials = t, this.appCheckCredentials = e, this.connection = n, this.serializer = r, this.S_ = !1;
  }
  b_() {
    if (this.S_) throw new Z(z.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  /** Invokes the provided RPC with auth and AppCheck tokens. */
  Oo(t, e, n, r) {
    return this.b_(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, o]) => this.connection.Oo(t, sc(e, n), r, s, o)).catch((s) => {
      throw s.name === "FirebaseError" ? (s.code === z.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), s) : new Z(z.UNKNOWN, s.toString());
    });
  }
  /** Invokes the provided RPC with streamed results with auth and AppCheck tokens. */
  ko(t, e, n, r, s) {
    return this.b_(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([o, a]) => this.connection.ko(t, sc(e, n), r, o, a, s)).catch((o) => {
      throw o.name === "FirebaseError" ? (o.code === z.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), o) : new Z(z.UNKNOWN, o.toString());
    });
  }
  terminate() {
    this.S_ = !0, this.connection.terminate();
  }
}
class dC {
  constructor(t, e) {
    this.asyncQueue = t, this.onlineStateHandler = e, /** The current OnlineState. */
    this.state = "Unknown", /**
     * A count of consecutive failures to open the stream. If it reaches the
     * maximum defined by MAX_WATCH_STREAM_FAILURES, we'll set the OnlineState to
     * Offline.
     */
    this.D_ = 0, /**
     * A timer that elapses after ONLINE_STATE_TIMEOUT_MS, at which point we
     * transition from OnlineState.Unknown to OnlineState.Offline without waiting
     * for the stream to actually fail (MAX_WATCH_STREAM_FAILURES times).
     */
    this.v_ = null, /**
     * Whether the client should log a warning message if it fails to connect to
     * the backend (initially true, cleared after a successful stream, or if we've
     * logged the message already).
     */
    this.C_ = !0;
  }
  /**
   * Called by RemoteStore when a watch stream is started (including on each
   * backoff attempt).
   *
   * If this is the first attempt, it sets the OnlineState to Unknown and starts
   * the onlineStateTimer.
   */
  F_() {
    this.D_ === 0 && (this.M_(
      "Unknown"
      /* OnlineState.Unknown */
    ), this.v_ = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.v_ = null, this.x_("Backend didn't respond within 10 seconds."), this.M_(
      "Offline"
      /* OnlineState.Offline */
    ), Promise.resolve())));
  }
  /**
   * Updates our OnlineState as appropriate after the watch stream reports a
   * failure. The first failure moves us to the 'Unknown' state. We then may
   * allow multiple failures (based on MAX_WATCH_STREAM_FAILURES) before we
   * actually transition to the 'Offline' state.
   */
  O_(t) {
    this.state === "Online" ? this.M_(
      "Unknown"
      /* OnlineState.Unknown */
    ) : (this.D_++, this.D_ >= 1 && (this.N_(), this.x_(`Connection failed 1 times. Most recent error: ${t.toString()}`), this.M_(
      "Offline"
      /* OnlineState.Offline */
    )));
  }
  /**
   * Explicitly sets the OnlineState to the specified state.
   *
   * Note that this resets our timers / failure counters, etc. used by our
   * Offline heuristics, so must not be used in place of
   * handleWatchStreamStart() and handleWatchStreamFailure().
   */
  set(t) {
    this.N_(), this.D_ = 0, t === "Online" && // We've connected to watch at least once. Don't warn the developer
    // about being offline going forward.
    (this.C_ = !1), this.M_(t);
  }
  M_(t) {
    t !== this.state && (this.state = t, this.onlineStateHandler(t));
  }
  x_(t) {
    const e = `Could not reach Cloud Firestore backend. ${t}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
    this.C_ ? (Ln(e), this.C_ = !1) : q("OnlineStateTracker", e);
  }
  N_() {
    this.v_ !== null && (this.v_.cancel(), this.v_ = null);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class pC {
  constructor(t, e, n, r, s) {
    this.localStore = t, this.datastore = e, this.asyncQueue = n, this.remoteSyncer = {}, /**
     * A list of up to MAX_PENDING_WRITES writes that we have fetched from the
     * LocalStore via fillWritePipeline() and have or will send to the write
     * stream.
     *
     * Whenever writePipeline.length > 0 the RemoteStore will attempt to start or
     * restart the write stream. When the stream is established the writes in the
     * pipeline will be sent in order.
     *
     * Writes remain in writePipeline until they are acknowledged by the backend
     * and thus will automatically be re-sent if the stream is interrupted /
     * restarted before they're acknowledged.
     *
     * Write responses from the backend are linked to their originating request
     * purely based on order, and so we can just shift() writes from the front of
     * the writePipeline as we receive responses.
     */
    this.L_ = [], /**
     * A mapping of watched targets that the client cares about tracking and the
     * user has explicitly called a 'listen' for this target.
     *
     * These targets may or may not have been sent to or acknowledged by the
     * server. On re-establishing the listen stream, these targets should be sent
     * to the server. The targets removed with unlistens are removed eagerly
     * without waiting for confirmation from the listen stream.
     */
    this.B_ = /* @__PURE__ */ new Map(), /**
     * A set of reasons for why the RemoteStore may be offline. If empty, the
     * RemoteStore may start its network connections.
     */
    this.k_ = /* @__PURE__ */ new Set(), /**
     * Event handlers that get called when the network is disabled or enabled.
     *
     * PORTING NOTE: These functions are used on the Web client to create the
     * underlying streams (to support tree-shakeable streams). On Android and iOS,
     * the streams are created during construction of RemoteStore.
     */
    this.q_ = [], this.Q_ = s, this.Q_.uo((o) => {
      n.enqueueAndForget(async () => {
        eo(this) && (q("RemoteStore", "Restarting streams for network reachability change."), await async function(l) {
          const h = _t(l);
          h.k_.add(
            4
            /* OfflineCause.ConnectivityChange */
          ), await to(h), h.K_.set(
            "Unknown"
            /* OnlineState.Unknown */
          ), h.k_.delete(
            4
            /* OfflineCause.ConnectivityChange */
          ), await Ya(h);
        }(this));
      });
    }), this.K_ = new dC(n, r);
  }
}
async function Ya(i) {
  if (eo(i)) for (const t of i.q_) await t(
    /* enabled= */
    !0
  );
}
async function to(i) {
  for (const t of i.q_) await t(
    /* enabled= */
    !1
  );
}
function eo(i) {
  return _t(i).k_.size === 0;
}
async function Wy(i, t, e) {
  if (!Zs(t)) throw t;
  i.k_.add(
    1
    /* OfflineCause.IndexedDbFailed */
  ), // Disable network and raise offline snapshots
  await to(i), i.K_.set(
    "Offline"
    /* OnlineState.Offline */
  ), e || // Use a simple read operation to determine if IndexedDB recovered.
  // Ideally, we would expose a health check directly on SimpleDb, but
  // RemoteStore only has access to persistence through LocalStore.
  (e = () => iC(i.localStore)), // Probe IndexedDB periodically and re-enable network
  i.asyncQueue.enqueueRetryable(async () => {
    q("RemoteStore", "Retrying IndexedDB access"), await e(), i.k_.delete(
      1
      /* OfflineCause.IndexedDbFailed */
    ), await Ya(i);
  });
}
function qy(i, t) {
  return t().catch((e) => Wy(i, e, t));
}
async function Xa(i) {
  const t = _t(i), e = nn(t);
  let n = t.L_.length > 0 ? t.L_[t.L_.length - 1].batchId : -1;
  for (; fC(t); ) try {
    const r = await nC(t.localStore, n);
    if (r === null) {
      t.L_.length === 0 && e.a_();
      break;
    }
    n = r.batchId, mC(t, r);
  } catch (r) {
    await Wy(t, r);
  }
  Yy(t) && Xy(t);
}
function fC(i) {
  return eo(i) && i.L_.length < 10;
}
function mC(i, t) {
  i.L_.push(t);
  const e = nn(i);
  e.s_() && e.f_ && e.g_(t.mutations);
}
function Yy(i) {
  return eo(i) && !nn(i).i_() && i.L_.length > 0;
}
function Xy(i) {
  nn(i).start();
}
async function gC(i) {
  nn(i).w_();
}
async function yC(i) {
  const t = nn(i);
  for (const e of i.L_) t.g_(e.mutations);
}
async function vC(i, t, e) {
  const n = i.L_.shift(), r = su.from(n, t, e);
  await qy(i, () => i.remoteSyncer.applySuccessfulWrite(r)), // It's possible that with the completion of this mutation another
  // slot has freed up.
  await Xa(i);
}
async function _C(i, t) {
  t && nn(i).f_ && // This error affects the actual write.
  await async function(n, r) {
    if (function(o) {
      return vE(o) && o !== z.ABORTED;
    }(r.code)) {
      const s = n.L_.shift();
      nn(n).__(), await qy(n, () => n.remoteSyncer.rejectFailedWrite(s.batchId, r)), // It's possible that with the completion of this mutation
      // another slot has freed up.
      await Xa(n);
    }
  }(i, t), // The write stream might have been started by refilling the write
  // pipeline for failed writes
  Yy(i) && Xy(i);
}
async function of(i, t) {
  const e = _t(i);
  e.asyncQueue.verifyOperationInProgress(), q("RemoteStore", "RemoteStore received new credentials");
  const n = eo(e);
  e.k_.add(
    3
    /* OfflineCause.CredentialChange */
  ), await to(e), n && // Don't set the network status to Unknown if we are offline.
  e.K_.set(
    "Unknown"
    /* OnlineState.Unknown */
  ), await e.remoteSyncer.handleCredentialChange(t), e.k_.delete(
    3
    /* OfflineCause.CredentialChange */
  ), await Ya(e);
}
async function xC(i, t) {
  const e = _t(i);
  t ? (e.k_.delete(
    2
    /* OfflineCause.IsSecondary */
  ), await Ya(e)) : t || (e.k_.add(
    2
    /* OfflineCause.IsSecondary */
  ), await to(e), e.K_.set(
    "Unknown"
    /* OnlineState.Unknown */
  ));
}
function nn(i) {
  return i.G_ || // Create stream (but note that it is not started yet).
  (i.G_ = function(e, n, r) {
    const s = _t(e);
    return s.b_(), new cC(n, s.connection, s.authCredentials, s.appCheckCredentials, s.serializer, r);
  }(i.datastore, i.asyncQueue, {
    Ro: () => Promise.resolve(),
    mo: gC.bind(null, i),
    po: _C.bind(null, i),
    p_: yC.bind(null, i),
    y_: vC.bind(null, i)
  }), i.q_.push(async (t) => {
    t ? (i.G_.__(), // This will start the write stream if necessary.
    await Xa(i)) : (await i.G_.stop(), i.L_.length > 0 && (q("RemoteStore", `Stopping write stream with ${i.L_.length} pending writes`), i.L_ = []));
  })), i.G_;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class hu {
  constructor(t, e, n, r, s) {
    this.asyncQueue = t, this.timerId = e, this.targetTimeMs = n, this.op = r, this.removalCallback = s, this.deferred = new kn(), this.then = this.deferred.promise.then.bind(this.deferred.promise), // It's normal for the deferred promise to be canceled (due to cancellation)
    // and so we attach a dummy catch callback to avoid
    // 'UnhandledPromiseRejectionWarning' log spam.
    this.deferred.promise.catch((o) => {
    });
  }
  get promise() {
    return this.deferred.promise;
  }
  /**
   * Creates and returns a DelayedOperation that has been scheduled to be
   * executed on the provided asyncQueue after the provided delayMs.
   *
   * @param asyncQueue - The queue to schedule the operation on.
   * @param id - A Timer ID identifying the type of operation this is.
   * @param delayMs - The delay (ms) before the operation should be scheduled.
   * @param op - The operation to run.
   * @param removalCallback - A callback to be called synchronously once the
   *   operation is executed or canceled, notifying the AsyncQueue to remove it
   *   from its delayedOperations list.
   *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and
   *   the DelayedOperation class public.
   */
  static createAndSchedule(t, e, n, r, s) {
    const o = Date.now() + n, a = new hu(t, e, o, r, s);
    return a.start(n), a;
  }
  /**
   * Starts the timer. This is called immediately after construction by
   * createAndSchedule().
   */
  start(t) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t);
  }
  /**
   * Queues the operation to run immediately (if it hasn't already been run or
   * canceled).
   */
  skipDelay() {
    return this.handleDelayElapsed();
  }
  /**
   * Cancels the operation if it hasn't already been executed or canceled. The
   * promise will be rejected.
   *
   * As long as the operation has not yet been run, calling cancel() provides a
   * guarantee that the operation will not be run.
   */
  cancel(t) {
    this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new Z(z.CANCELLED, "Operation cancelled" + (t ? ": " + t : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then((t) => this.deferred.resolve(t))) : Promise.resolve());
  }
  clearTimeout() {
    this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
}
function Ky(i, t) {
  if (Ln("AsyncQueue", `${t}: ${i}`), Zs(i)) return new Z(z.UNAVAILABLE, `${t}: ${i}`);
  throw i;
}
class bC {
  constructor() {
    this.queries = af(), this.onlineState = "Unknown", this.X_ = /* @__PURE__ */ new Set();
  }
  terminate() {
    (function(e, n) {
      const r = _t(e), s = r.queries;
      r.queries = af(), s.forEach((o, a) => {
        for (const l of a.J_) l.onError(n);
      });
    })(this, new Z(z.ABORTED, "Firestore shutting down"));
  }
}
function af() {
  return new Gn((i) => Py(i), Cy);
}
function wC(i) {
  i.X_.forEach((t) => {
    t.next();
  });
}
var lf, hf;
(hf = lf || (lf = {})).na = "default", /** Listen to changes in cache only */
hf.Cache = "cache";
class AC {
  constructor(t, e, n, r, s, o) {
    this.localStore = t, this.remoteStore = e, this.eventManager = n, this.sharedClientState = r, this.currentUser = s, this.maxConcurrentLimboResolutions = o, this.Ma = {}, this.xa = new Gn((a) => Py(a), Cy), this.Oa = /* @__PURE__ */ new Map(), /**
     * The keys of documents that are in limbo for which we haven't yet started a
     * limbo resolution query. The strings in this set are the result of calling
     * `key.path.canonicalString()` where `key` is a `DocumentKey` object.
     *
     * The `Set` type was chosen because it provides efficient lookup and removal
     * of arbitrary elements and it also maintains insertion order, providing the
     * desired queue-like FIFO semantics.
     */
    this.Na = /* @__PURE__ */ new Set(), /**
     * Keeps track of the target ID for each document that is in limbo with an
     * active target.
     */
    this.La = new Ve(et.comparator), /**
     * Keeps track of the information about an active limbo resolution for each
     * active target ID that was started for the purpose of limbo resolution.
     */
    this.Ba = /* @__PURE__ */ new Map(), this.ka = new ou(), /** Stores user completion handlers, indexed by User and BatchId. */
    this.qa = {}, /** Stores user callbacks waiting for all pending writes to be acknowledged. */
    this.Qa = /* @__PURE__ */ new Map(), this.Ka = Ir.Qn(), this.onlineState = "Unknown", // The primary state is set to `true` or `false` immediately after Firestore
    // startup. In the interim, a client should only be considered primary if
    // `isPrimary` is true.
    this.$a = void 0;
  }
  get isPrimaryClient() {
    return this.$a === !0;
  }
}
async function SC(i, t, e) {
  const n = PC(i);
  try {
    const r = await function(o, a) {
      const l = _t(o), h = te.now(), c = a.reduce((d, m) => d.add(m.key), pe());
      let p, f;
      return l.persistence.runTransaction("Locally write mutations", "readwrite", (d) => {
        let m = xa(), g = pe();
        return l.hs.getEntries(d, c).next((y) => {
          m = y, m.forEach((b, S) => {
            S.isValidDocument() || (g = g.add(b));
          });
        }).next(() => l.localDocuments.getOverlayedDocuments(d, m)).next((y) => {
          p = y;
          const b = [];
          for (const S of a) {
            const C = fE(S, p.get(S.key).overlayedDocument);
            C != null && // NOTE: The base state should only be applied if there's some
            // existing document to override, so use a Precondition of
            // exists=true
            b.push(new Hn(S.key, C, xy(C.value.mapValue), Oi.exists(!0)));
          }
          return l.mutationQueue.addMutationBatch(d, h, b, a);
        }).next((y) => {
          f = y;
          const b = y.applyToLocalDocumentSet(p, g);
          return l.documentOverlayCache.saveOverlays(d, y.batchId, b);
        });
      }).then(() => ({
        batchId: f.batchId,
        changes: Ry(p)
      }));
    }(n.localStore, t);
    n.sharedClientState.addPendingMutation(r.batchId), function(o, a, l) {
      let h = o.qa[o.currentUser.toKey()];
      h || (h = new Ve(ft)), h = h.insert(a, l), o.qa[o.currentUser.toKey()] = h;
    }(n, r.batchId, e), await Ka(n, r.changes), await Xa(n.remoteStore);
  } catch (r) {
    const s = Ky(r, "Failed to persist write");
    e.reject(s);
  }
}
function cf(i, t, e) {
  const n = _t(i);
  if (n.isPrimaryClient && e === 0 || !n.isPrimaryClient && e === 1) {
    const r = [];
    n.xa.forEach((s, o) => {
      const a = o.view.ea(t);
      a.snapshot && r.push(a.snapshot);
    }), function(o, a) {
      const l = _t(o);
      l.onlineState = a;
      let h = !1;
      l.queries.forEach((c, p) => {
        for (const f of p.J_)
          f.ea(a) && (h = !0);
      }), h && wC(l);
    }(n.eventManager, t), r.length && n.Ma.R_(r), n.onlineState = t, n.isPrimaryClient && n.sharedClientState.setOnlineState(t);
  }
}
async function TC(i, t) {
  const e = _t(i), n = t.batch.batchId;
  try {
    const r = await eC(e.localStore, t);
    Jy(
      e,
      n,
      /*error=*/
      null
    ), Qy(e, n), e.sharedClientState.updateMutationState(n, "acknowledged"), await Ka(e, r);
  } catch (r) {
    await Kc(r);
  }
}
async function EC(i, t, e) {
  const n = _t(i);
  try {
    const r = await function(o, a) {
      const l = _t(o);
      return l.persistence.runTransaction("Reject batch", "readwrite-primary", (h) => {
        let c;
        return l.mutationQueue.lookupMutationBatch(h, a).next((p) => (Bt(p !== null), c = p.keys(), l.mutationQueue.removeMutationBatch(h, p))).next(() => l.mutationQueue.performConsistencyCheck(h)).next(() => l.documentOverlayCache.removeOverlaysForBatchId(h, c, a)).next(() => l.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(h, c)).next(() => l.localDocuments.getDocuments(h, c));
      });
    }(n.localStore, t);
    Jy(n, t, e), Qy(n, t), n.sharedClientState.updateMutationState(t, "rejected", e), await Ka(n, r);
  } catch (r) {
    await Kc(r);
  }
}
function Qy(i, t) {
  (i.Qa.get(t) || []).forEach((e) => {
    e.resolve();
  }), i.Qa.delete(t);
}
function Jy(i, t, e) {
  const n = _t(i);
  let r = n.qa[n.currentUser.toKey()];
  if (r) {
    const s = r.get(t);
    s && (e ? s.reject(e) : s.resolve(), r = r.remove(t)), n.qa[n.currentUser.toKey()] = r;
  }
}
async function Ka(i, t, e) {
  const n = _t(i), r = [], s = [], o = [];
  n.xa.isEmpty() || (n.xa.forEach((a, l) => {
    o.push(n.Ua(l, t, e).then((h) => {
      var c;
      if ((h || e) && n.isPrimaryClient) {
        const p = h ? !h.fromCache : (c = void 0) === null || c === void 0 ? void 0 : c.current;
        n.sharedClientState.updateQueryState(l.targetId, p ? "current" : "not-current");
      }
      if (h) {
        r.push(h);
        const p = lu.zi(l.targetId, h);
        s.push(p);
      }
    }));
  }), await Promise.all(o), n.Ma.R_(r), await async function(l, h) {
    const c = _t(l);
    try {
      await c.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (p) => L.forEach(h, (f) => L.forEach(f.Wi, (d) => c.persistence.referenceDelegate.addReference(p, f.targetId, d)).next(() => L.forEach(f.Gi, (d) => c.persistence.referenceDelegate.removeReference(p, f.targetId, d)))));
    } catch (p) {
      if (!Zs(p)) throw p;
      q("LocalStore", "Failed to update sequence numbers: " + p);
    }
    for (const p of h) {
      const f = p.targetId;
      if (!p.fromCache) {
        const d = c.us.get(f), m = d.snapshotVersion, g = d.withLastLimboFreeSnapshotVersion(m);
        c.us = c.us.insert(f, g);
      }
    }
  }(n.localStore, s));
}
async function CC(i, t) {
  const e = _t(i);
  if (!e.currentUser.isEqual(t)) {
    q("SyncEngine", "User change. New user:", t.toKey());
    const n = await Gy(e.localStore, t);
    e.currentUser = t, // Fails tasks waiting for pending writes requested by previous user.
    function(s, o) {
      s.Qa.forEach((a) => {
        a.forEach((l) => {
          l.reject(new Z(z.CANCELLED, o));
        });
      }), s.Qa.clear();
    }(e, "'waitForPendingWrites' promise is rejected due to a user change."), // TODO(b/114226417): Consider calling this only in the primary tab.
    e.sharedClientState.handleUserChange(t, n.removedBatchIds, n.addedBatchIds), await Ka(e, n.Ts);
  }
}
function PC(i) {
  const t = _t(i);
  return t.remoteStore.remoteSyncer.applySuccessfulWrite = TC.bind(null, t), t.remoteStore.remoteSyncer.rejectFailedWrite = EC.bind(null, t), t;
}
class Sa {
  constructor() {
    this.kind = "memory", this.synchronizeTabs = !1;
  }
  async initialize(t) {
    this.serializer = qa(t.databaseInfo.databaseId), this.sharedClientState = this.za(t), this.persistence = this.ja(t), await this.persistence.start(), this.localStore = this.Ha(t), this.gcScheduler = this.Ja(t, this.localStore), this.indexBackfillerScheduler = this.Ya(t, this.localStore);
  }
  Ja(t, e) {
    return null;
  }
  Ya(t, e) {
    return null;
  }
  Ha(t) {
    return tC(this.persistence, new ZE(), t.initialUser, this.serializer);
  }
  ja(t) {
    return new jy(au.ei, this.serializer);
  }
  za(t) {
    return new rC();
  }
  async terminate() {
    var t, e;
    (t = this.gcScheduler) === null || t === void 0 || t.stop(), (e = this.indexBackfillerScheduler) === null || e === void 0 || e.stop(), this.sharedClientState.shutdown(), await this.persistence.shutdown();
  }
}
Sa.provider = {
  build: () => new Sa()
};
class IC extends Sa {
  constructor(t) {
    super(), this.cacheSizeBytes = t;
  }
  Ja(t, e) {
    Bt(this.persistence.referenceDelegate instanceof Aa);
    const n = this.persistence.referenceDelegate.garbageCollector;
    return new FE(n, t.asyncQueue, e);
  }
  ja(t) {
    const e = this.cacheSizeBytes !== void 0 ? Ce.withCacheSize(this.cacheSizeBytes) : Ce.DEFAULT;
    return new jy((n) => Aa.ei(n, e), this.serializer);
  }
}
class ac {
  async initialize(t, e) {
    this.localStore || (this.localStore = t.localStore, this.sharedClientState = t.sharedClientState, this.datastore = this.createDatastore(e), this.remoteStore = this.createRemoteStore(e), this.eventManager = this.createEventManager(e), this.syncEngine = this.createSyncEngine(
      e,
      /* startAsPrimary=*/
      !t.synchronizeTabs
    ), this.sharedClientState.onlineStateHandler = (n) => cf(
      this.syncEngine,
      n,
      1
      /* OnlineStateSource.SharedClientState */
    ), this.remoteStore.remoteSyncer.handleCredentialChange = CC.bind(null, this.syncEngine), await xC(this.remoteStore, this.syncEngine.isPrimaryClient));
  }
  createEventManager(t) {
    return function() {
      return new bC();
    }();
  }
  createDatastore(t) {
    const e = qa(t.databaseInfo.databaseId), n = function(s) {
      return new lC(s);
    }(t.databaseInfo);
    return function(s, o, a, l) {
      return new uC(s, o, a, l);
    }(t.authCredentials, t.appCheckCredentials, n, e);
  }
  createRemoteStore(t) {
    return function(n, r, s, o, a) {
      return new pC(n, r, s, o, a);
    }(this.localStore, this.datastore, t.asyncQueue, (e) => cf(
      this.syncEngine,
      e,
      0
      /* OnlineStateSource.RemoteStore */
    ), function() {
      return sf.p() ? new sf() : new sC();
    }());
  }
  createSyncEngine(t, e) {
    return function(r, s, o, a, l, h, c) {
      const p = new AC(r, s, o, a, l, h);
      return c && (p.$a = !0), p;
    }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, t.initialUser, t.maxConcurrentLimboResolutions, e);
  }
  async terminate() {
    var t, e;
    await async function(r) {
      const s = _t(r);
      q("RemoteStore", "RemoteStore shutting down."), s.k_.add(
        5
        /* OfflineCause.Shutdown */
      ), await to(s), s.Q_.shutdown(), // Set the OnlineState to Unknown (rather than Offline) to avoid potentially
      // triggering spurious listener events with cached data, etc.
      s.K_.set(
        "Unknown"
        /* OnlineState.Unknown */
      );
    }(this.remoteStore), (t = this.datastore) === null || t === void 0 || t.terminate(), (e = this.eventManager) === null || e === void 0 || e.terminate();
  }
}
ac.provider = {
  build: () => new ac()
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RC {
  constructor(t, e, n, r, s) {
    this.authCredentials = t, this.appCheckCredentials = e, this.asyncQueue = n, this.databaseInfo = r, this.user = de.UNAUTHENTICATED, this.clientId = vy.newId(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this._uninitializedComponentsProvider = s, this.authCredentials.start(n, async (o) => {
      q("FirestoreClient", "Received user=", o.uid), await this.authCredentialListener(o), this.user = o;
    }), this.appCheckCredentials.start(n, (o) => (q("FirestoreClient", "Received new app check token=", o), this.appCheckCredentialListener(o, this.user)));
  }
  get configuration() {
    return {
      asyncQueue: this.asyncQueue,
      databaseInfo: this.databaseInfo,
      clientId: this.clientId,
      authCredentials: this.authCredentials,
      appCheckCredentials: this.appCheckCredentials,
      initialUser: this.user,
      maxConcurrentLimboResolutions: 100
    };
  }
  setCredentialChangeListener(t) {
    this.authCredentialListener = t;
  }
  setAppCheckTokenChangeListener(t) {
    this.appCheckCredentialListener = t;
  }
  terminate() {
    this.asyncQueue.enterRestrictedMode();
    const t = new kn();
    return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
      try {
        this._onlineComponents && await this._onlineComponents.terminate(), this._offlineComponents && await this._offlineComponents.terminate(), // The credentials provider must be terminated after shutting down the
        // RemoteStore as it will prevent the RemoteStore from retrieving auth
        // tokens.
        this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), t.resolve();
      } catch (e) {
        const n = Ky(e, "Failed to shutdown persistence");
        t.reject(n);
      }
    }), t.promise;
  }
}
async function nh(i, t) {
  i.asyncQueue.verifyOperationInProgress(), q("FirestoreClient", "Initializing OfflineComponentProvider");
  const e = i.configuration;
  await t.initialize(e);
  let n = e.initialUser;
  i.setCredentialChangeListener(async (r) => {
    n.isEqual(r) || (await Gy(t.localStore, r), n = r);
  }), // When a user calls clearPersistence() in one client, all other clients
  // need to be terminated to allow the delete to succeed.
  t.persistence.setDatabaseDeletedListener(() => i.terminate()), i._offlineComponents = t;
}
async function uf(i, t) {
  i.asyncQueue.verifyOperationInProgress();
  const e = await kC(i);
  q("FirestoreClient", "Initializing OnlineComponentProvider"), await t.initialize(e, i.configuration), // The CredentialChangeListener of the online component provider takes
  // precedence over the offline component provider.
  i.setCredentialChangeListener((n) => of(t.remoteStore, n)), i.setAppCheckTokenChangeListener((n, r) => of(t.remoteStore, r)), i._onlineComponents = t;
}
async function kC(i) {
  if (!i._offlineComponents) if (i._uninitializedComponentsProvider) {
    q("FirestoreClient", "Using user provided OfflineComponentProvider");
    try {
      await nh(i, i._uninitializedComponentsProvider._offline);
    } catch (t) {
      const e = t;
      if (!function(r) {
        return r.name === "FirebaseError" ? r.code === z.FAILED_PRECONDITION || r.code === z.UNIMPLEMENTED : !(typeof DOMException < "u" && r instanceof DOMException) || // When the browser is out of quota we could get either quota exceeded
        // or an aborted error depending on whether the error happened during
        // schema migration.
        r.code === 22 || r.code === 20 || // Firefox Private Browsing mode disables IndexedDb and returns
        // INVALID_STATE for any usage.
        r.code === 11;
      }(e)) throw e;
      fa("Error using user provided cache. Falling back to memory cache: " + e), await nh(i, new Sa());
    }
  } else q("FirestoreClient", "Using default OfflineComponentProvider"), await nh(i, new IC(void 0));
  return i._offlineComponents;
}
async function MC(i) {
  return i._onlineComponents || (i._uninitializedComponentsProvider ? (q("FirestoreClient", "Using user provided OnlineComponentProvider"), await uf(i, i._uninitializedComponentsProvider._online)) : (q("FirestoreClient", "Using default OnlineComponentProvider"), await uf(i, new ac()))), i._onlineComponents;
}
function OC(i) {
  return MC(i).then((t) => t.syncEngine);
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Zy(i) {
  const t = {};
  return i.timeoutSeconds !== void 0 && (t.timeoutSeconds = i.timeoutSeconds), t;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const df = /* @__PURE__ */ new Map();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function DC(i, t, e) {
  if (!e) throw new Z(z.INVALID_ARGUMENT, `Function ${i}() cannot be called with an empty ${t}.`);
}
function BC(i, t, e, n) {
  if (t === !0 && n === !0) throw new Z(z.INVALID_ARGUMENT, `${i} and ${e} cannot be used together.`);
}
function pf(i) {
  if (!et.isDocumentKey(i)) throw new Z(z.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${i} has ${i.length}.`);
}
function cu(i) {
  if (i === void 0) return "undefined";
  if (i === null) return "null";
  if (typeof i == "string") return i.length > 20 && (i = `${i.substring(0, 20)}...`), JSON.stringify(i);
  if (typeof i == "number" || typeof i == "boolean") return "" + i;
  if (typeof i == "object") {
    if (i instanceof Array) return "an array";
    {
      const t = (
        /** try to get the constructor name for an object. */
        function(n) {
          return n.constructor ? n.constructor.name : null;
        }(i)
      );
      return t ? `a custom ${t} object` : "an object";
    }
  }
  return typeof i == "function" ? "a function" : rt();
}
function lc(i, t) {
  if ("_delegate" in i && // Unwrap Compat types
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (i = i._delegate), !(i instanceof t)) {
    if (t.name === i.constructor.name) throw new Z(z.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const e = cu(i);
      throw new Z(z.INVALID_ARGUMENT, `Expected type '${t.name}', but it was: ${e}`);
    }
  }
  return i;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ff {
  constructor(t) {
    var e, n;
    if (t.host === void 0) {
      if (t.ssl !== void 0) throw new Z(z.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = !0;
    } else this.host = t.host, this.ssl = (e = t.ssl) === null || e === void 0 || e;
    if (this.credentials = t.credentials, this.ignoreUndefinedProperties = !!t.ignoreUndefinedProperties, this.localCache = t.localCache, t.cacheSizeBytes === void 0) this.cacheSizeBytes = 41943040;
    else {
      if (t.cacheSizeBytes !== -1 && t.cacheSizeBytes < 1048576) throw new Z(z.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = t.cacheSizeBytes;
    }
    BC("experimentalForceLongPolling", t.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t.experimentalAutoDetectLongPolling), this.experimentalForceLongPolling = !!t.experimentalForceLongPolling, this.experimentalForceLongPolling ? this.experimentalAutoDetectLongPolling = !1 : t.experimentalAutoDetectLongPolling === void 0 ? this.experimentalAutoDetectLongPolling = !0 : (
      // For backwards compatibility, coerce the value to boolean even though
      // the TypeScript compiler has narrowed the type to boolean already.
      // noinspection PointlessBooleanExpressionJS
      this.experimentalAutoDetectLongPolling = !!t.experimentalAutoDetectLongPolling
    ), this.experimentalLongPollingOptions = Zy((n = t.experimentalLongPollingOptions) !== null && n !== void 0 ? n : {}), function(s) {
      if (s.timeoutSeconds !== void 0) {
        if (isNaN(s.timeoutSeconds)) throw new Z(z.INVALID_ARGUMENT, `invalid long polling timeout: ${s.timeoutSeconds} (must not be NaN)`);
        if (s.timeoutSeconds < 5) throw new Z(z.INVALID_ARGUMENT, `invalid long polling timeout: ${s.timeoutSeconds} (minimum allowed value is 5)`);
        if (s.timeoutSeconds > 30) throw new Z(z.INVALID_ARGUMENT, `invalid long polling timeout: ${s.timeoutSeconds} (maximum allowed value is 30)`);
      }
    }(this.experimentalLongPollingOptions), this.useFetchStreams = !!t.useFetchStreams;
  }
  isEqual(t) {
    return this.host === t.host && this.ssl === t.ssl && this.credentials === t.credentials && this.cacheSizeBytes === t.cacheSizeBytes && this.experimentalForceLongPolling === t.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t.experimentalAutoDetectLongPolling && function(n, r) {
      return n.timeoutSeconds === r.timeoutSeconds;
    }(this.experimentalLongPollingOptions, t.experimentalLongPollingOptions) && this.ignoreUndefinedProperties === t.ignoreUndefinedProperties && this.useFetchStreams === t.useFetchStreams;
  }
}
class uu {
  /** @hideconstructor */
  constructor(t, e, n, r) {
    this._authCredentials = t, this._appCheckCredentials = e, this._databaseId = n, this._app = r, /**
     * Whether it's a Firestore or Firestore Lite instance.
     */
    this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new ff({}), this._settingsFrozen = !1, // A task that is assigned when the terminate() is invoked and resolved when
    // all components have shut down. Otherwise, Firestore is not terminated,
    // which can mean either the FirestoreClient is in the process of starting,
    // or restarting.
    this._terminateTask = "notTerminated";
  }
  /**
   * The {@link @firebase/app#FirebaseApp} associated with this `Firestore` service
   * instance.
   */
  get app() {
    if (!this._app) throw new Z(z.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return this._terminateTask !== "notTerminated";
  }
  _setSettings(t) {
    if (this._settingsFrozen) throw new Z(z.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new ff(t), t.credentials !== void 0 && (this._authCredentials = function(n) {
      if (!n) return new vT();
      switch (n.type) {
        case "firstParty":
          return new wT(n.sessionIndex || "0", n.iamToken || null, n.authTokenFactory || null);
        case "provider":
          return n.client;
        default:
          throw new Z(z.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type");
      }
    }(t.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = !0, this._settings;
  }
  _delete() {
    return this._terminateTask === "notTerminated" && (this._terminateTask = this._terminate()), this._terminateTask;
  }
  async _restart() {
    this._terminateTask === "notTerminated" ? await this._terminate() : this._terminateTask = "notTerminated";
  }
  /** Returns a JSON-serializable representation of this `Firestore` instance. */
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  /**
   * Terminates all components used by this client. Subclasses can override
   * this method to clean up their own dependencies, but must also call this
   * method.
   *
   * Only ever called once.
   */
  _terminate() {
    return function(e) {
      const n = df.get(e);
      n && (q("ComponentProvider", "Removing Datastore"), df.delete(e), n.terminate());
    }(this), Promise.resolve();
  }
}
function VC(i, t, e, n = {}) {
  var r;
  const s = (i = lc(i, uu))._getSettings(), o = `${t}:${e}`;
  if (s.host !== "firestore.googleapis.com" && s.host !== o && fa("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used."), i._setSettings(Object.assign(Object.assign({}, s), {
    host: o,
    ssl: !1
  })), n.mockUserToken) {
    let a, l;
    if (typeof n.mockUserToken == "string") a = n.mockUserToken, l = de.MOCK_USER;
    else {
      a = JA(n.mockUserToken, (r = i._app) === null || r === void 0 ? void 0 : r.options.projectId);
      const h = n.mockUserToken.sub || n.mockUserToken.user_id;
      if (!h) throw new Z(z.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
      l = new de(h);
    }
    i._authCredentials = new _T(new yy(a, l));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class du {
  // This is the lite version of the Query class in the main SDK.
  /** @hideconstructor protected */
  constructor(t, e, n) {
    this.converter = e, this._query = n, /** The type of this Firestore reference. */
    this.type = "query", this.firestore = t;
  }
  withConverter(t) {
    return new du(this.firestore, t, this._query);
  }
}
class Di {
  /** @hideconstructor */
  constructor(t, e, n) {
    this.converter = e, this._key = n, /** The type of this Firestore reference. */
    this.type = "document", this.firestore = t;
  }
  get _path() {
    return this._key.path;
  }
  /**
   * The document's identifier within its collection.
   */
  get id() {
    return this._key.path.lastSegment();
  }
  /**
   * A string representing the path of the referenced document (relative
   * to the root of the database).
   */
  get path() {
    return this._key.path.canonicalString();
  }
  /**
   * The collection this `DocumentReference` belongs to.
   */
  get parent() {
    return new Ks(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(t) {
    return new Di(this.firestore, t, this._key);
  }
}
class Ks extends du {
  /** @hideconstructor */
  constructor(t, e, n) {
    super(t, e, ZT(n)), this._path = n, /** The type of this Firestore reference. */
    this.type = "collection";
  }
  /** The collection's identifier. */
  get id() {
    return this._query.path.lastSegment();
  }
  /**
   * A string representing the path of the referenced collection (relative
   * to the root of the database).
   */
  get path() {
    return this._query.path.canonicalString();
  }
  /**
   * A reference to the containing `DocumentReference` if this is a
   * subcollection. If this isn't a subcollection, the reference is null.
   */
  get parent() {
    const t = this._path.popLast();
    return t.isEmpty() ? null : new Di(
      this.firestore,
      /* converter= */
      null,
      new et(t)
    );
  }
  withConverter(t) {
    return new Ks(this.firestore, t, this._path);
  }
}
function FC(i, t, ...e) {
  if (i = ua(i), // We allow omission of 'pathString' but explicitly prohibit passing in both
  // 'undefined' and 'null'.
  arguments.length === 1 && (t = vy.newId()), DC("doc", "path", t), i instanceof uu) {
    const n = zt.fromString(t, ...e);
    return pf(n), new Di(
      i,
      /* converter= */
      null,
      new et(n)
    );
  }
  {
    if (!(i instanceof Di || i instanceof Ks)) throw new Z(z.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const n = i._path.child(zt.fromString(t, ...e));
    return pf(n), new Di(i.firestore, i instanceof Ks ? i.converter : null, new et(n));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class mf {
  constructor(t = Promise.resolve()) {
    this.Iu = [], // Is this AsyncQueue being shut down? Once it is set to true, it will not
    // be changed again.
    this.Eu = !1, // Operations scheduled to be queued in the future. Operations are
    // automatically removed after they are run or canceled.
    this.du = [], // visible for testing
    this.Au = null, // Flag set while there's an outstanding AsyncQueue operation, used for
    // assertion sanity-checks.
    this.Ru = !1, // Enabled during shutdown on Safari to prevent future access to IndexedDB.
    this.Vu = !1, // List of TimerIds to fast-forward delays for.
    this.mu = [], // Backoff timer used to schedule retries for retryable operations
    this.r_ = new Hy(
      this,
      "async_queue_retry"
      /* TimerId.AsyncQueueRetry */
    ), // Visibility handler that triggers an immediate retry of all retryable
    // operations. Meant to speed up recovery when we regain file system access
    // after page comes into foreground.
    this.fu = () => {
      const n = ih();
      n && q("AsyncQueue", "Visibility state changed to " + n.visibilityState), this.r_.Jo();
    }, this.gu = t;
    const e = ih();
    e && typeof e.addEventListener == "function" && e.addEventListener("visibilitychange", this.fu);
  }
  get isShuttingDown() {
    return this.Eu;
  }
  /**
   * Adds a new operation to the queue without waiting for it to complete (i.e.
   * we ignore the Promise result).
   */
  enqueueAndForget(t) {
    this.enqueue(t);
  }
  enqueueAndForgetEvenWhileRestricted(t) {
    this.pu(), // eslint-disable-next-line @typescript-eslint/no-floating-promises
    this.yu(t);
  }
  enterRestrictedMode(t) {
    if (!this.Eu) {
      this.Eu = !0, this.Vu = t || !1;
      const e = ih();
      e && typeof e.removeEventListener == "function" && e.removeEventListener("visibilitychange", this.fu);
    }
  }
  enqueue(t) {
    if (this.pu(), this.Eu)
      return new Promise(() => {
      });
    const e = new kn();
    return this.yu(() => this.Eu && this.Vu ? Promise.resolve() : (t().then(e.resolve, e.reject), e.promise)).then(() => e.promise);
  }
  enqueueRetryable(t) {
    this.enqueueAndForget(() => (this.Iu.push(t), this.wu()));
  }
  /**
   * Runs the next operation from the retryable queue. If the operation fails,
   * reschedules with backoff.
   */
  async wu() {
    if (this.Iu.length !== 0) {
      try {
        await this.Iu[0](), this.Iu.shift(), this.r_.reset();
      } catch (t) {
        if (!Zs(t)) throw t;
        q("AsyncQueue", "Operation failed with retryable error: " + t);
      }
      this.Iu.length > 0 && // If there are additional operations, we re-schedule `retryNextOp()`.
      // This is necessary to run retryable operations that failed during
      // their initial attempt since we don't know whether they are already
      // enqueued. If, for example, `op1`, `op2`, `op3` are enqueued and `op1`
      // needs to  be re-run, we will run `op1`, `op1`, `op2` using the
      // already enqueued calls to `retryNextOp()`. `op3()` will then run in the
      // call scheduled here.
      // Since `backoffAndRun()` cancels an existing backoff and schedules a
      // new backoff on every call, there is only ever a single additional
      // operation in the queue.
      this.r_.jo(() => this.wu());
    }
  }
  yu(t) {
    const e = this.gu.then(() => (this.Ru = !0, t().catch((n) => {
      this.Au = n, this.Ru = !1;
      const r = (
        /**
        * Chrome includes Error.message in Error.stack. Other browsers do not.
        * This returns expected output of message + stack when available.
        * @param error - Error or FirestoreError
        */
        function(o) {
          let a = o.message || "";
          return o.stack && (a = o.stack.includes(o.message) ? o.stack : o.message + `
` + o.stack), a;
        }(n)
      );
      throw Ln("INTERNAL UNHANDLED ERROR: ", r), n;
    }).then((n) => (this.Ru = !1, n))));
    return this.gu = e, e;
  }
  enqueueAfterDelay(t, e, n) {
    this.pu(), // Fast-forward delays for timerIds that have been overridden.
    this.mu.indexOf(t) > -1 && (e = 0);
    const r = hu.createAndSchedule(this, t, e, n, (s) => this.Su(s));
    return this.du.push(r), r;
  }
  pu() {
    this.Au && rt();
  }
  verifyOperationInProgress() {
  }
  /**
   * Waits until all currently queued tasks are finished executing. Delayed
   * operations are not run.
   */
  async bu() {
    let t;
    do
      t = this.gu, await t;
    while (t !== this.gu);
  }
  /**
   * For Tests: Determine if a delayed operation with a particular TimerId
   * exists.
   */
  Du(t) {
    for (const e of this.du) if (e.timerId === t) return !0;
    return !1;
  }
  /**
   * For Tests: Runs some or all delayed operations early.
   *
   * @param lastTimerId - Delayed operations up to and including this TimerId
   * will be drained. Pass TimerId.All to run all delayed operations.
   * @returns a Promise that resolves once all operations have been run.
   */
  vu(t) {
    return this.bu().then(() => {
      this.du.sort((e, n) => e.targetTimeMs - n.targetTimeMs);
      for (const e of this.du) if (e.skipDelay(), t !== "all" && e.timerId === t) break;
      return this.bu();
    });
  }
  /**
   * For Tests: Skip all subsequent delays for a timer id.
   */
  Cu(t) {
    this.mu.push(t);
  }
  /** Called once a DelayedOperation is run or canceled. */
  Su(t) {
    const e = this.du.indexOf(t);
    this.du.splice(e, 1);
  }
}
class $y extends uu {
  /** @hideconstructor */
  constructor(t, e, n, r) {
    super(t, e, n, r), /**
     * Whether it's a {@link Firestore} or Firestore Lite instance.
     */
    this.type = "firestore", this._queue = new mf(), this._persistenceKey = (r == null ? void 0 : r.name) || "[DEFAULT]";
  }
  async _terminate() {
    if (this._firestoreClient) {
      const t = this._firestoreClient.terminate();
      this._queue = new mf(t), this._firestoreClient = void 0, await t;
    }
  }
}
function LC(i, t) {
  const e = typeof i == "object" ? i : oT(), n = typeof i == "string" ? i : "(default)", r = iT(e, "firestore").getImmediate({
    identifier: n
  });
  if (!r._initialized) {
    const s = KA("firestore");
    s && VC(r, ...s);
  }
  return r;
}
function NC(i) {
  if (i._terminated) throw new Z(z.FAILED_PRECONDITION, "The client has already been terminated.");
  return i._firestoreClient || UC(i), i._firestoreClient;
}
function UC(i) {
  var t, e, n;
  const r = i._freezeSettings(), s = function(a, l, h, c) {
    return new LT(a, l, h, c.host, c.ssl, c.experimentalForceLongPolling, c.experimentalAutoDetectLongPolling, Zy(c.experimentalLongPollingOptions), c.useFetchStreams);
  }(i._databaseId, ((t = i._app) === null || t === void 0 ? void 0 : t.options.appId) || "", i._persistenceKey, r);
  i._componentsProvider || !((e = r.localCache) === null || e === void 0) && e._offlineComponentProvider && (!((n = r.localCache) === null || n === void 0) && n._onlineComponentProvider) && (i._componentsProvider = {
    _offline: r.localCache._offlineComponentProvider,
    _online: r.localCache._onlineComponentProvider
  }), i._firestoreClient = new RC(i._authCredentials, i._appCheckCredentials, i._queue, s, i._componentsProvider && function(a) {
    const l = a == null ? void 0 : a._online.build();
    return {
      _offline: a == null ? void 0 : a._offline.build(l),
      _online: l
    };
  }(i._componentsProvider));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Qs {
  /** @hideconstructor */
  constructor(t) {
    this._byteString = t;
  }
  /**
   * Creates a new `Bytes` object from the given Base64 string, converting it to
   * bytes.
   *
   * @param base64 - The Base64 string used to create the `Bytes` object.
   */
  static fromBase64String(t) {
    try {
      return new Qs(_i.fromBase64String(t));
    } catch (e) {
      throw new Z(z.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + e);
    }
  }
  /**
   * Creates a new `Bytes` object from the given Uint8Array.
   *
   * @param array - The Uint8Array used to create the `Bytes` object.
   */
  static fromUint8Array(t) {
    return new Qs(_i.fromUint8Array(t));
  }
  /**
   * Returns the underlying bytes as a Base64-encoded string.
   *
   * @returns The Base64-encoded string created from the `Bytes` object.
   */
  toBase64() {
    return this._byteString.toBase64();
  }
  /**
   * Returns the underlying bytes in a new `Uint8Array`.
   *
   * @returns The Uint8Array created from the `Bytes` object.
   */
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  /**
   * Returns a string representation of the `Bytes` object.
   *
   * @returns A string representation of the `Bytes` object.
   */
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  /**
   * Returns true if this `Bytes` object is equal to the provided one.
   *
   * @param other - The `Bytes` object to compare against.
   * @returns true if this `Bytes` object is equal to the provided one.
   */
  isEqual(t) {
    return this._byteString.isEqual(t._byteString);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class t0 {
  /**
   * Creates a `FieldPath` from the provided field names. If more than one field
   * name is provided, the path will point to a nested field in a document.
   *
   * @param fieldNames - A list of field names.
   */
  constructor(...t) {
    for (let e = 0; e < t.length; ++e) if (t[e].length === 0) throw new Z(z.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new oe(t);
  }
  /**
   * Returns true if this `FieldPath` is equal to the provided one.
   *
   * @param other - The `FieldPath` to compare against.
   * @returns true if this `FieldPath` is equal to the provided one.
   */
  isEqual(t) {
    return this._internalPath.isEqual(t._internalPath);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class e0 {
  /**
   * @param _methodName - The public API endpoint that returns this class.
   * @hideconstructor
   */
  constructor(t) {
    this._methodName = t;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class i0 {
  /**
   * Creates a new immutable `GeoPoint` object with the provided latitude and
   * longitude values.
   * @param latitude - The latitude as number between -90 and 90.
   * @param longitude - The longitude as number between -180 and 180.
   */
  constructor(t, e) {
    if (!isFinite(t) || t < -90 || t > 90) throw new Z(z.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t);
    if (!isFinite(e) || e < -180 || e > 180) throw new Z(z.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + e);
    this._lat = t, this._long = e;
  }
  /**
   * The latitude of this `GeoPoint` instance.
   */
  get latitude() {
    return this._lat;
  }
  /**
   * The longitude of this `GeoPoint` instance.
   */
  get longitude() {
    return this._long;
  }
  /**
   * Returns true if this `GeoPoint` is equal to the provided one.
   *
   * @param other - The `GeoPoint` to compare against.
   * @returns true if this `GeoPoint` is equal to the provided one.
   */
  isEqual(t) {
    return this._lat === t._lat && this._long === t._long;
  }
  /** Returns a JSON-serializable representation of this GeoPoint. */
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long
    };
  }
  /**
   * Actually private to JS consumers of our API, so this function is prefixed
   * with an underscore.
   */
  _compareTo(t) {
    return ft(this._lat, t._lat) || ft(this._long, t._long);
  }
}
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class n0 {
  /**
   * @private
   * @internal
   */
  constructor(t) {
    this._values = (t || []).map((e) => e);
  }
  /**
   * Returns a copy of the raw number array form of the vector.
   */
  toArray() {
    return this._values.map((t) => t);
  }
  /**
   * Returns `true` if the two VectorValue has the same raw number arrays, returns `false` otherwise.
   */
  isEqual(t) {
    return function(n, r) {
      if (n.length !== r.length) return !1;
      for (let s = 0; s < n.length; ++s) if (n[s] !== r[s]) return !1;
      return !0;
    }(this._values, t._values);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const zC = /^__.*__$/;
class jC {
  constructor(t, e, n) {
    this.data = t, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t, e) {
    return this.fieldMask !== null ? new Hn(t, this.data, this.fieldMask, e, this.fieldTransforms) : new $s(t, this.data, e, this.fieldTransforms);
  }
}
function r0(i) {
  switch (i) {
    case 0:
    case 2:
    case 1:
      return !0;
    case 3:
    case 4:
      return !1;
    default:
      throw rt();
  }
}
class pu {
  /**
   * Initializes a ParseContext with the given source and path.
   *
   * @param settings - The settings for the parser.
   * @param databaseId - The database ID of the Firestore instance.
   * @param serializer - The serializer to use to generate the Value proto.
   * @param ignoreUndefinedProperties - Whether to ignore undefined properties
   * rather than throw.
   * @param fieldTransforms - A mutable list of field transforms encountered
   * while parsing the data.
   * @param fieldMask - A mutable list of field paths encountered while parsing
   * the data.
   *
   * TODO(b/34871131): We don't support array paths right now, so path can be
   * null to indicate the context represents any location within an array (in
   * which case certain features will not work and errors will be somewhat
   * compromised).
   */
  constructor(t, e, n, r, s, o) {
    this.settings = t, this.databaseId = e, this.serializer = n, this.ignoreUndefinedProperties = r, // Minor hack: If fieldTransforms is undefined, we assume this is an
    // external call and we need to validate the entire path.
    s === void 0 && this.Fu(), this.fieldTransforms = s || [], this.fieldMask = o || [];
  }
  get path() {
    return this.settings.path;
  }
  get Mu() {
    return this.settings.Mu;
  }
  /** Returns a new context with the specified settings overwritten. */
  xu(t) {
    return new pu(Object.assign(Object.assign({}, this.settings), t), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  Ou(t) {
    var e;
    const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t), r = this.xu({
      path: n,
      Nu: !1
    });
    return r.Lu(t), r;
  }
  Bu(t) {
    var e;
    const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t), r = this.xu({
      path: n,
      Nu: !1
    });
    return r.Fu(), r;
  }
  ku(t) {
    return this.xu({
      path: void 0,
      Nu: !0
    });
  }
  qu(t) {
    return Ta(t, this.settings.methodName, this.settings.Qu || !1, this.path, this.settings.Ku);
  }
  /** Returns 'true' if 'fieldPath' was traversed when creating this context. */
  contains(t) {
    return this.fieldMask.find((e) => t.isPrefixOf(e)) !== void 0 || this.fieldTransforms.find((e) => t.isPrefixOf(e.field)) !== void 0;
  }
  Fu() {
    if (this.path) for (let t = 0; t < this.path.length; t++) this.Lu(this.path.get(t));
  }
  Lu(t) {
    if (t.length === 0) throw this.qu("Document fields must not be empty");
    if (r0(this.Mu) && zC.test(t)) throw this.qu('Document fields cannot begin and end with "__"');
  }
}
class GC {
  constructor(t, e, n) {
    this.databaseId = t, this.ignoreUndefinedProperties = e, this.serializer = n || qa(t);
  }
  /** Creates a new top-level parse context. */
  $u(t, e, n, r = !1) {
    return new pu({
      Mu: t,
      methodName: e,
      Ku: n,
      path: oe.emptyPath(),
      Nu: !1,
      Qu: r
    }, this.databaseId, this.serializer, this.ignoreUndefinedProperties);
  }
}
function HC(i) {
  const t = i._freezeSettings(), e = qa(i._databaseId);
  return new GC(i._databaseId, !!t.ignoreUndefinedProperties, e);
}
function WC(i, t, e, n, r, s = {}) {
  const o = i.$u(s.merge || s.mergeFields ? 2 : 0, t, e, r);
  l0("Data must be an object, but it was:", o, n);
  const a = o0(n, o);
  let l, h;
  if (s.merge) l = new li(o.fieldMask), h = o.fieldTransforms;
  else if (s.mergeFields) {
    const c = [];
    for (const p of s.mergeFields) {
      const f = qC(t, p, e);
      if (!o.contains(f)) throw new Z(z.INVALID_ARGUMENT, `Field '${f}' is specified in your field mask but missing from your input data.`);
      KC(c, f) || c.push(f);
    }
    l = new li(c), h = o.fieldTransforms.filter((p) => l.covers(p.field));
  } else l = null, h = o.fieldTransforms;
  return new jC(new oi(a), l, h);
}
function s0(i, t) {
  if (a0(
    // Unwrap the API type from the Compat SDK. This will return the API type
    // from firestore-exp.
    i = ua(i)
  )) return l0("Unsupported field value:", t, i), o0(i, t);
  if (i instanceof e0)
    return function(n, r) {
      if (!r0(r.Mu)) throw r.qu(`${n._methodName}() can only be used with update() and set()`);
      if (!r.path) throw r.qu(`${n._methodName}() is not currently supported inside arrays`);
      const s = n._toFieldTransform(r);
      s && r.fieldTransforms.push(s);
    }(i, t), null;
  if (i === void 0 && t.ignoreUndefinedProperties)
    return null;
  if (
    // If context.path is null we are inside an array and we don't support
    // field mask paths more granular than the top-level array.
    t.path && t.fieldMask.push(t.path), i instanceof Array
  ) {
    if (t.settings.Nu && t.Mu !== 4) throw t.qu("Nested arrays are not supported");
    return function(n, r) {
      const s = [];
      let o = 0;
      for (const a of n) {
        let l = s0(a, r.ku(o));
        l == null && // Just include nulls in the array for fields being replaced with a
        // sentinel.
        (l = {
          nullValue: "NULL_VALUE"
        }), s.push(l), o++;
      }
      return {
        arrayValue: {
          values: s
        }
      };
    }(i, t);
  }
  return function(n, r) {
    if ((n = ua(n)) === null) return {
      nullValue: "NULL_VALUE"
    };
    if (typeof n == "number") return lE(r.serializer, n);
    if (typeof n == "boolean") return {
      booleanValue: n
    };
    if (typeof n == "string") return {
      stringValue: n
    };
    if (n instanceof Date) {
      const s = te.fromDate(n);
      return {
        timestampValue: rc(r.serializer, s)
      };
    }
    if (n instanceof te) {
      const s = new te(n.seconds, 1e3 * Math.floor(n.nanoseconds / 1e3));
      return {
        timestampValue: rc(r.serializer, s)
      };
    }
    if (n instanceof i0) return {
      geoPointValue: {
        latitude: n.latitude,
        longitude: n.longitude
      }
    };
    if (n instanceof Qs) return {
      bytesValue: bE(r.serializer, n._byteString)
    };
    if (n instanceof Di) {
      const s = r.databaseId, o = n.firestore._databaseId;
      if (!o.isEqual(s)) throw r.qu(`Document reference is for database ${o.projectId}/${o.database} but should be for database ${s.projectId}/${s.database}`);
      return {
        referenceValue: Uy(n.firestore._databaseId || r.databaseId, n._key.path)
      };
    }
    if (n instanceof n0)
      return function(o, a) {
        return {
          mapValue: {
            fields: {
              __type__: {
                stringValue: "__vector__"
              },
              value: {
                arrayValue: {
                  values: o.toArray().map((l) => {
                    if (typeof l != "number") throw a.qu("VectorValues must only contain numeric values.");
                    return ru(a.serializer, l);
                  })
                }
              }
            }
          }
        };
      }(n, r);
    throw r.qu(`Unsupported field value: ${cu(n)}`);
  }(i, t);
}
function o0(i, t) {
  const e = {};
  return _y(i) ? (
    // If we encounter an empty object, we explicitly add it to the update
    // mask to ensure that the server creates a map entry.
    t.path && t.path.length > 0 && t.fieldMask.push(t.path)
  ) : Lr(i, (n, r) => {
    const s = s0(r, t.Ou(n));
    s != null && (e[n] = s);
  }), {
    mapValue: {
      fields: e
    }
  };
}
function a0(i) {
  return !(typeof i != "object" || i === null || i instanceof Array || i instanceof Date || i instanceof te || i instanceof i0 || i instanceof Qs || i instanceof Di || i instanceof e0 || i instanceof n0);
}
function l0(i, t, e) {
  if (!a0(e) || !function(r) {
    return typeof r == "object" && r !== null && (Object.getPrototypeOf(r) === Object.prototype || Object.getPrototypeOf(r) === null);
  }(e)) {
    const n = cu(e);
    throw n === "an object" ? t.qu(i + " a custom object") : t.qu(i + " " + n);
  }
}
function qC(i, t, e) {
  if (
    // If required, replace the FieldPath Compat class with the firestore-exp
    // FieldPath.
    (t = ua(t)) instanceof t0
  ) return t._internalPath;
  if (typeof t == "string") return XC(i, t);
  throw Ta(
    "Field path arguments must be of type string or ",
    i,
    /* hasConverter= */
    !1,
    /* path= */
    void 0,
    e
  );
}
const YC = new RegExp("[~\\*/\\[\\]]");
function XC(i, t, e) {
  if (t.search(YC) >= 0) throw Ta(
    `Invalid field path (${t}). Paths must not contain '~', '*', '/', '[', or ']'`,
    i,
    /* hasConverter= */
    !1,
    /* path= */
    void 0,
    e
  );
  try {
    return new t0(...t.split("."))._internalPath;
  } catch {
    throw Ta(
      `Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,
      i,
      /* hasConverter= */
      !1,
      /* path= */
      void 0,
      e
    );
  }
}
function Ta(i, t, e, n, r) {
  const s = n && !n.isEmpty(), o = r !== void 0;
  let a = `Function ${t}() called with invalid data`;
  e && (a += " (via `toFirestore()`)"), a += ". ";
  let l = "";
  return (s || o) && (l += " (found", s && (l += ` in field ${n}`), o && (l += ` in document ${r}`), l += ")"), new Z(z.INVALID_ARGUMENT, a + i + l);
}
function KC(i, t) {
  return i.some((e) => e.isEqual(t));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function QC(i, t, e) {
  let n;
  return n = i ? e && (e.merge || e.mergeFields) ? i.toFirestore(t, e) : i.toFirestore(t) : t, n;
}
function JC(i, t, e) {
  i = lc(i, Di);
  const n = lc(i.firestore, $y), r = QC(i.converter, t, e);
  return ZC(n, [WC(HC(n), "setDoc", i._key, r, i.converter !== null, e).toMutation(i._key, Oi.none())]);
}
function ZC(i, t) {
  return function(n, r) {
    const s = new kn();
    return n.asyncQueue.enqueueAndForget(async () => SC(await OC(n), r, s)), s.promise;
  }(NC(i), t);
}
(function(t, e = !0) {
  (function(r) {
    Fr = r;
  })(sT), pa(new Gs("firestore", (n, { instanceIdentifier: r, options: s }) => {
    const o = n.getProvider("app").getImmediate(), a = new $y(new xT(n.getProvider("auth-internal")), new ST(n.getProvider("app-check-internal")), function(h, c) {
      if (!Object.prototype.hasOwnProperty.apply(h.options, ["projectId"])) throw new Z(z.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
      return new ya(h.options.projectId, c);
    }(o, r), o);
    return s = Object.assign({
      useFetchStreams: e
    }, s), a._setSettings(s), a;
  }, "PUBLIC").setMultipleInstances(!0)), fr(Up, "4.7.5", t), // BUILD_TARGET will be replaced by values like esm2017, cjs2017, etc during the compilation
  fr(Up, "4.7.5", "esm2017");
})();
const h0 = "couplesRun_nickname", c0 = "couplesRun_playerId", u0 = "couplesRun_highScore", $C = {
  apiKey: "AIzaSyBPCVBnq-hw94nmIEYtfMwT5PiCLvNDWQs",
  authDomain: "couples-run.firebaseapp.com",
  projectId: "couples-run",
  storageBucket: "couples-run.firebasestorage.app",
  messagingSenderId: "817663008433",
  appId: "1:817663008433:web:6271fc6c5a91e2b95fcc90"
};
let d0;
const p0 = () => localStorage.getItem(h0) ?? "", tP = (i) => localStorage.setItem(h0, i) ?? "", eP = async (i) => {
  let t = m0();
  t || (t = window.crypto.randomUUID(), nP(t));
  const e = hc();
  i <= e.amount || (g0({ amount: i, stored: !1 }), await f0());
}, iP = () => {
  const i = ly($C);
  d0 = LC(i), setInterval(() => f0(), 5e3);
}, f0 = async () => {
  const { amount: i, stored: t } = hc();
  i === 0 || t || (await JC(
    FC(d0, "scores", m0()),
    {
      nickname: p0(),
      score: i,
      timestamp: Date.now()
    },
    { merge: !0 }
  ), hc().amount === i && g0({ amount: i, stored: !0 }));
}, m0 = () => localStorage.getItem(c0) ?? "", nP = (i) => localStorage.setItem(c0, i), hc = () => {
  const i = localStorage.getItem(u0);
  return i ? JSON.parse(i) : { amount: 0, stored: !1 };
}, g0 = (i) => localStorage.setItem(u0, JSON.stringify(i));
class rP extends ei {
  constructor() {
    super({
      label: "form-screen",
      alpha: 0
    });
    mt(this, "_accepted", !1);
    mt(this, "_nickname", p0());
    this.addComponent(
      new _e({
        label: "text",
        text: "Enter your nickname:",
        fontFamily: "PressStart2P",
        fontSize: 24,
        textColor: 16763904,
        landscape: {
          position: { x: 20, y: 44 },
          anchor: { x: 0, y: 0.5 }
        },
        portrait: {
          position: { x: 20, y: 20 },
          anchor: 0
        }
      })
    ), this.addComponent(
      new Jw({
        background: "input.png",
        fontFamily: "Arial, sans-serif",
        fontSize: 24,
        label: "nickname",
        textColor: 0,
        text: this._nickname,
        maxLength: 10,
        padding: 10,
        landscape: {
          position: { x: 520, y: 20 }
        },
        portrait: {
          position: { x: 20, y: 80 }
        },
        onChange: (s) => {
          var o;
          this._nickname = s, r.enabled = !!((o = this._nickname) != null && o.trim()) && this._accepted, r.interactive = r.enabled;
        }
      })
    );
    const e = this.addComponent(
      new Be({
        label: "checkbox",
        resource: "checkbox-off.png",
        interactive: !0,
        cursor: "pointer",
        landscape: {
          position: { x: 20, y: 120 }
        },
        portrait: {
          position: { x: 20, y: 180 }
        },
        onClick: () => {
          var s;
          this._accepted = !this._accepted, r.enabled = !!((s = this._nickname) != null && s.trim()) && this._accepted, r.interactive = r.enabled, e.texture = this._accepted ? "checkbox-on.png" : "checkbox-off.png";
        }
      })
    );
    this.addComponent(
      new _e({
        label: "agreement",
        fontFamily: "PressStart2P",
        fontSize: 24,
        textColor: 16763904,
        text: "",
        lineHeight: 40,
        landscape: {
          position: { x: 100, y: 125 },
          text: "By accepting you agree to the privacy policy"
        },
        portrait: {
          position: { x: 100, y: 185 },
          text: `By accepting you agree to
the privacy policy`
        }
      })
    );
    const n = this.addComponent(
      new ei({
        label: "buttons",
        landscape: {
          y: 250
        },
        portrait: {
          y: 340
        },
        horizontalAlignment: "center",
        width: 650
      })
    );
    n.addComponent(
      new qg({
        label: "policy-button",
        url: it.privacyPolicyUrl,
        resource: "policy-button.png",
        hoverResource: "policy-button-hover.png",
        disabledResource: "policy-button.png",
        interactive: !0,
        cursor: "pointer"
      })
    );
    const r = n.addComponent(
      new ja({
        label: "play-button",
        resource: "play-button.png",
        hoverResource: "play-button-hover.png",
        disabledResource: "play-button-disabled.png",
        position: { x: 350, y: 0 },
        cursor: "pointer",
        onClick: async () => {
          r.interactive = !1, tP(this._nickname), this.parent.goToGame();
        }
      })
    );
    r.enabled = !1, this.animate({
      from: { alpha: 0 },
      to: { alpha: 1 },
      duration: 1
    });
  }
}
class sP extends Br {
  async init() {
    this.alpha = 0, this.addComponent(
      new Xg({
        label: "city-bg",
        resource: "city-bg.png"
      })
    ), await Promise.all([
      this.animate({ from: { alpha: 0 }, to: { alpha: 1 }, duration: 2 }),
      Gc(it.sounds.menuLoop, {
        toVolume: 0.3,
        fadeDuration: 0.5,
        loop: !0
      })
    ]), this.addComponent(new DA());
  }
  showCharacterSelectionScreen() {
    this.components[1].destroy(), this.addComponent(new NA());
  }
  showFormScreen() {
    this.components[1].destroy(), this.addComponent(new rP());
  }
  async goToGame() {
    await Promise.all([
      Hc(it.sounds.menuLoop, { fadeDuration: 2 }),
      this.animate({
        from: { alpha: 1 },
        to: { alpha: 0 },
        duration: 2
      })
    ]), Ie(it.signals.goToGame);
  }
}
class oP extends Yg {
  constructor() {
    super({
      label: "background",
      resource: "city-bg.png"
    }), this._registerToSignal(it.signals.moveScreen, this._move);
  }
  _move(t) {
    this.tilePosition.x = -t;
  }
}
class aP extends ei {
  constructor() {
    super({
      label: "info",
      position: { x: 20, y: 20 }
    });
    mt(this, "_totalLifePoints");
    let e = this.addComponent(
      new _e({
        label: "life-points-indicator",
        text: "Life Points:",
        fontFamily: "PressStart2P",
        fontSize: 16,
        textColor: 13421772,
        position: { x: 0, y: 3 }
      })
    ).width + 10;
    for (let n = 0; n < it.lifePoints; n++)
      e += this.addComponent(
        new Be({
          label: `life-point-${n}`,
          resource: "life.png",
          position: { x: e, y: 0 }
        })
      ).width + 5;
    e += this.addComponent(
      new Be({
        label: "separator",
        resource: "separator.png",
        position: { x: e + 10, y: 0 }
      })
    ).width + 25, e += this.addComponent(
      new _e({
        label: "score-indicator",
        text: "Score:",
        fontFamily: "PressStart2P",
        fontSize: 16,
        textColor: 13421772,
        position: { x: e, y: 3 }
      })
    ).width + 10, this.addComponent(
      new _e({
        label: "score",
        text: ht.score.toString(),
        fontFamily: "PressStart2P",
        fontSize: 16,
        textColor: 13421772,
        position: { x: e, y: 3 },
        bitmap: !0
      })
    ), this._totalLifePoints = it.lifePoints, this._registerToSignal(
      it.signals.loseLifePoints,
      this._removeLifePoints
    ), this._registerToSignal(it.signals.updateScore, this._updateScore);
  }
  get _score() {
    return this.components[this.components.length - 1];
  }
  async _removeLifePoints(e) {
    for (let n = this.components.length - 1; n >= 0 && e > 0; n--)
      if (this.components[n].label.startsWith("life-point-") && (this.removeComponent(this.components[n]), n++, this._totalLifePoints--, e--, this._totalLifePoints === 0)) {
        ht.started = !1, Hc(it.sounds.mainLoop, { fadeDuration: 0.5 }), jn(it.sounds.gameOver), await this.delay(4), Ie(it.signals.gameOver);
        break;
      }
  }
  _updateScore() {
    this._score.text = ht.score.toString();
  }
}
const rh = {
  run: (i, t) => `${i}/run/${i}-run-${t % 8 + 1}.png`,
  jump: (i, t) => t <= 6 ? `${i}/${i}-jump.png` : `${i}/${i}-idle.png`,
  idle: (i, t) => `${i}/${i}-idle.png`
}, lP = 5;
class Qa extends Be {
  constructor(e) {
    super({
      label: "character",
      resource: rh.idle(e, 0),
      scale: { x: 2, y: 2 },
      position: { x: 130, y: -100 }
    });
    mt(this, "_resourceType");
    mt(this, "_moveFrame", 0);
    mt(this, "_moveSprite", 0);
    mt(this, "_moveState", "idle");
    mt(this, "_onGround", !1);
    mt(this, "_currentJump", 0);
    mt(this, "_pressing", !1);
    mt(this, "_pressed", !1);
    mt(this, "_nextIncreaseSpeedMilestone", 0);
    mt(this, "_canDamage", !0);
    this._resourceType = e, Na({
      target: this,
      rectangle: {
        x: this.x + 49,
        y: this.y + 40,
        width: 46,
        height: 64
      },
      movement: {
        linearMovement: {
          velocity: { x: 0, y: 0 }
        }
      },
      onUpdatePosition: this._updatePosition.bind(this)
    });
  }
  jump() {
    this._canJump() && (this._currentJump++, this._changeState("jump"));
  }
  press() {
    !this.hasPressAndRelease || !this._canJump() || (this._pressing = !0, this._setVelocity());
  }
  release() {
    !this.hasPressAndRelease || !this._pressing || !ht.started || (this._pressing = !1, this._pressed = !0, this._currentJump++, this._changeState("jump"));
  }
  async damage() {
    if (!this._canDamage || !ht.started) return;
    this._canDamage = !1, jn(it.sounds.playerHit, { volume: 2 }), Ie(it.signals.loseLifePoints, 1);
    const e = this.tint;
    await this.animate({
      from: { tint: 16763904 },
      to: { tint: 16711680 },
      duration: 0.2,
      repeat: 10,
      revert: !0
    }), this.tint = e, this._canDamage = !0;
  }
  _onTick() {
    ht.started && (this._moveState === "idle" && this._changeState("run"), this._moveFrame++, this._moveFrame % lP === 0 && (this._moveFrame = 0, this._moveSprite++, this.texture = rh[this._moveState](
      this._resourceType,
      this._moveSprite
    )));
  }
  _changeState(e) {
    this._moveState = e, this._moveFrame = 0, this._moveSprite = 0, this.texture = rh[this._moveState](
      this._resourceType,
      this._moveSprite + 1
    ), this._setVelocity();
  }
  _updatePosition(e, n, r) {
    if (!(!ht.started && this._moveState !== "idle")) {
      if (this.x = e - 49, this.y = n - 40, this._onGround = r, this.y > tt.screen.height + 100) {
        Ie(it.signals.loseLifePoints, it.lifePoints);
        return;
      }
      Ie(it.signals.moveScreen, this.x - 130), r && this._moveState !== "run" && ht.started && (this._pressed = !1, this._currentJump = 0, this._changeState("run")), this._canIncreaseSpeed() && (this._nextIncreaseSpeedMilestone > 0 && ht.speed++, this._nextIncreaseSpeedMilestone = this.x + this._increaseSpeedMilestone);
    }
  }
  _canIncreaseSpeed() {
    return this.x >= this._nextIncreaseSpeedMilestone;
  }
  _canJump() {
    return ht.started ? this._moveState === "jump" && this._currentJump < this._totalAllowedJumps ? !0 : this._moveState === "run" && this._onGround : !1;
  }
  _setVelocity() {
    const { x: e, y: n } = this._getNewVelocity();
    jc(this, {
      linearMovement: {
        velocity: { x: e, y: n }
      }
    });
  }
  _getNewVelocity() {
    return this._moveState === "jump" ? {
      x: ht.speed,
      y: this._pressed ? -15 : -10
    } : this._moveState === "run" ? {
      x: this._pressing ? ht.speed / 2 : ht.speed,
      y: 0
    } : { x: 0, y: 0 };
  }
}
class hP extends Be {
  constructor(t, e) {
    super({
      label: `drink-${t.x}-${t.y}`,
      resource: "drink.png",
      position: t,
      scale: { x: 3, y: 3 }
    }), Na({
      target: this,
      rectangle: {
        x: e + this.x,
        y: this.y,
        width: this.width,
        height: this.height
      },
      onCollision: async (n) => {
        ht.started && n instanceof Qa && (ht.score += 10, Ie(it.signals.updateScore), jn(it.sounds.coin, { volume: 2 }), this.destroy());
      }
    }), this.animate({
      from: { y: this.y },
      to: { y: this.y - 5 },
      duration: 1,
      repeat: -1,
      revert: !0
    });
  }
}
const cP = 5;
class uP extends Be {
  constructor(e, n) {
    super({
      label: `position-${e.x}-${e.y}`,
      resource: "zombie/walk/zombie-walk-1.png",
      position: e,
      scale: { x: 0.2, y: 0.2 }
    });
    mt(this, "_started", !1);
    mt(this, "_distance", 0);
    mt(this, "_moveFrame", 0);
    mt(this, "_moveSprite", 0);
    mt(this, "_acceleration", 0);
    this._distance = n, Na({
      target: this,
      rectangle: {
        x: this._distance + this.x,
        y: this.y,
        width: this.width,
        height: this.height
      },
      onUpdatePosition: this._updatePosition.bind(this),
      onCollision: this._onCollision.bind(this)
    }), this._registerToSignal(it.signals.moveScreen, this._onMoveScreen);
  }
  _onTick() {
    !this._started || !ht.started || (this.x + this.width >= 0 ? Sp(this, -1, 0) : (this._acceleration++, Sp(this, 0, this._acceleration)), this._moveFrame++, this._moveFrame % cP === 0 && (this._moveFrame = 0, this._moveSprite++, this.texture = `zombie/walk/zombie-walk-${this._moveSprite % 10 + 1}.png`));
  }
  _updatePosition(e, n) {
    this.x = e - this._distance, this.y = n;
  }
  _onCollision(e) {
    ht.started && e instanceof Qa && e.damage();
  }
  _onMoveScreen(e) {
    ht.started && e + tt.screen.width >= this._distance + this.x && (this._started = !0, jc(this, {
      linearMovement: {
        velocity: { x: -1, y: 0 }
      }
    }), this._unregisterFromSignal(it.signals.moveScreen));
  }
}
class gf extends ei {
  constructor(e, n, r) {
    super({
      label: `platform-${r}`,
      position: { x: r, y: 0 }
    });
    mt(this, "_topOffset", 0);
    this._topOffset = (8 - e) * 32;
    let s = this._topOffset;
    s += this.addComponent(
      new Us({
        label: "platform-top",
        resource: "platform-top.png",
        width: n,
        position: { x: 0, y: s }
      })
    ).height;
    for (let o = 0; o < e; o++)
      s += this.addComponent(
        new Us({
          label: `platform-middle-${o}`,
          resource: "platform-middle.png",
          width: n,
          position: { x: 0, y: s }
        })
      ).height;
    Na({
      target: this,
      rectangle: {
        x: this.x,
        y: this.components[0].position.y + 4,
        width: this.width,
        height: this.height - 4
      },
      surface: !0
    }), this._createDrinks(r), this._createZombies(r);
  }
  _createDrinks(e) {
    let n = e === 0 ? 200 : 0;
    const r = 37, s = 49, o = 5, a = 5;
    for (; n + r <= this.width; ) {
      n += Gi(0, this.width - r);
      const l = this._topOffset - s - Gi(0, o) * s, h = Gi(0, a);
      for (let c = 0; c < h && n + r <= this.width; c++)
        this.addComponent(new hP({ x: n, y: l }, e)), n += r;
      n += 20;
    }
  }
  _createZombies(e) {
    if (e === 0) return;
    const n = 40, r = 61.6;
    let s = Gi(0, 1e3);
    const o = this._topOffset - r;
    for (; s + n <= this.width; )
      this.addComponent(new uP({ x: s, y: o }, e)), s += 300 + Gi(0, this.width - n);
  }
}
class dP extends Qa {
  constructor() {
    super("girl");
  }
  get hasPressAndRelease() {
    return !0;
  }
  get _increaseSpeedMilestone() {
    return 2e4;
  }
  get _totalAllowedJumps() {
    return 1;
  }
}
class pP extends Qa {
  constructor() {
    super("boy");
  }
  get hasPressAndRelease() {
    return !1;
  }
  get _increaseSpeedMilestone() {
    return 1e4;
  }
  get _totalAllowedJumps() {
    return 2;
  }
}
class fP extends ei {
  constructor() {
    super({
      label: "platforms",
      verticalAlignment: "bottom",
      height: 292
    });
    mt(this, "_limit", 0);
    this.addComponent(
      ht.selectedCharacter === "girl" ? new dP() : new pP()
    ), this._limit = this.addComponent(new gf(2, 1e3, 0)).width, this._createPlatforms(), this._registerToSignal(it.signals.moveScreen, this._move);
  }
  get character() {
    return this.components[0];
  }
  _move(e) {
    this.x = -e, this._deleteExpiredPlatforms(), this._createPlatforms();
  }
  _createPlatforms() {
    for (; this._limit + this.x <= W.screen.width + 1e3; ) {
      const e = Gi(1, 8), n = Gi(200, 1500), r = Gi(100, 200);
      this.addComponent(
        new gf(e, n, this._limit + r)
      ), this._limit += r + n;
    }
  }
  _deleteExpiredPlatforms() {
    for (; ; ) {
      const e = this.components[1];
      if (e.x + e.width + 100 < -this.x)
        e.destroy();
      else
        break;
    }
  }
}
class yf extends Br {
  constructor() {
    super(...arguments);
    mt(this, "_cancelClickDebounce", null);
    mt(this, "_keepingClick", !1);
  }
  get _platforms() {
    return this.components[2];
  }
  async init() {
    ht.speed = ht.originalSpeed, ht.score = 0, this.alpha = 0, this.interactive = !0, this.addComponent(new oP()), this.addComponent(new aP()), this.addComponent(new fP()), await Promise.all([
      this.animate({
        from: { alpha: 0 },
        to: { alpha: 1 },
        duration: 1
      }),
      Gc(it.sounds.mainLoop, {
        toVolume: 0.3,
        fadeDuration: 0.5,
        loop: !0
      })
    ]), await this.delay(1), ht.started = !0;
  }
  _onClick() {
    if (!ht.started) return;
    if (!this._platforms.character.hasPressAndRelease) {
      this._platforms.character.jump();
      return;
    }
    this._keepingClick = !1;
    const { start: e, cancel: n } = Wc(
      () => {
        this._keepingClick = !0, this._platforms.character.press();
      },
      () => {
      },
      300,
      0
    );
    this._cancelClickDebounce = n, e();
  }
  _onPointerUp() {
    var e;
    !ht.started || !this._platforms.character.hasPressAndRelease || ((e = this._cancelClickDebounce) == null || e.call(this), this._cancelClickDebounce = null, this._keepingClick ? this._platforms.character.release() : this._platforms.character.jump());
  }
}
const mP = [
  {
    name: "default",
    assets: [
      {
        alias: [
          "audio/sounds.json"
        ],
        src: [
          "audio/sounds-EgVUtQ.json"
        ],
        data: {
          tags: {}
        }
      },
      {
        alias: [
          "audio/sounds.mp3"
        ],
        src: [
          "audio/sounds-wkfo.mp3",
          "audio/sounds-nYlG.ogg"
        ],
        data: {
          tags: {}
        }
      },
      {
        alias: [
          "default"
        ],
        src: [
          "default-vbWOIQ@0.5x.png.json",
          "default-uhPi.png.json",
          "default-PxBCOQ.webp.json",
          "default-Hk_gWQ@0.5x.avif.json",
          "default-h9YFuA.avif.json",
          "default-ca-T0Q@0.5x.webp.json"
        ],
        data: {
          tags: {
            tps: !0
          }
        }
      }
    ]
  }
], gP = {
  bundles: mP
};
class yP extends Br {
  async init() {
    this.addComponent(
      new _e({
        label: "game-over",
        text: "Game Over",
        fontFamily: W.loadingScene.fontFamily,
        fontSize: 48,
        textColor: W.loadingScene.textColor,
        anchor: { x: 0.5, y: 0.5 },
        horizontalAlignment: "center",
        verticalAlignment: "center",
        margin: { x: 0, y: -50 }
      })
    ), this.addComponent(
      new _e({
        label: "score",
        text: `Your score is ${ht.score}`,
        fontFamily: W.loadingScene.fontFamily,
        fontSize: 28,
        textColor: W.loadingScene.textColor,
        anchor: { x: 0.5, y: 0.5 },
        horizontalAlignment: "center",
        verticalAlignment: "center",
        margin: { x: 0, y: 50 }
      })
    ), eP(ht.score), this.delay(2).then(() => Ie(it.signals.goToGame));
  }
}
const SP = (i) => {
  const t = new URLSearchParams(window.location.search ?? ""), e = hs(
    W.signals.destroyLoadingScene,
    () => {
      Zo(
        e.name,
        e.binding
      ), fs(
        t.has("character") ? new yf() : new RA()
      );
    }
  ), n = hs(it.signals.goToIntro, () => {
    Zo(n.name, n.binding), fs(new sP());
  });
  hs(it.signals.goToGame, () => {
    fs(new yf());
  }), hs(it.signals.gameOver, () => {
    fs(new yP());
  }), W.gameName = "couples-run", W.assets.basePath = i.assetsBasePath, W.maxFPS = Number(t.get("maxFPS")) || 60, W.debug = !!t.get("debug"), W.assets.manifest = gP, W.assets.extra = [
    { alias: "Lobster", src: kA, data: { family: "Lobster" } },
    {
      alias: "PressStart2P",
      src: MA,
      data: { family: "PressStart2P" }
    }
  ], it.creditsUrl = i.creditsUrl, it.privacyPolicyUrl = i.privacyPolicyUrl, ht.selectedCharacter = t.get("character") === "boy" ? "boy" : "girl", gA(), iP();
};
export {
  ut as $,
  me as A,
  vx as B,
  ge as C,
  X as D,
  Ch as E,
  _x as F,
  Ax as G,
  ct as H,
  Te as I,
  Ex as J,
  xx as K,
  Tx as L,
  Cx as M,
  Px as N,
  Mt as O,
  jt as P,
  ld as Q,
  Pe as R,
  Ri as S,
  xe as T,
  t_ as U,
  Rd as V,
  nt as W,
  An as X,
  Jf as Y,
  mm as Z,
  fh as _,
  em as a,
  Pa as a0,
  sv as a1,
  lm as a2,
  H_ as a3,
  kd as a4,
  Y_ as a5,
  pc as a6,
  sm as a7,
  zf as a8,
  bi as a9,
  Rx as aa,
  If as ab,
  xd as ac,
  kf as ad,
  Ac as ae,
  M_ as af,
  vr as ag,
  h_ as ah,
  C_ as ai,
  qt as aj,
  wd as ak,
  Ov as al,
  wl as am,
  hm as an,
  ov as ao,
  SP as ap,
  Ji as b,
  Lt as c,
  ch as d,
  Tm as e,
  Sb as f,
  It as g,
  Cm as h,
  av as i,
  $d as j,
  Eh as k,
  ks as l,
  _v as m,
  Dn as n,
  Th as o,
  Gt as p,
  $_ as q,
  tp as r,
  Md as s,
  yr as t,
  dt as u,
  vb as v,
  Ii as w,
  fc as x,
  yx as y,
  Fo as z
};
